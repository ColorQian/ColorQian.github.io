<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>进程的调度</title>
      <link href="/posts/c59b.html"/>
      <url>/posts/c59b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>序</p></blockquote><p>进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。</p><p>一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执行了，于是操作系统会选择下一个要运行的进程。</p><p>选择一个进程运行这一功能是在操作系统中完成的，通常称为<strong>调度程序</strong>（<em>scheduler</em>）。</p><p>那到底什么时候调度进程，或以什么原则来调度进程呢？</p><h1 id="1-调度时机"><a href="#1-调度时机" class="headerlink" title="1. 调度时机"></a>1. 调度时机</h1><p>在进程的生命周期中，当进程从一个运行状态到另外一状态变化的时候，其实会触发一次调度。</p><p>比如，以下状态的变化都会触发操作系统的调度：</p><ul><li><em>从就绪态 -&gt; 运行态</em>：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；</li><li><em>从运行态 -&gt; 阻塞态</em>：当进程发生 I/O 事件而阻塞时，操作系统必须另外一个进程运行；</li><li><em>从运行态 -&gt; 结束态</em>：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；</li></ul><p>因为，这些状态变化的时候，操作系统需要考虑是否要让新的进程给 CPU 运行，或者是否让当前进程从 CPU 上退出来而换另一个进程运行。</p><p>另外，如果硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断<br>，把调度算法分为两类：</p><ul><li><strong>非抢占式调度算法</strong>挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。</li><li><strong>抢占式调度算法</strong>挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生<strong>时钟中断</strong>，以便把 CPU 控制返回给调度程序进行调度，也就是常说的<strong>时间片机制</strong>。</li></ul><h1 id="2-调度原则"><a href="#2-调度原则" class="headerlink" title="2. 调度原则"></a>2. 调度原则</h1><p><em>原则一</em>：如果运行的程序，发生了 I/O 事件的请求，那 CPU 使用率必然会很低，因为此时进程在阻塞等待硬盘的数据返回。这样的过程，势必会造成 CPU 突然的空闲。所以，<strong>为了提高 CPU 利用率，在这种发送 I/O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。</strong></p><p><em>原则二</em>：有的程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量（CPU 在单位时间内完成的进程数量）的降低。所以，<strong>要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。</strong></p><p><em>原则三</em>：从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，<strong>如果进程的等待时间很长而运行时间很短，那周转时间就很长，这不是我们所期望的，调度程序应该避免这种情况发生。</strong></p><p><em>原则四</em>：处于就绪队列的进程，也不能等太久，当然希望这个等待的时间越短越好，这样可以使得进程更快的在 CPU 中执行。所以，<strong>就绪队列中进程的等待时间也是调度程序所需要考虑的原则。</strong></p><p><em>原则五</em>：对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，<strong>对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则。</strong></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211123151032.png"></p><p>针对上面的五种调度原则，总结成如下：</p><ul><li><strong>CPU 利用率</strong>：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；</li><li><strong>系统吞吐量</strong>：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；</li><li><strong>周转时间</strong>：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好；</li><li><strong>等待时间</strong>：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；</li><li><strong>响应时间</strong>：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。</li></ul><p>说白了，这么多调度原则，目的就是要使得进程要「快」。</p><h1 id="3-调度算法"><a href="#3-调度算法" class="headerlink" title="3. 调度算法"></a>3. 调度算法</h1><blockquote><p>01、先来先服务调度算法</p></blockquote><p>最简单的一个调度算法，就是非抢占式的<strong>先来先服务（*First Come First Seved, FCFS*）算法</strong>了。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211123151903.jpeg"></p><p>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p><p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p><p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。</p><blockquote><p>02、最短作业优先调度算法</p></blockquote><p><strong>最短作业优先（*Shortest Job First, SJF*）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211123152036.jpeg"></p><p>这显然对长作业不利，很容易造成一种极端现象。</p><p>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p><blockquote><p>03、高响应比优先调度算法</p></blockquote><p>前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。</p><p>那么，<strong>高响应比优先<br>（*Highest Response Ratio Next, HRRN*）调度算法</strong>主要是权衡了短作业和长作业。</p><p><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>，「响应比优先级」的计算公式：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211123152356.jpeg"></p><p>从上面的公式，可以发现：</p><ul><li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li><li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</li></ul><blockquote><p>04、时间片轮转调度算法</p></blockquote><p>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211123152657.jpeg"></p><p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul><p>另外，时间片的长度就是一个很关键的点：</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果设得太长又可能引起对短作业进程的响应时间变长。</li></ul><p>一般来说，将时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p><blockquote><p>05、最高优先级调度算法</p></blockquote><p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p><p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</p><p>进程的优先级可以分为，静态优先级和动态优先级：</p><ul><li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li><li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li></ul><p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p><ul><li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li><li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p><blockquote><p>06、多级反馈队列调度算法</p></blockquote><p><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p><p>顾名思义：</p><ul><li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211123153306.jpeg"></p><p>来看看，它是如何工作的：</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li><li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li></ul><p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p><hr><p>以上内容参考公众号：<strong>小林coding</strong></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211123153427.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图解系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 调度 </tag>
            
            <tag> 进程的调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程的基础知识</title>
      <link href="/posts/ccfc.html"/>
      <url>/posts/ccfc.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是线程？"><a href="#1-什么是线程？" class="headerlink" title="1.什么是线程？"></a>1.什么是线程？</h1><p>线程是进程当中的一条执行流程，线程之间可以并发运行且共享相同的地址空间。</p><p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211122211358.png" alt="image-20211122211350853"></p><h1 id="2-线程的优缺点"><a href="#2-线程的优缺点" class="headerlink" title="2.线程的优缺点"></a>2.线程的优缺点</h1><blockquote><p>线程的优点</p></blockquote><p>一个进程中可以存在多个线程；</p><p>各个线程之间可以并发执行；</p><p>各个线程之间可以共享地址空间和文件等资源。</p><blockquote><p>线程的缺点</p></blockquote><p>当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃。</p><p>举个例子，对于游戏的用户设计，则不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程。</p><h1 id="3-进程与线程"><a href="#3-进程与线程" class="headerlink" title="3.进程与线程"></a>3.进程与线程</h1><h2 id="3-1进程与线程的比较"><a href="#3-1进程与线程的比较" class="headerlink" title="3.1进程与线程的比较"></a>3.1进程与线程的比较</h2><p>进程是资源(包括内存、打开的文件等)分配的单位，线程是CPU调度的单位；</p><p>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</p><p>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</p><p>线程能减少并发执行的时间和空间开销；</p><blockquote><p>对于，线程相比进程能减少开销，体现在:</p></blockquote><p>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</p><p>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</p><p>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</p><p>由于同一进程的各线程间共享内存和文件资源，那么<strong>在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了</strong>；</p><p>所以，不管是时间效率，还是空间效率线程比进程都要高。</p><h1 id="4-线程的上下文切换"><a href="#4-线程的上下文切换" class="headerlink" title="4.线程的上下文切换"></a>4.线程的上下文切换</h1><p>在前面我们知道了，线程与进程最大的区别在于：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</p><p>所以，所谓操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。</p><p>对于线程和进程，我们可以这么理解：</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程；</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；</li></ul><p>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p><blockquote><p>线程上下文切换的是什么？</p></blockquote><p>这还得看线程是不是属于同一个进程：</p><ul><li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li><li><strong>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</strong>；</li></ul><p>所以，线程的上下文切换相比进程，开销要小很多。</p><br><h1 id="5-线程的实现"><a href="#5-线程的实现" class="headerlink" title="5.线程的实现"></a>5.线程的实现</h1><p>主要有三种线程的实现方式：</p><ul><li><strong>用户线程（<em>User Thread</em>）</strong>：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</li><li><strong>内核线程（<em>Kernel Thread</em>）</strong>：在内核中实现的线程，是由内核管理的线程；</li><li><strong>轻量级进程（<em>LightWeight Process</em>）</strong>：在内核中来支持用户线程；</li></ul><p>那么，这还需要考虑一个问题，用户线程和内核线程的对应关系。</p><blockquote><p>首先，第一种关系是<strong>多对一</strong>的关系，也就是多个用户线程对应同一个内核线程：</p></blockquote><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211122215929.png" alt="image-20211122215928419"></p><blockquote><p>第二种是<strong>一对一</strong>的关系，也就是一个用户线程对应一个内核线程：</p></blockquote><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211122220011.png" alt="image-20211122220010608"></p><blockquote><p>第三种是<strong>多对多</strong>的关系，也就是多个用户线程对应到多个内核线程：</p></blockquote><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211122220044.png" alt="image-20211122220043866"></p><br><h2 id="5-1-用户级线程"><a href="#5-1-用户级线程" class="headerlink" title="5.1 用户级线程"></a>5.1 用户级线程</h2><blockquote><p>用户线程如何理解？存在什么优势和缺陷？</p></blockquote><p>用户线程是基于用户态的线程管理库来实现的，那么<strong>线程控制块（<em>Thread Control Block, TCB</em>）</strong> 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。</p><p>所以，<strong>用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。</strong></p><p>用户级线程的模型，也就类似前面提到的<strong>多对一</strong>的关系，即多个用户线程对应同一个内核线程，如下图所示：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211122221307.png" alt="image-20211122221306246"></p><blockquote><p>用户线程的优点</p></blockquote><p>每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；</p><p>用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；</p><blockquote><p>用户线程的缺点</p></blockquote><ul><li>由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。</li><li>当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。</li><li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；</li></ul><h2 id="5-2-内核级线程"><a href="#5-2-内核级线程" class="headerlink" title="5.2 内核级线程"></a>5.2 内核级线程</h2><blockquote><p>内核线程如何理解？存在什么优势和缺陷？</p></blockquote><p><strong>内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。</strong></p><p>内核线程的模型，也就类似前面提到的<strong>一对一</strong>的关系，即一个用户线程对应一个内核线程，如下图所示：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211122222511.png" alt="image-20211122222510157"></p><blockquote><p>内核级线程的优缺点</p></blockquote><p>内核线程的<strong>优点</strong>：</p><ul><li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；</li><li>分配给线程，多线程的进程获得更多的 CPU 运行时间；</li></ul><p>内核线程的<strong>缺点</strong>：</p><ul><li>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；</li><li>线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；</li></ul><h2 id="5-3-轻量级进程"><a href="#5-3-轻量级进程" class="headerlink" title="5.3 轻量级进程"></a>5.3 轻量级进程</h2><p><strong>轻量级进程（*Light-weight process，LWP*）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持。</strong></p><p>另外，LWP 只能由内核管理并像普通进程一样被调度，Linux 内核是支持 LWP 的典型例子。</p><p>在大多数系统中，<strong>LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息</strong>。一般来说，一个进程代表程序的一个实例，而 LWP 代表程序的执行线程，因为一个执行线程不像进程那样需要那么多状态信息，所以 LWP 也不带有这样的信息。</p><p>在 LWP 之上也是可以使用用户线程的，那么 LWP 与用户线程的对应关系就有三种：</p><ul><li><code>1 : 1</code>，即一个 LWP 对应 一个用户线程；</li><li><code>N : 1</code>，即一个 LWP 对应多个用户线程；</li><li><code>M : N</code>，即多个 LWP 对应多个用户线程；</li></ul><p>接下来针对上面这三种对应关系说明它们优缺点。先看下图的 LWP 模型：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211122223422.png" alt="image-20211122223420867"></p><p><strong>1 : 1 模式</strong></p><p>一个线程对应到一个 LWP 再对应到一个内核线程，如上图的进程 4，属于此模型。</p><ul><li>优点：实现并行，当一个 LWP 阻塞，不会影响其他 LWP；</li><li>缺点：每一个用户线程，就产生一个内核线程，创建线程的开销较大。</li></ul><p><strong>N : 1 模式</strong></p><p>多个用户线程对应一个 LWP 再对应一个内核线程，如上图的进程 2，线程管理是在用户空间完成的，此模式中用户的线程对操作系统不可见。</p><ul><li>优点：用户线程要开几个都没问题，且上下文切换发生用户空间，切换的效率较高；</li><li>缺点：一个用户线程如果阻塞了，则整个进程都将会阻塞，另外在多核 CPU 中，是没办法充分利用 CPU 的。</li></ul><p><strong>M : N 模式</strong></p><p>根据前面的两个模型混搭一起，就形成 <code>M:N</code> 模型，该模型提供了两级控制，首先多个用户线程对应到多个 LWP，LWP 再一一对应到内核线程，如上图的进程 3。</p><ul><li>优点：综合了前两种优点，大部分的线程上下文发生在用户空间，且多个线程又可以充分利用多核 CPU 的资源。</li></ul><p><strong>组合模式</strong></p><p>如上图的进程 5，此进程结合 <code>1:1</code> 模型和 <code>M:N</code> 模型。开发人员可以针对不同的应用特点调节内核线程的数目来达到物理并行性和逻辑并行性的最佳方案。</p><hr><p>以上内容参考公众号：<strong>小林coding</strong></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018151438.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图解系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议分层模型</title>
      <link href="/posts/f45d.html"/>
      <url>/posts/f45d.html</url>
      
        <content type="html"><![CDATA[<p>TCP/IP分层模型：</p><p>硬件层、网卡层、互联网层、传输层、应用层</p><h1 id="1-硬件层-物理层"><a href="#1-硬件层-物理层" class="headerlink" title="1.硬件层(物理层)"></a>1.硬件层(物理层)</h1><p>TCP/IP最底层是负责数据传输的硬件。这种硬件就相当于以太网或电话线路等物理层设备。关于它的内容一直无法统一的定义。</p><p>TCP/IP是在网络互连的设备之间能够通信的前提下才被提出的协议。</p><h1 id="2-网络接口层（数据链路层）"><a href="#2-网络接口层（数据链路层）" class="headerlink" title="2.网络接口层（数据链路层）"></a>2.网络接口层（数据链路层）</h1><p>网络接口层利用以太网中的数据链路层进行通信，因此属于接口层。也就是说，把它当成让NIC(网络接口卡)起作用的“驱动程序”也无妨。驱动程序是在操作系统与硬件之间起桥梁作用的软件。</p><h1 id="3-互联网层（网络层）"><a href="#3-互联网层（网络层）" class="headerlink" title="3.互联网层（网络层）"></a>3.互联网层（网络层）</h1><p>互联网层使用IP协议，它相当于OSI模型中的第3层网络层。IP协议基于IP地址转发分包数据。</p><p><strong>IP协议的作用是将分组数据包发送到目的主机。</strong></p><p>TCP/IP分层中的互联网层与传输层的功能通常由操作系统提供。尤其是路由器，它必须得实现通过互联网层转发分组数据包的功能。</p><p>此外，连接互联网的所有主机跟路由器都必须实现IP功能。其它网络设备则没必要一定实现IP或TCP的功能。</p><h2 id="3-1-IP"><a href="#3-1-IP" class="headerlink" title="3.1 IP"></a>3.1 IP</h2><ul><li>IP是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一端，这期间它使用IP地址作为主机的标识。</li><li>IP还隐含着数据链路层的功能。通过IP,相互通信的主机之间不论经过怎样的底层数据链路都能够实现通信。</li><li>虽然IP也是分组交换的一种协议，但它不具有重发机制。即是数据未能到达对端主机，也不会重发。因此属于非可靠传输协议。</li></ul><h2 id="3-2-ICMP"><a href="#3-2-ICMP" class="headerlink" title="3.2 ICMP"></a>3.2 ICMP</h2><p>IP数据包在发送途中一旦发生异常导致无法到达对端目标时，需要给发送端发送一个发生异常的通知。ICMP就是为这一功能而制定的。它有时也被用来诊断网络的健康状况。</p><h2 id="3-3-ARP"><a href="#3-3-ARP" class="headerlink" title="3.3 ARP"></a>3.3 ARP</h2><p>从分组数据包的IP地址中解析出物理地址（MAC地址）的一种协议。</p><h1 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h1><p><strong>传输层最主要的功能就是能够让应用程序之间实现通信</strong>，识别不同的应用程序使用端口号。</p><blockquote><p>TCP</p></blockquote><p>TCP是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP还能够有效利用带宽，缓解网络拥堵。</p><p>然而，为了建立与断开连接，有时它至少需要7次的发包收包，导致网络流量的浪费。此外，为了提高网络的利用率，TCP协议中定义了各种各样复杂的规范，因此不利于视频会议(音频、视频的数据量既定)等场合的使用。</p><blockquote><p>UDP</p></blockquote><p>UDP有别于TCP,它是一种面向无连接的传输层协议。UDP不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。</p><p>UDP常用于分组数据较少或多播、广播通信以及视频通信等多媒体领域。</p><h1 id="5-应用层（会话层以上的分层）"><a href="#5-应用层（会话层以上的分层）" class="headerlink" title="5.应用层（会话层以上的分层）"></a>5.应用层（会话层以上的分层）</h1><p>TCP/IP模型的分层中，将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这些功能有时由一个单一的程序实现，有时也有可能会由多个程序实现。因此，细看TCP/IP的应用程序功能会发现，它不仅实现了OSI模型中应用层的内容，还要实现会话层与表示层的功能。</p><hr><p>以上内容参考：《图解TCP/IP》</p>]]></content>
      
      
      <categories>
          
          <category> 图解TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 分层模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程的基础知识</title>
      <link href="/posts/91b5.html"/>
      <url>/posts/91b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-进程的概念"><a href="#1-进程的概念" class="headerlink" title="1.进程的概念"></a>1.进程的概念</h1><p>​        我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个<strong>运行中的程序，就被称为「进程」（Process）</strong>。</p><p>操作系统管理进程的核心:<strong>多个进程，交替执行。</strong></p><h1 id="2-进程的状态"><a href="#2-进程的状态" class="headerlink" title="2.进程的状态"></a>2.进程的状态</h1><p><strong>在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。</strong></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211023161955.png"></p><blockquote><p>上图中各个状态的意义：</p></blockquote><ul><li>运行状态（<em>Runing</em>）：该时刻进程占用 CPU；</li><li>就绪状态（<em>Ready</em>）：可运行，由于其他进程处于运行状态而暂时停止运行；</li><li>阻塞状态（<em>Blocked</em>）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；</li></ul><blockquote><p>当然，进程还有另外两个基本状态：</p></blockquote><ul><li>创建状态（<em>new</em>）：进程正在被创建时的状态；</li><li>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；</li></ul><p>于是，一个完整的进程状态的变迁如下图:</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211023162315.png"></p><blockquote><p>再来详细说明一下进程的状态变迁：</p></blockquote><ul><li><em>NULL -&gt; 创建状态</em>：一个新进程被创建时的第一个状态；</li><li><em>创建状态 -&gt; 就绪状态</em>：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；</li><li><em>就绪态 -&gt; 运行状态</em>：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；</li><li><em>运行状态 -&gt; 结束状态</em>：当进程已经运行完成或出错时，会被操作系统作结束状态处理；</li><li><em>运行状态 -&gt; 就绪状态</em>：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；</li><li><em>运行状态 -&gt; 阻塞状态</em>：当进程请求某个事件且必须等待时，例如请求 I/O 事件；</li><li><em>阻塞状态 -&gt; 就绪状态</em>：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；</li></ul><br><blockquote><p>进程的挂起状态</p></blockquote><p>如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，显然不是我们所希望的，毕竟物理内存空间是有限的，被阻塞状态的进程占用着物理内存就一种浪费物理内存的行为。</p><p>所以，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211023162844.png"></p><p>那么，就需要一个新的状态，来<strong>描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态</strong>。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。</p><p>另外，挂起状态可以分为两种：</p><ul><li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li><li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；</li></ul><p>这两种挂起状态加上前面的五种状态，就变成了七种状态变迁（留给我的颜色不多了），见如下图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211023163832.png"></p><p>导致进程挂起的原因不只是因为进程所使用的内存空间不在物理内存，还包括如下情况：</p><ul><li>通过 sleep 让进程间歇性挂起，其工作原理是设置一个定时器，到期后唤醒进程。</li><li>用户希望挂起一个程序的执行，比如在 Linux 中用 <code>Ctrl+Z</code> 挂起进程；</li></ul><br><h1 id="3-进程的控制结构"><a href="#3-进程的控制结构" class="headerlink" title="3.进程的控制结构"></a>3.进程的控制结构</h1><p>在操作系统中，是用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程的。</p><p><strong>PCB 是进程存在的唯一标识</strong>，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。</p><blockquote><p>PCB具体包含什么信息呢？</p></blockquote><p><strong>进程描述信息：</strong></p><ul><li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li><li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li></ul><p><strong>进程控制和管理信息：</strong></p><ul><li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li><li>进程优先级：进程抢占 CPU 时的优先级；</li></ul><p><strong>资源分配清单：</strong></p><ul><li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。</li></ul><p><strong>CPU 相关信息：</strong></p><ul><li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</li></ul><blockquote><p>每个PCB是如何组织的呢？</p></blockquote><p>通常是通过<strong>链表</strong>的方式进行组织，把具有<strong>相同状态的进程链在一起，组成各种队列</strong>。比如：</p><ul><li>将所有处于就绪状态的进程链在一起，称为<strong>就绪队列</strong>；</li><li>把所有因等待某事件而处于等待状态的进程链在一起就组成各种<strong>阻塞队列</strong>；</li><li>另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211023170059.png"></p><p>除了链接的组织方式，还有索引方式，它的工作原理：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。</p><p>一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。</p><br><h1 id="4-进程的控制"><a href="#4-进程的控制" class="headerlink" title="4.进程的控制"></a>4.进程的控制</h1><blockquote><p>我们熟知了进程的状态变迁和进程的数据结构 PCB 后，再来看看进程的<strong>创建、终止、阻塞、唤醒</strong>的过程，这些过程也就是进程的控制。</p></blockquote><p><strong>01 创建进程</strong></p><p>操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止时，其在父进程处继承的资源应当还给父进程。同时，终止父进程时同时也会终止其所有的子进程。</p><p>注意：Linux 操作系统对于终止有子进程的父进程，会把子进程交给 1 号进程接管。本文所指出的进程终止概念是宏观操作系统的一种观点，最后怎么实现当然是看具体的操作系统。</p><p>创建进程的过程如下：</p><ul><li>为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB，PCB 是有限的，若申请失败则创建失败；</li><li>为进程分配资源，此处如果资源不足，进程就会进入等待状态，以等待资源；</li><li>初始化 PCB；</li><li>如果进程的调度队列能够接纳新进程，那就将进程插入到就绪队列，等待被调度运行；</li></ul><p><strong>02 终止进程</strong></p><p>进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 <code>kill</code> 掉）。</p><p>终止进程的过程如下：</p><ul><li>查找需要终止的进程的 PCB；</li><li>如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；</li><li>如果其还有子进程，则应将其所有子进程终止；</li><li>将该进程所拥有的全部资源都归还给父进程或操作系统；</li><li>将其从 PCB 所在队列中删除；</li></ul><p><strong>03 阻塞进程</strong></p><p>当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。</p><p>阻塞进程的过程如下：</p><ul><li>找到将要被阻塞进程标识号对应的 PCB；</li><li>如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；</li><li>将该 PCB 插入到阻塞队列中去；</li></ul><p><strong>04 唤醒进程</strong></p><p>进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。</p><p>如果某进程正在等待 I/O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。</p><p>唤醒进程的过程如下：</p><ul><li>在该事件的阻塞队列中找到相应进程的 PCB；</li><li>将其从阻塞队列中移出，并置其状态为就绪状态；</li><li>把该 PCB 插入到就绪队列中，等待调度程序调度；</li></ul><p>进程的阻塞和唤醒是一对功能相反的语句，如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句。</p><br><h1 id="5-进程的上下文切换"><a href="#5-进程的上下文切换" class="headerlink" title="5.进程的上下文切换"></a>5.进程的上下文切换</h1><blockquote><p>CPU上下文切换</p></blockquote><p>各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个<strong>一个进程切换到另一个进程运行，称为进程的上下文切换</strong>。</p><blockquote><p>在详细说进程上下文切换前，我们先来看看 CPU 上下文切换</p></blockquote><p>大多数操作系统都是多任务，通常支持大于 CPU 数量的任务同时运行。实际上，这些任务并不是同时运行的，只是因为系统在很短的时间内，让各个任务分别在 CPU 运行，于是就造成同时运行的错觉。</p><p>任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。</p><p>所以，操作系统需要事先帮 CPU 设置好 <strong>CPU 寄存器和程序计数器</strong>。</p><p>CPU 寄存器是 CPU 内部一个容量小，但是速度极快的内存（缓存）。我举个例子，寄存器像是你的口袋，内存像你的书包，硬盘则是你家里的柜子，如果你的东西存放到口袋，那肯定是比你从书包或家里柜子取出来要快的多。</p><p>再来，程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。</p><p><strong>所以说，CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 CPU 上下文。</strong></p><p><strong>CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</strong></p><p>系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p><br><blockquote><p>进程的上下文切换</p></blockquote><p>上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：<strong>进程上下文切换、线程上下文切换和中断上下文切换</strong>。</p><p><strong>进程是由内核管理和调度的，所以进程的切换只能发生在内核态。</strong></p><p>所以，<strong>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</strong></p><p>通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211023171443.png"></p><p>大家需要注意，进程的上下文开销是很关键的，我们希望它的开销越小越好，这样可以使得进程可以把更多时间花费在执行程序上，而不是耗费在上下文切换。</p><blockquote><p>发生进程上下文切换有哪些场景？</p></blockquote><ul><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；</li><li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；</li><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；</li></ul><p>以上，就是发生进程上下文切换的常见场景了。</p><hr><p>以上内容参考公众号：<strong>小林coding</strong></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018151438.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图解系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 进程的状态 </tag>
            
            <tag> PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="/posts/9a8a.html"/>
      <url>/posts/9a8a.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-虚拟内存"><a href="#1-虚拟内存" class="headerlink" title="1.虚拟内存"></a>1.虚拟内存</h1><ul><li><p>操作系统为每个进程分配一套<strong>虚拟地址</strong>，这样就可以把每个进程所使用的地址隔离开来。但是有个前提，每个进程都不能直接访问物理地址，而是需要通过虚拟地址映射到物理地址上</p></li><li><p>操作系统会提供一种机制，将不同进程的虚拟地址和不同的物理内存地址映射起来</p></li><li><p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211017221801.png"></p><hr><p>操作系统如何管理虚拟地址和物理地址之间的关系？</p><p>主要由<strong>内存分段和内存分页</strong></p><h1 id="2-内存分段"><a href="#2-内存分段" class="headerlink" title="2.内存分段"></a>2.内存分段</h1><ul><li>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段（<em>Segmentation</em>）的形式把这些段分离出来</strong>。</li></ul><h2 id="1-虚拟地址和物理地址的映射关系"><a href="#1-虚拟地址和物理地址的映射关系" class="headerlink" title="1.虚拟地址和物理地址的映射关系"></a>1.虚拟地址和物理地址的映射关系</h2><blockquote><p>分段机制下，虚拟地址和物理地址是如何映射的？</p></blockquote><ul><li>分段机制下的虚拟地址由两部分组成，<strong>段选择子</strong>和<strong>段内偏移量</strong>。</li><li>虚拟地址是通过<strong>段表</strong>与物理地址进行映射的</li><li><strong>段选择子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li><li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018133710.png"></p><br><p>举例说明内存分段机制下，虚拟地址和物理地址之间的映射关系：</p><ul><li>虚拟地址是通过<strong>段表</strong>与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018134016.png"></p><p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。</p><p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：</p><ul><li>第一个就是<strong>内存碎片</strong>的问题。</li><li>第二个就是<strong>内存交换的效率低</strong>的问题。</li></ul><br><h2 id="2-内存碎片"><a href="#2-内存碎片" class="headerlink" title="2.内存碎片"></a>2.内存碎片</h2><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018134751.png"></p><p>这里的内存碎片的问题共有两处地方：</p><ul><li>外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；</li><li>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；</li></ul><p>针对上面两种内存碎片的问题，解决的方式会有所不同。</p><p>解决外部内存碎片的问题就是<strong>内存交换</strong>。</p><h2 id="3-内存交换"><a href="#3-内存交换" class="headerlink" title="3.内存交换"></a>3.内存交换</h2><p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p><p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p><blockquote><p>再来看看，分段为什么会导致内存交换效率低的问题？</p></blockquote><p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 <code>Swap</code> 内存区域，这个过程会产生性能瓶颈。</p><p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p><p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p><p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。</p><br><h1 id="3-内存分页"><a href="#3-内存分页" class="headerlink" title="3.内存分页"></a>3.内存分页</h1><p>分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。</p><p>要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是<strong>内存分页</strong>（<em>Paging</em>）。</p><p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</p><h2 id="1-虚拟地址和物理地址的映射关系-1"><a href="#1-虚拟地址和物理地址的映射关系-1" class="headerlink" title="1.虚拟地址和物理地址的映射关系"></a>1.虚拟地址和物理地址的映射关系</h2><p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，如下图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018135901.png"></p><ul><li>页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。</li><li>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</li></ul><br><ul><li>分页是怎么解决分段的内存碎片、内存交换效率低的问题？</li></ul><p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而<strong>采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</strong>(不会产生内存分段那种大的内存碎片)</p><p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong>(内存交换的开销小，效率高)</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018141405.png"></p><ul><li>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></li></ul><br><p><strong>分页机制下，虚拟地址和物理地址是如何映射的？</strong></p><ul><li>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018141854.png"></p><p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p><ul><li>把虚拟内存地址，切分成页号和偏移量；</li><li>根据页号，从页表里面，查询对应的物理页号；</li><li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li></ul><br><p>简单的分页有什么缺陷吗？(消耗过多的内存空间)</p><p>因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。</p><p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 <code>4MB</code> 的内存来存储页表。</p><p>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。</p><p>那么，<code>100</code> 个进程的话，就需要 <code>400MB</code> 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。</p><br><hr><h2 id="2-多级页表"><a href="#2-多级页表" class="headerlink" title="2.多级页表"></a>2.多级页表</h2><p>要解决上面的问题，就需要采用一种叫作<strong>多级页表</strong>（<em>Multi-Level Page Table</em>）的解决方案。</p><p>在前面我们知道了，对于单页表的实现方式，在 32 位和页大小 <code>4KB</code> 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。</p><p>我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code>个「页表项」，形成<strong>二级分页</strong>。如下图所示：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018143847.png"></p><blockquote><p>你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？</p></blockquote><p>当然如果 4GB 的虚拟地址全部都映射到了物理内存上的话，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。</p><p>其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的<strong>局部性原理</strong>么？</p><p>每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p><p>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表</strong>。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= <code>0.804MB</code>，这对比单级页表的 <code>4MB</code> 是不是一个巨大的节约？</p><p>那么为什么不分级的页表就做不到这样节约内存呢？我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以<strong>页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项</strong>（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。</p><p>我们把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。</p><br><p>对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：</p><ul><li>全局页目录项 PGD（<em>Page Global Directory</em>）；</li><li>上层页目录项 PUD（<em>Page Upper Directory</em>）；</li><li>中间页目录项 PMD（<em>Page Middle Directory</em>）；</li><li>页表项 PTE（<em>Page Table Entry</em>）；</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018144321.png"></p><br><h2 id="3-TLB-Translation-Lookaside-Buffer-页表缓存、快表"><a href="#3-TLB-Translation-Lookaside-Buffer-页表缓存、快表" class="headerlink" title="3.TLB(Translation Lookaside Buffer)-页表缓存、快表"></a>3.TLB(<em>Translation Lookaside Buffer</em>)-页表缓存、快表</h2><ul><li><p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。</p></li><li><p>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</p></li></ul><p>我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，通常称为页表缓存、转址旁路缓存、快表等。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018145704.png"></p><p>在 CPU 芯片里面，封装了内存管理单元（<em>Memory Management Unit</em>）芯片，它用来完成地址转换和 TLB 的访问与交互。</p><p>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。</p><p>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。</p><br><hr><h2 id="4-段页式内存管理"><a href="#4-段页式内存管理" class="headerlink" title="4.段页式内存管理"></a>4.段页式内存管理</h2><p>段页式内存管理实现的方式：</p><ul><li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li><li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li></ul><p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。</p><p>用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018150429.png"></p><p>段页式地址变换中要得到物理地址须经过三次内存访问：</p><ul><li>第一次访问段表，得到页表起始地址；</li><li>第二次访问页表，得到物理页号；</li><li>第三次将物理页号与页内位移组合，得到物理地址。</li></ul><p>可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。</p><br><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><ul><li><p>为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套<strong>虚拟地址空间</strong>，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。</p></li><li><p>每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过<strong>内存交换</strong>技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。</p></li><li><p>那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。</p></li><li><p>那么对于虚拟地址与物理地址的映射关系，可以有<strong>分段</strong>和<strong>分页</strong>的方式，同时两者结合都是可以的。</p></li><li><p>内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致内存碎片和内存交换效率低的问题。</p></li><li><p>于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 <code>4KB</code>。由于分了页后，就不会产生细小的内存碎片。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。</p></li><li><p>再来，为了解决简单分页产生的页表过大的问题，就有了<strong>多级页表</strong>，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的<strong>局部性原理</strong>，在 CPU 芯片中加入了 <strong>TLB</strong>，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。</p></li><li><p><strong>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理</strong>。于是 Linux 就把所有段的基地址设为 <code>0</code>，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。</p></li><li><p>另外，Linxu 系统中虚拟空间分布可分为<strong>用户态</strong>和<strong>内核态</strong>两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。</p></li></ul><hr><p>以上内容参考公众号：<strong>小林coding</strong></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211018151438.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图解系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
            <tag> 内存分页 </tag>
            
            <tag> 内存分段 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转字符串与旋转数组</title>
      <link href="/posts/5f98.html"/>
      <url>/posts/5f98.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-旋转数组"><a href="#1-旋转数组" class="headerlink" title="1.旋转数组"></a>1.旋转数组</h1><p>题目链接：<a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a></p><ul><li>题目</li></ul><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>进阶：</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</p><p>示例 1:</p><ul><li>输入: nums = [1,2,3,4,5,6,7], k = 3</li><li>输出: [5,6,7,1,2,3,4]</li><li>解释: 向右旋转 1 步: [7,1,2,3,4,5,6]。<br>向右旋转 2 步: [6,7,1,2,3,4,5]。<br>向右旋转 3 步: [5,6,7,1,2,3,4]。</li></ul><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/rotate-array/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateArray</span> </span>{</span><br><span class="line">    <span class="comment">//旋转数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">//将nums[i]中的元素 移动后 放入temp数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            temp[(i + k) % len] = nums[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再将temp数组中的值 赋值给nums数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-反转字符串"><a href="#2-反转字符串" class="headerlink" title="2.反转字符串"></a>2.反转字符串</h1><p><a href="https://leetcode-cn.com/problems/reverse-string/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：输入：[“h”,”e”,”l”,”l”,”o”] 输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：输入：[“H”,”a”,”n”,”n”,”a”,”h”] 输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><ul><li>思路分析</li></ul><p>利用双指针，将左右两边的字母交换，然后左指针右移，右指针左移</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/reverse-string/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseString</span> </span>{</span><br><span class="line">    <span class="comment">//反转字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = s.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="keyword">char</span> temp = <span class="string">' '</span>;</span><br><span class="line">            temp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-反转字符串II"><a href="#3-反转字符串II" class="headerlink" title="3.反转字符串II"></a>3.反转字符串II</h1><p><a href="https://leetcode-cn.com/problems/reverse-string-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s = “abcdefg”, k = 2 输出: “bacdfeg”</p><ul><li>思路分析</li></ul><p>在遍历字符串的过程中，只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。</p><p>因为要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。</p><p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/reverse-string-ii/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseString2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span> * k) {</span><br><span class="line">            <span class="comment">//1.每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="keyword">if</span> (i + k - <span class="number">1</span> &lt;= len - <span class="number">1</span>) {</span><br><span class="line">                reverse(i, i + k - <span class="number">1</span>, chars);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//2.剩余字符串小于k个，则将剩余的全部反转</span></span><br><span class="line">            reverse(i, len - <span class="number">1</span>, chars);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">char</span>[] chars)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) {</span><br><span class="line">            <span class="keyword">char</span> temp = <span class="string">' '</span>;</span><br><span class="line">            temp = chars[start];</span><br><span class="line">            chars[start] = chars[end];</span><br><span class="line">            chars[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-替换空格"><a href="#4-替换空格" class="headerlink" title="4.替换空格"></a>4.替换空格</h1><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：输入：s = “We are happy.” 输出：”We%20are%20happy.”</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplaceSpace</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">replace</span><span class="params">(String s)</span></span>{</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()){</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">" "</span>.equals(String.valueOf(c))){  <span class="comment">//String.valueOf() 将char转为String</span></span><br><span class="line">                sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                sb.append(c);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-翻转字符串里的单词"><a href="#5-翻转字符串里的单词" class="headerlink" title="5.翻转字符串里的单词"></a>5.翻转字符串里的单词</h1><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义[left,right]为需要读取单词的区间</span></span><br><span class="line"><span class="comment"> * 指针left、right定义为在去掉字符串首尾空格后字符串的首尾位置</span></span><br><span class="line"><span class="comment"> * 1.去掉字符串首尾左右空格，移动left、right指针指向去掉空格后的首尾位置。</span></span><br><span class="line"><span class="comment"> * while（left&lt;=right）{</span></span><br><span class="line"><span class="comment"> * 2.从后往前一个个遍历单词，设置index指针，指向right位置，index从后往前遍历，直到遇到空格或者末尾</span></span><br><span class="line"><span class="comment"> * 说明此时已经将其中一个单词遍历完。</span></span><br><span class="line"><span class="comment"> * 3.此时index+1为该单词的首位，遍历字符串[index+1,right]区间，加入到StringBuffer中</span></span><br><span class="line"><span class="comment"> * 4.判断index位置，加入空格：若index位置已经到达头位置了，说明不需要添加空格，否则都需要添加空格隔开单词</span></span><br><span class="line"><span class="comment"> * 5.index继续从后往前遍历，跳过空格直到遇到非空字符，将right指向index的位置执行下一次循环</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> * 6.返回StringBuilder.toString();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/reverse-words-in-a-string/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseWords</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = ch.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//去除字符串两端的空格</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; len &amp;&amp; ch[left] == <span class="string">' '</span>) left++;</span><br><span class="line">        <span class="keyword">while</span> (right &gt;= <span class="number">0</span> &amp;&amp; ch[right] == <span class="string">' '</span>) right--;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">            <span class="keyword">int</span> index = right;   <span class="comment">//记录当前最右边的位置</span></span><br><span class="line">            <span class="comment">//从右向左遍历</span></span><br><span class="line">            <span class="keyword">while</span> (index &gt;= left &amp;&amp; ch[index] != <span class="string">' '</span>) index--;</span><br><span class="line">            <span class="comment">//将index~right范围内的单词加入到StringBuilder</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt;= right; i++) {</span><br><span class="line">                sb.append(ch[i]);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//在新加入的单词之间加一个空格</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= left) sb.append(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//去除原先字符串的单词之间多余的空格</span></span><br><span class="line">            <span class="keyword">while</span> (index &gt;= left &amp;&amp; ch[index] == <span class="string">' '</span>) index--;</span><br><span class="line"></span><br><span class="line">            right = index;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-剑指Offer58-II-左旋转字符串"><a href="#6-剑指Offer58-II-左旋转字符串" class="headerlink" title="6.剑指Offer58-II.左旋转字符串"></a>6.剑指Offer58-II.左旋转字符串</h1><p><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：<br>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p><p>示例 2：<br>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateStr</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        String str1 = s.substring(<span class="number">0</span>, n);</span><br><span class="line">        String str2 = s.substring(n, len);</span><br><span class="line">        <span class="keyword">return</span> str2 + str1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈刷题笔记</title>
      <link href="/posts/17ab.html"/>
      <url>/posts/17ab.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-每日温度"><a href="#1-每日温度" class="headerlink" title="1.每日温度"></a>1.每日温度</h1><p><a href="https://leetcode-cn.com/problems/daily-temperatures/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><ul><li>思路分析</li></ul><p>方法一：暴力解法，两层for循环，把至少需要等待的天数就搜出来了。时间复杂度是O(n^2)</p><p>方法二：单调栈</p><p>1.先把下标0压入栈中</p><p>2.利用for循环遍历temperatures数组，</p><p>​    1)如果当前遍历到的数组元素，大于**栈顶(stack.peek())**中保存的下标对应的元素</p><p>​        则说明出现了更高的气温，记录到result数组中，接着将栈顶元素弹出，将<strong>下标i</strong>压栈</p><p>​    2)如果当前遍历到的数组元素，小于等于**栈顶(stack.peek())**中保存的下标对应的元素</p><p>​        则直接将<strong>下标i</strong>压栈</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/daily-temperatures/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyTemperatures</span> </span>{</span><br><span class="line">    <span class="comment">//方法一：单调栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) {</span><br><span class="line">        <span class="keyword">int</span> len = temperatures.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);  <span class="comment">//栈中放入数组的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) {</span><br><span class="line">                    result[stack.peek()] = i - stack.peek();</span><br><span class="line">                    stack.pop();</span><br><span class="line">                }</span><br><span class="line">                stack.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：暴力求解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures2(<span class="keyword">int</span>[] temperatures) {</span><br><span class="line">        <span class="keyword">int</span> len = temperatures.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) {</span><br><span class="line">                <span class="keyword">if</span> (temperatures[j] &gt; temperatures[i]) {</span><br><span class="line">                    result[i] = j - i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-下一个更大元素-I"><a href="#2-下一个更大元素-I" class="headerlink" title="2.下一个更大元素 I"></a>2.下一个更大元素 I</h1><p><a href="https://leetcode-cn.com/problems/next-greater-element-i/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:</p><p>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p><p>示例 2:<br>输入: nums1 = [2,4], nums2 = [1,2,3,4].<br>输出: [3,-1]<br>解释:<br>对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。<br>对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出-1 。</p><ul><li>思路分析</li></ul><p>1.定义一个result数组，并赋初值为-1</p><p>2.在遍历nums2的过程中，我们要判断nums2[i]是否在nums1中出现过，因为最后是要根据nums1元素的下标来更新result数组。</p><p><strong>注意题目中说是两个没有重复元素 的数组 nums1 和 nums2</strong>。</p><p>没有重复元素，我们就可以用HashMap来做映射了。根据数值快速找到下标，还可以判断nums2[i]是否在nums1中出现过。</p><p>3.接着使用单调栈</p><p>栈头到栈底的顺序，要从小到大，也就是保持栈里的元素为递增顺序。只要保持递增，才能找到右边第一个比自己大的元素。</p><p>可能这里有一些同学不理解，那么可以自己尝试一下用递减栈，能不能求出来。其实递减栈就是求右边第一个比自己小的元素了。</p><p>接下来就要分析如下三种情况，一定要分析清楚。</p><ol><li>情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li></ol><p>此时满足递增栈（栈头到栈底的顺序），所以直接入栈。</p><ol start="2"><li>情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li></ol><p>如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！</p><ol start="3"><li>情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ol><p>此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。</p><p>判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。</p><p>记录结果这块逻辑有一点小绕，要清楚，此时栈顶元素在nums2中右面第一个大的元素是nums2[i]即当前遍历元素。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/next-greater-element-i/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextGreaterElement1</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) {</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        Arrays.fill(result, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将nums1的下标，元素放入map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) {</span><br><span class="line">            map.put(nums1[i], i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums2.length; i++) {</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) {</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(nums2[stack.peek()])) {  <span class="comment">//看一下nums1中是否包含这个元素</span></span><br><span class="line">                    <span class="keyword">int</span> index = map.get(nums2[stack.peek()]); <span class="comment">//获取该元素在nums1中的下标</span></span><br><span class="line">                    result[index] = nums2[i];</span><br><span class="line">                }</span><br><span class="line">                stack.pop();</span><br><span class="line">            }</span><br><span class="line">            stack.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-下一个更大元素II"><a href="#3-下一个更大元素II" class="headerlink" title="3.下一个更大元素II"></a>3.下一个更大元素II</h1><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p>示例 1:</p><p>输入: [1,2,1]</p><p>输出: [2,-1,2]</p><p>解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数；</p><p>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</p><ul><li>思路分析</li></ul><p>本题与<a href="#1.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6">每日温度</a>如出一辙，不同的是，本题涉及到循环数组</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/next-greater-element-ii/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextGreaterElement2</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) {</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(result, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len * <span class="number">2</span>; i++) {</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i % len] &gt; nums[stack.peek()]) {</span><br><span class="line">                result[stack.peek()] = nums[i % len];</span><br><span class="line">                stack.pop();</span><br><span class="line">            }</span><br><span class="line">            stack.push(i % len);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-接雨水"><a href="#4-接雨水" class="headerlink" title="4.接雨水"></a>4.接雨水</h1><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例 1：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211002163735.png" alt="img"></p><ul><li>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</li><li>输出：6</li><li>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</li></ul><p>示例 2：</p><ul><li>输入：height = [4,2,0,3,2,5]</li><li>输出：9</li></ul><ul><li>思路分析</li></ul><p><a href="https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html">接雨水的思路分析(代码随想录)</a></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/trapping-rain-water/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrappingRainWater</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一：双指针解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap1</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) { <span class="comment">//第一列和最后一列不接雨水</span></span><br><span class="line">            <span class="keyword">int</span> rHeight = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = i + <span class="number">1</span>; r &lt; len; r++) {  <span class="comment">//找右边的最高的那一列</span></span><br><span class="line">                <span class="keyword">if</span> (height[r] &gt; rHeight) rHeight = height[r];</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> lHeight = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = i - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--) {  <span class="comment">//找左边最高的那一列</span></span><br><span class="line">                <span class="keyword">if</span> (height[l] &gt; lHeight) lHeight = height[l];</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> iheight = Math.min(lHeight, rHeight) - height[i]; <span class="comment">//当前列的装水量</span></span><br><span class="line">            <span class="keyword">if</span> (iheight &gt; <span class="number">0</span>) sum += iheight;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：动态规划解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap2</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {    <span class="comment">//记录左边最高的墙</span></span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {  <span class="comment">//记录右边最高的墙</span></span><br><span class="line">            rightMax[i] = Math.max(rightMax[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) { <span class="comment">//第一列和最后一列不记录雨水量</span></span><br><span class="line">            <span class="keyword">int</span> iHeight = Math.min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">            <span class="keyword">if</span> (iHeight &gt; <span class="number">0</span>) sum += iHeight;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------</span></span><br><span class="line">    <span class="comment">//方法三：单调栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>{</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) {</span><br><span class="line">                <span class="keyword">int</span> mid = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) {</span><br><span class="line">                    <span class="keyword">int</span> h = Math.min(height[i], height[stack.peek()]) - height[mid];</span><br><span class="line">                    <span class="keyword">int</span> w = i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                    sum += h * w;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            stack.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//----------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        TrappingRainWater rainWater = <span class="keyword">new</span> TrappingRainWater();</span><br><span class="line">        <span class="keyword">int</span> trap = rainWater.trap(<span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>});</span><br><span class="line">        System.out.println(trap);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-柱状图中最大的矩形"><a href="#5-柱状图中最大的矩形" class="headerlink" title="5.柱状图中最大的矩形"></a>5.柱状图中最大的矩形</h1><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211002164054.png"></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20211002164105.png"></p><ul><li>思路分析</li></ul><p><a href="https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html">参考代码随想录</a></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargestRectangle</span> </span>{</span><br><span class="line">    <span class="comment">//方法一：单调栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[height.length + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="comment">//将新数组的首尾分别 补位 0</span></span><br><span class="line">        heights[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        heights[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) {</span><br><span class="line">            heights[i] = height[i - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()]) {</span><br><span class="line">                <span class="keyword">int</span> mid = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) {</span><br><span class="line">                    <span class="keyword">int</span> h = heights[mid];    <span class="comment">//注意此处的h = heights[mid],不太好理解!!!</span></span><br><span class="line">                    <span class="keyword">int</span> w = i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                    result = Math.max(h * w, result);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            stack.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------------</span></span><br><span class="line">    <span class="comment">//方法二：双指针解法(leetcode超时)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea1</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="keyword">int</span> left = i;</span><br><span class="line">            <span class="keyword">int</span> right = i;</span><br><span class="line">            <span class="comment">//向左边找，如果heights[left] &gt;= heights[i] ,则保留，直到遇到 i 左边第一个高度小于i的，结束循环</span></span><br><span class="line">            <span class="keyword">for</span> (; left &gt;= <span class="number">0</span>; left--) {</span><br><span class="line">                <span class="keyword">if</span> (heights[left] &lt; heights[i]) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向右边找，如果heights[left] &gt;= heights[i] ,则保留，直到遇到 i 右边第一个高度小于i的，结束循环</span></span><br><span class="line">            <span class="keyword">for</span> (; right &lt; len; right++) {</span><br><span class="line">                <span class="keyword">if</span> (heights[right] &lt; heights[i]) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> h = heights[i];</span><br><span class="line">            <span class="keyword">int</span> w = right - left - <span class="number">1</span>;</span><br><span class="line">            result = Math.max(result, h * w);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> rectangleArea = largestRectangleArea(<span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>});</span><br><span class="line">        System.out.println(rectangleArea);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>思路分析参考：<a href="https://programmercarl.com/">代码随想录</a>，感谢carl哥！！！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之子序列系列</title>
      <link href="/posts/c863.html"/>
      <url>/posts/c863.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-最长递增子序列"><a href="#1-最长递增子序列" class="headerlink" title="1.最长递增子序列"></a>1.最长递增子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p><p>示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4</p><p>示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1</p><ul><li>思路分析</li></ul><p>1.dp[i]的定义</p><p><strong>dp[i]表示i之前包括i的最长上升子序列</strong>。</p><p>2.状态转移方程</p><p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p><p>所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</p><p><strong>注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值</strong>。</p><p>3.dp[i]的初始化</p><p>每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是是1.</p><p>4.确定遍历顺序</p><p>dp[i] 是有0到i-1各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。</p><p>j其实就是0到i-1，遍历i的循环里外层，遍历j则在内层</p><p>5.举例推导dp数组</p><p>输入：[0,1,0,3,2]，dp数组的变化如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930151942.jpeg" alt="300.最长上升子序列"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/longest-increasing-subsequence/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestIncreasingSubsequence</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//dp[i] 表示i之前包括i的最长上升子序列</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>); <span class="comment">//dp[i] 的初始值为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) {</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            result = dp[i] &gt; result ? dp[i] : result;  <span class="comment">//不一定dp[n - 1]就是最长的子序列，</span></span><br><span class="line">                                                       <span class="comment">// 所以要在遍历的过程中，保存最大值。</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-最长连续递增序列"><a href="#2-最长连续递增序列" class="headerlink" title="2.最长连续递增序列"></a>2.最长连续递增序列</h1><p><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p><p>示例 1： 输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</p><p>示例 2： 输入：nums = [2,2,2,2,2] 输出：1 解释：最长连续递增序列是 [2], 长度为1。</p><ul><li>思路分析</li></ul><p>1.确定dp数组（dp table）以及下标的含义</p><p>**dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]**。</p><p>注意这里的定义，一定是以下标i为结尾，并不是说一定以下标0为起始位置。</p><p>2.确定递推公式</p><p>如果 nums[i + 1] &gt; nums[i]，那么以 i+1 为结尾的数组的连续递增的子序列长度 一定等于 以i为结尾的数组的连续递增的子序列长度 + 1 。</p><p>即：dp[i + 1] = dp[i] + 1;</p><p>3.dp数组如何初始化</p><p>以下标i为结尾的数组的连续递增的子序列长度最少也应该是1，即就是nums[i]这一个元素。</p><p>所以dp[i]应该初始1;</p><p>4.确定遍历顺序</p><p>从递推公式上可以看出， dp[i + 1]依赖dp[i]，所以一定是从前向后遍历。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestContinueSub</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];  <span class="comment">//dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]。</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            result = result &gt; dp[i] ? result : dp[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-最长重复子数组"><a href="#3-最长重复子数组" class="headerlink" title="3.最长重复子数组"></a>3.最长重复子数组</h1><p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><p>示例：</p><p>输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释： 长度最长的公共子数组是 [3, 2, 1] 。</p><ul><li>思路分析</li></ul><p>1.确定dp数组（dp table）以及下标的含义</p><p><code>dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。</code></p><p>2.确定递推公式</p><p><code>根据dp[i][j]的定义，dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来。</code></p><p>即当A[i - 1] 和B[j - 1]相等的时候，<code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p><p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p><p>3.dp数组如何初始化</p><p><code>根据dp[i][j]的定义，dp[i][0] 和dp[0][j]其实都是没有意义的！</code></p><p><code>但dp[i][0] 和dp[0][j]要初始值，因为 为了方便递归公式dp[i][j] = dp[i - 1][j - 1] + 1;</code></p><p><code>所以dp[i][0] 和dp[0][j]初始化为0。</code></p><p><code>举个例子A[0]如果和B[0]相同的话，dp[1][1] = dp[0][0] + 1，只有dp[0][0]初始为0</code>，正好符合递推公式逐步累加起来。</p><p>4.确定遍历顺序</p><p>外层for循环遍历A，内层for循环遍历B。</p><p>5.举例推导dp数组</p><p>拿示例1中，A: [1,2,3,2,1]，B: [3,2,1,4,7]为例，画一个dp数组的状态变化，如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930160647.jpeg" alt="718.最长重复子数组"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxRepeatedSubarray</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2.length;</span><br><span class="line">        <span class="comment">//dp[i][j] ：以下标i - 1为结尾的nums1，和以下标j - 1为结尾的nums2，最长重复子数组长度为dp[i][j]。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                result = result &gt; dp[i][j] ? result : dp[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-最长公共子序列"><a href="#4-最长公共子序列" class="headerlink" title="4.最长公共子序列"></a>4.最长公共子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><p>示例 1:</p><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace”，它的长度为 3。</p><p>示例 2:<br>输入：text1 = “abc”, text2 = “abc”<br>输出：3<br>解释：最长公共子序列是 “abc”，它的长度为 3。</p><p>示例 3:<br>输入：text1 = “abc”, text2 = “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0。</p><ul><li>思路分析</li></ul><p>1.确定dp数组（dp table）以及下标的含义</p><p><code>dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]</code></p><p>有同学会问：为什么要定义长度为[0, i - 1]的字符串text1，定义为长度为[0, i]的字符串text1不香么？</p><p>这样定义是为了后面代码实现方便，如果非要定义为为长度为[0, i]的字符串text1也可以，大家可以试一试！</p><p>2.确定递推公式</p><p>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p><p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以<code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p><p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</p><p>即：<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</code></p><p>3.dp数组如何初始化</p><p>先看看<code>dp[i][0]</code>应该是多少呢？</p><p><code>test1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i][0] = 0;</code></p><p><code>同理dp[0][j]也是0。</code></p><p>4.确定遍历顺序</p><p>从前向后，从上到下来遍历这个矩阵。</p><p>5.举例推导dp数组</p><p>以输入：text1 = “abcde”, text2 = “ace” 为例，dp状态如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930162727.jpeg" alt="1143.最长公共子序列1"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/longest-common-subsequence/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestCommonSubsequence</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>{</span><br><span class="line">        <span class="keyword">char</span>[] str1 = text1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = text2.toCharArray();</span><br><span class="line">        <span class="comment">//dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str1.length + <span class="number">1</span>][str2.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= str1.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= str2.length; j++) {</span><br><span class="line">                <span class="keyword">if</span> (str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[str1.length][str2.length];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-不相交的线"><a href="#5-不相交的线" class="headerlink" title="5.不相交的线"></a>5.不相交的线</h1><p><a href="https://leetcode-cn.com/problems/uncrossed-lines/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p><p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p><p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930163001.png" alt="1035.不相交的线"></p><ul><li>思路分析</li></ul><p>本题与<strong>4.最长公共子序列</strong>其实是一个题目，都是找最长的公共子序列</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/uncrossed-lines/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UncrossedLines</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2.length;</span><br><span class="line">        <span class="comment">//dp[i][j]：长度为[0, i - 1]的数组nums1 与 长度为[0, j - 1]的数组nums2的最长公共子序列为dp[i][j]</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-最大子序和"><a href="#6-最大子序和" class="headerlink" title="6.最大子序和"></a>6.最大子序和</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6</p><ul><li>思路分析</li></ul><p>动规五部曲如下：</p><p>1.确定dp数组（dp table）以及下标的含义</p><p>**dp[i]：包括下标i之前的最大连续子序列和为dp[i]**。</p><p>2.确定递推公式</p><p>dp[i]只有两个方向可以推出来：</p><p>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</p><p>nums[i]，即：从头开始计算当前连续子序列和</p><p>一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i]);</p><p>3.dp数组如何初始化</p><p>从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。</p><p>dp[0]应该是多少呢?</p><p>更具dp[i]的定义，很明显dp[0]因为为nums[0]即dp[0] = nums[0]。</p><p>4.确定遍历顺序</p><p>递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。</p><p>5.举例推导dp数组</p><p>以示例一为例，输入：nums = [-2,1,-3,4,-1,2,1,-5,4]，对应的dp状态如下： <img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930170553.png" alt="53.最大子序和（动态规划）"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/maximum-subarray/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarray</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//dp[i] 表示i之前的最大子序列和</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; result) result = dp[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="7-判断子序列"><a href="#7-判断子序列" class="headerlink" title="7. 判断子序列"></a>7. 判断子序列</h1><p><a href="https://leetcode-cn.com/problems/is-subsequence/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p>示例 1： 输入：s = “abc”, t = “ahbgdc” 输出：true</p><p>示例 2： 输入：s = “axc”, t = “ahbgdc” 输出：false</p><ul><li>思路分析</li></ul><p>动态规划五部曲分析如下：</p><p>1.确定dp数组（dp table）以及下标的含义</p><p><code>**dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]**。</code></p><p>2.确定递推公式</p><p>在确定递推公式的时候，首先要考虑如下两种操作，整理如下：</p><ul><li>if (s[i - 1] == t[j - 1])<ul><li>t中找到了一个字符在s中也出现了</li></ul></li><li>if (s[i - 1] != t[j - 1])<ul><li>相当于t要删除元素，继续匹配</li></ul></li></ul><p><code>if (s[i - 1] == t[j - 1])，那么dp[i][j] = dp[i - 1][j - 1] + 1;，因为找到了一个相同的字符，相同子序列长度自然要在dp[i-1][j-1]的基础上加1（**如果不理解，在回看一下dp[i][j]的定义**）</code></p><p><code>if (s[i - 1] != t[j - 1])，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i][j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i][j] = dp[i][j - 1];</code></p><p>3.dp数组如何初始化</p><p><code>从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，所以dp[0][0]和dp[i][0]是一定要初始化的。</code></p><p>4.确定遍历顺序</p><p><code>同理从从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，那么遍历顺序也应该是从上到下，从左到右</code></p><p>5.举例推导dp数组</p><p>以示例一为例，输入：s = “abc”, t = “ahbgdc”，dp状态转移图如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930194920.jpeg" alt="392.判断子序列2"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/is-subsequence/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsSubsequence</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = s.length();</span><br><span class="line">        <span class="keyword">int</span> n2 = t.length();</span><br><span class="line">        <span class="comment">//dp[i][j] 表示 如果长度为i的s 是 长度为j的t的子串 , 则dp[i][j] == s.length</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = t.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2 ; j++) {</span><br><span class="line">                <span class="keyword">if</span> (str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {  <span class="comment">//此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i][j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i][j] = dp[i][j - 1];</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2] == s.length();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="8-不同的子序列"><a href="#8-不同的子序列" class="headerlink" title="8.不同的子序列"></a>8.不同的子序列</h1><p><a href="https://leetcode-cn.com/problems/distinct-subsequences/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930195152.jpeg" alt="115.不同的子序列示例"></p><ul><li>思路分析</li></ul><p>五部曲分析如下：</p><p>1.确定dp数组（dp table）以及下标的含义</p><p><code>dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。</code></p><p>2.确定递推公式</p><p>这一类问题，基本是要分析两种情况</p><ul><li>s[i - 1] 与 t[j - 1]相等</li><li>s[i - 1] 与 t[j - 1] 不相等</li></ul><p>当s[i - 1] 与 t[j - 1]相等时，<code>dp[i][j]可以有两部分组成。</code></p><p><code>一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。</code></p><p><code>一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。</code></p><p>这里可能有同学不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。</p><p>例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。</p><p>当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。</p><p>3.dp数组如何初始化</p><p><code>从递推公式dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] = dp[i - 1][j]; 中可以看出dp[i][0] 和dp[0][j]是一定要初始化的。</code></p><p>每次当初始化的时候，先回顾一下<code>dp[i][j]</code>的定义，不要凭感觉初始化。</p><p><code>dp[i][0] </code>表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。</p><p>那么<code>dp[i][0]</code>一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。</p><p>再来看，<code>dp[0][j]</code>：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。</p><p><code>那么dp[0][j]一定都是0</code>，s如论如何也变成不了t。</p><p>最后就要看一个特殊位置了，即：<code>dp[0][0] </code>应该是多少。</p><p><code>dp[0][0]</code>应该是1，空字符串s，可以删除0个元素，变成空字符串t。</p><p>4.确定遍历顺序</p><p>从递推公式<code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] = dp[i - 1][j]; </code>中可以看出<code>dp[i][j]</code>都是根据左上方和正上方推出来的。</p><p>所以遍历的时候一定是从上到下，从左到右，这样保证<code>dp[i][j]</code>可以根据之前计算出来的数值进行计算。</p><p>5.举例推导dp数组</p><p>以s：”baegg”，t：”bag”为例，推导dp数组状态如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930200555.jpeg" alt="115.不同的子序列"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/distinct-subsequences/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifferentSubsequence</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>{</span><br><span class="line">        <span class="comment">//dp[i][j] 表示下标为i-1的s 包含 下标为j-1的t 的个数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length(); i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.length(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="9-两个字符串的删除操作"><a href="#9-两个字符串的删除操作" class="headerlink" title="9.两个字符串的删除操作"></a>9.两个字符串的删除操作</h1><p><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p><p>示例：</p><p>输入: “sea”, “eat”<br>输出: 2 解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</p><ul><li>思路分析</li></ul><p>动规五部曲，分析如下：</p><p>1.确定dp数组（dp table）以及下标的含义</p><p><code>dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</code></p><p>2.确定递推公式</p><ul><li><p>当word1[i - 1] 与 word2[j - 1]相同的时候，<code>dp[i][j] = dp[i - 1][j - 1];</code></p></li><li><p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有二种情况：</p><p>情况一：删word1[i - 1]，最少操作次数为<code>dp[i - 1][j] + 1</code></p><p>情况二：删word2[j - 1]，最少操作次数为<code>dp[i][j - 1] + 1</code></p></li></ul><p>3.dp数组如何初始化</p><p>从递推公式中，可以看出来，<code>dp[i][0] 和 dp[0][j]</code>是一定要初始化的。</p><p><code>dp[i][0]：word2为空字符串，以i-1为结尾的字符串word2要删除多少个元素，才能和word1相同呢，很明显dp[i][0] = i。</code></p><p><code>dp[0][j]的话同理</code></p><p>4.确定遍历顺序</p><p><code>从递推公式 dp[i][j] = min(dp[i - 1][j - 1] + 2, min(dp[i - 1][j], dp[i][j - 1]) + 1); 和dp[i][j] = dp[i - 1][j - 1]可以看出dp[i][j]都是根据左上方、正上方、正左方推出来的。</code></p><p>所以遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。</p><p>5.举例推导dp数组</p><p>以word1:”sea”，word2:”eat”为例，推导dp数组状态图如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930203936.png" alt="583.两个字符串的删除操作1"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/delete-operation-for-two-strings/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteTwoStrings</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>{</span><br><span class="line">        <span class="comment">//dp[i][j] 表示 使得以下标i-1结尾的word1 和 以j-1为结尾的word2 相同，所需要删除字符的最小个数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp数组初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.length(); i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.length(); j++) {</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.length(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.length(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="10-编辑距离"><a href="#10-编辑距离" class="headerlink" title="10.编辑距离"></a>10.编辑距离</h1><p><a href="https://leetcode-cn.com/problems/edit-distance/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>示例 1： 输入：word1 = “horse”, word2 = “ros” 输出：3 解释： horse -&gt; rorse (将 ‘h’ 替换为 ‘r’) rorse -&gt; rose (删除 ‘r’) rose -&gt; ros (删除 ‘e’)</p><p>示例 2： 输入：word1 = “intention”, word2 = “execution” 输出：5 解释： intention -&gt; inention (删除 ‘t’) inention -&gt; enention (将 ‘i’ 替换为 ‘e’) enention -&gt; exention (将 ‘n’ 替换为 ‘x’) exention -&gt; exection (将 ‘n’ 替换为 ‘c’) exection -&gt; execution (插入 ‘u’)</p><ul><li>思路分析</li></ul><p>1.确定dp数组（dp table）以及下标的含义</p><p><code>**dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]**。</code></p><p>2.确定递推公式</p><p>1).当匹配上时</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1];</span><br></pre></td></tr></tbody></table></figure><p> 2).当匹配不上时</p><p><code>if (word1[i - 1] != word2[j - 1])</code>，此时就需要编辑了，如何编辑呢？</p><ul><li>操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。</li></ul><p>即 <code>dp[i][j] = dp[i - 1][j] + 1;</code></p><ul><li>操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。</li></ul><p>即 <code>dp[i][j] = dp[i][j - 1] + 1;</code></p><p>这里有同学发现了，怎么都是删除元素，添加元素去哪了。</p><p><strong>word2添加一个元素，相当于word1删除一个元素</strong>，例如 <code>word1 = "ad" ，word2 = "a"</code>，<code>word1</code>删除元素<code>'d'</code> 和 <code>word2</code>添加一个元素<code>'d'</code>，变成<code>word1="a", word2="ad"</code>， 最终的操作数是一样！</p><ul><li>操作三：替换元素，<code>word1</code>替换<code>word1[i - 1]</code>，使其与<code>word2[j - 1]</code>相同，此时不用增加元素，那么以下标<code>i-2</code>为结尾的<code>word1</code> 与 <code>j-2</code>为结尾的<code>word2</code>的最近编辑距离 加上一个替换元素的操作。</li></ul><p>即 <code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p><p>综上，当 <code>if (word1[i - 1] != word2[j - 1])</code> 时取最小的，即：<code>dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;</code></p><p>3.dp数组初始化</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">再回顾一下dp[i][j]的定义：</span><br><span class="line"></span><br><span class="line">**dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]**。</span><br><span class="line"></span><br><span class="line">那么dp[i][0] 和 dp[0][j] 表示什么呢？</span><br><span class="line"></span><br><span class="line">dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。</span><br><span class="line"></span><br><span class="line">那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i;</span><br><span class="line"></span><br><span class="line">同理dp[0][j] = j;</span><br></pre></td></tr></tbody></table></figure><p>4.遍历顺序</p><p>在dp矩阵从左到右从上到下去遍历。</p><p>5.距离推导dp数组</p><p>以示例1为例，输入：<code>word1 = "horse", word2 = "ros"</code>为例，dp矩阵状态图如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930210035.jpeg" alt="72.编辑距离1"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/edit-distance/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditDistance</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>{</span><br><span class="line">        <span class="comment">//dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp数组初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.length(); i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.length(); j++) {</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.length(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.length(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="11-回文子串"><a href="#11-回文子串" class="headerlink" title="11.回文子串"></a>11.回文子串</h1><p><a href="https://leetcode-cn.com/problems/palindromic-substrings/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><p>输入：”abc” 输出：3 解释：三个回文子串: “a”, “b”, “c”</p><p>示例 2：</p><p>输入：”aaa” 输出：6 解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p><ul><li>思路分析</li></ul><p>两层for循环，遍历区间起始位置和终止位置，然后判断这个区间是不是回文。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/palindromic-substrings/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromicSubstrings</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings2</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> sum = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++) {</span><br><span class="line">                <span class="comment">//如果s的(i,j)这部分是回文子串，则sum+1</span></span><br><span class="line">                <span class="keyword">if</span> (isPalindromic(i,j,s)) sum += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindromic</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String s)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) {</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(start) != s.charAt(end)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="12-最长回文子序列"><a href="#12-最长回文子序列" class="headerlink" title="12.最长回文子序列"></a>12.最长回文子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。</p><p>示例 1: 输入: “bbbab” 输出: 4 一个可能的最长回文子序列为 “bbbb”。</p><p>示例 2: 输入:”cbbd” 输出: 2 一个可能的最长回文子序列为 “bb”。</p><ul><li>思路分析</li></ul><p>动规五部曲分析如下：</p><p>1.确定dp数组（dp table）以及下标的含义</p><p>**<code>dp[i][j]：</code>字符串s在[i, j]范围内最长的回文子序列的长度为<code>dp[i][j]</code>**。</p><p>2.确定递推公式</p><p>在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。</p><p>如果s[i]与s[j]相同，那么<code>dp[i][j] = dp[i + 1][j - 1] + 2;</code></p><p>如图： <img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930213949.jpeg" alt="516.最长回文子序列"></p><p>如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子串的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</p><p>加入<code>s[j]的回文子序列长度为dp[i + 1][j]。</code></p><p>加入<code>s[i]的回文子序列长度为dp[i][j - 1]。</code></p><p>那么<code>dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</code></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930214039.jpeg" alt="516.最长回文子序列1"></p><p>3.dp数组如何初始化</p><p>首先要考虑当i 和j 相同的情况，从递推公式：<code>dp[i][j] = dp[i + 1][j - 1] + 2; </code>可以看出 递推公式是计算不到 i 和j相同时候的情况。</p><p>所以需要手动初始化一下，当i与j相同，那么<code>dp[i][j]</code>一定是等于1的，即：一个字符的回文子序列长度就是1。</p><p>其他情况<code>dp[i][j]初始为0就行，这样递推公式：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); 中dp[i][j]</code>才不会被初始值覆盖。</p><p>4.确定遍历顺序</p><p>从递推公式<code>dp[i][j] = dp[i + 1][j - 1] + 2 和 dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) 可以看出，dp[i][j]是依赖于dp[i + 1][j - 1] 和 dp[i + 1][j]，</code></p><p>也就是从矩阵的角度来说，<code>dp[i][j] </code>下一行的数据。 <strong>所以遍历i的时候一定要从下到上遍历，这样才能保证，下一行的数据是经过计算的</strong>。</p><p>递推公式：<code>dp[i][j] = dp[i + 1][j - 1] + 2，dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) </code>分别对应着下图中的红色箭头方向，如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930214144.jpeg" alt="516.最长回文子序列2"></p><p>5.举例推导dp数组</p><p>输入s:”cbbd” 为例，dp数组状态如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210930214201.jpeg" alt="516.最长回文子序列3"></p><p><code>红色框即：dp[0][s.size() - 1]; 为最终结果。</code></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/longest-palindromic-subsequence/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestPalindromicSubsequence</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="comment">//dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()][s.length()];</span><br><span class="line">        <span class="comment">//dp数组初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意遍历顺序和递推公式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) {</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.length() - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>以上思路分析，参考:<a href="https://programmercarl.com/">代码随想录</a>，</strong>题目来自：LeetCode</p><p><strong>感谢carl哥!!!</strong></p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之买卖股票专题</title>
      <link href="/posts/87d3.html"/>
      <url>/posts/87d3.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-买卖股票的最佳时机"><a href="#1-买卖股票的最佳时机" class="headerlink" title="1.买卖股票的最佳时机"></a>1.买卖股票的最佳时机</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p><ul><li>思路分析</li></ul><p>1.确定dp数组（dp table）以及下标的含义</p><p>dp[i][0] 表示第i天持有股票所得最多现金 ，<strong>这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？</strong></p><p>其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。</p><p>dp[i][1] 表示第i天不持有股票所得最多现金</p><p><strong>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</strong></p><p>很多同学把“持有”和“买入”没分区分清楚。</p><p>2.确定递推公式</p><p>如果第i天持有股票即<code>dp[i][0]，</code> 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：<code>dp[i - 1</code>][0]</li><li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</li></ul><p>那么<code>dp[i][0]</code>应该选所得现金最大的，所以<code>dp[i][0] = max(dp[i - 1][0], -prices[i]);</code></p><p>如果第i天不持有股票即<code>dp[i</code>][1]， 也可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：<code>dp[i - 1][1]</code></li><li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：<code>prices[i] + dp[i - 1][0]</code></li></ul><p>同样<code>dp[i][1]</code>取最大的，<code>dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</code></p><p>3.dp数组的初始化</p><p>那么<code>dp[0][0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0][0] -= prices[0];</code></p><p><code>dp[0][1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0][1] = 0;</code></p><p>4.遍历顺序</p><p>从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。</p><p>5.举例推导dp数组</p><p>以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210927145900.png" alt="121.买卖股票的最佳时机"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStock</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//贪心算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> low = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) {</span><br><span class="line">            low = Math.min(low, prices[i]);</span><br><span class="line">            result = Math.max(result, prices[i] - low);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][0] 表示第i天持有股票，所剩余的最大金额</span></span><br><span class="line">        <span class="comment">// dp[i][1] 表示第i天不持有股票，所剩余的最大金额</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-买卖股票的最佳时机II"><a href="#2-买卖股票的最佳时机II" class="headerlink" title="2.买卖股票的最佳时机II"></a>2.买卖股票的最佳时机II</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><ul><li>思路分析</li></ul><p>此题与<strong>1.买卖股票的最佳时机</strong>最大的区别就是可以多次买卖股票</p><p>需要修改的关键代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStock</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//贪心算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> low = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) {</span><br><span class="line">            low = Math.min(low, prices[i]);</span><br><span class="line">            result = Math.max(result, prices[i] - low);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][0] 表示第i天持有股票，所剩余的最大金额</span></span><br><span class="line">        <span class="comment">// dp[i][1] 表示第i天不持有股票，所剩余的最大金额</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-买卖股票的最佳时机含手续费"><a href="#3-买卖股票的最佳时机含手续费" class="headerlink" title="3.买卖股票的最佳时机含手续费"></a>3.买卖股票的最佳时机含手续费</h1><ul><li>题目</li></ul><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p>示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8</p><p>解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p><ul><li>思路分析</li></ul><p>此题与<strong>2.买卖股票的最佳时机II</strong>最大的区别就是:在卖股票时，需要收取手续费</p><p>所以只需要在卖股票时减去手续费即可</p><p>要修改的关键代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">      dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">      dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStockWithFee</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-买卖股票的最佳时机III"><a href="#4-买卖股票的最佳时机III" class="headerlink" title="4.买卖股票的最佳时机III"></a>4.买卖股票的最佳时机III</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。</p><p>示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p>示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为0。</p><p>示例 4： 输入：prices = [1] 输出：0</p><ul><li>思路分析</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。</span><br><span class="line"></span><br><span class="line">接来下我用动态规划五部曲详细分析一下：</span><br><span class="line"></span><br><span class="line">1.确定dp数组以及下标的含义</span><br><span class="line">一天一共就有五个状态， 0. 没有操作</span><br><span class="line">1第一次买入</span><br><span class="line">2第一次卖出</span><br><span class="line">3第二次买入</span><br><span class="line">4第二次卖出</span><br><span class="line">dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.确定递推公式</span><br><span class="line">需要注意：dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区。</span><br><span class="line"></span><br><span class="line">达到dp[i][1]状态，有两个具体操作：</span><br><span class="line"></span><br><span class="line">操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]</span><br><span class="line">操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]</span><br><span class="line">那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？</span><br><span class="line"></span><br><span class="line">一定是选最大的，所以 dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);</span><br><span class="line"></span><br><span class="line">同理dp[i][2]也有两个操作：</span><br><span class="line"></span><br><span class="line">操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]</span><br><span class="line">操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]</span><br><span class="line">所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</span><br><span class="line"></span><br><span class="line">同理可推出剩下状态部分：</span><br><span class="line"></span><br><span class="line">dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.dp数组如何初始化</span><br><span class="line">第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;</span><br><span class="line"></span><br><span class="line">第0天做第一次买入的操作，dp[0][1] = -prices[0];</span><br><span class="line"></span><br><span class="line">第0天做第一次卖出的操作，这个初始值应该是多少呢？</span><br><span class="line"></span><br><span class="line">首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，</span><br><span class="line"></span><br><span class="line">从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。</span><br><span class="line"></span><br><span class="line">所以dp[0][2] = 0;</span><br><span class="line"></span><br><span class="line">第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</span><br><span class="line"></span><br><span class="line">第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。</span><br><span class="line"></span><br><span class="line">所以第二次买入操作，初始化为：dp[0][3] = -prices[0];</span><br><span class="line"></span><br><span class="line">同理第二次卖出初始化dp[0][4] = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.确定遍历顺序</span><br><span class="line">从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</span><br></pre></td></tr></tbody></table></figure><p>5.举例推导dp数组</p><p>以输入[1,2,3,4,5]为例</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210927155708.png" alt="123.买卖股票的最佳时机III"></p><p>大家可以看到红色框为最后两次卖出的状态。</p><p>现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。</p><p>所以最终最大利润是<code>dp[4][4]</code></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStock3</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="comment">//dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">4</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-买卖股票的最佳时机IV"><a href="#5-买卖股票的最佳时机IV" class="headerlink" title="5.买卖股票的最佳时机IV"></a>5.买卖股票的最佳时机IV</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2。</p><p>示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</p><ul><li>思路分析</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">动规五部曲，分析如下：</span><br><span class="line"></span><br><span class="line">******1.确定dp数组以及下标的含义******</span><br><span class="line">在动态规划：4.买卖股票的最佳时机III中，我是定义了一个二维dp数组，本题其实依然可以用一个二维dp数组。</span><br><span class="line"></span><br><span class="line">使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]</span><br><span class="line"></span><br><span class="line">j的状态表示为：</span><br><span class="line"></span><br><span class="line">0 表示不操作</span><br><span class="line">1 第一次买入</span><br><span class="line">2 第一次卖出</span><br><span class="line">3 第二次买入</span><br><span class="line">4 第二次卖出</span><br><span class="line">.....</span><br><span class="line">大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入。</span><br><span class="line"></span><br><span class="line">题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">******2.确定递推公式******</span><br><span class="line"></span><br><span class="line">还要强调一下：dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区。</span><br><span class="line"></span><br><span class="line">达到dp[i][1]状态，有两个具体操作：</span><br><span class="line"></span><br><span class="line">操作一：第i天买入股票了，那么dp[i][1] = dp[i - 1][0] - prices[i]</span><br><span class="line">操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]</span><br><span class="line">选最大的，所以 dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][0]);</span><br><span class="line"></span><br><span class="line">同理dp[i][2]也有两个操作：</span><br><span class="line"></span><br><span class="line">操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]</span><br><span class="line">操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]</span><br><span class="line">所以dp[i][2] = max(dp[i - 1][i] + prices[i], dp[i][2])</span><br><span class="line"></span><br><span class="line">同理可以类比剩下的状态，代码如下：</span><br><span class="line"></span><br><span class="line">for (int j = 0; j &lt; 2 * k - 1; j += 2) {</span><br><span class="line">    dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);</span><br><span class="line">    dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);</span><br><span class="line">}</span><br><span class="line">本题和动态规划：123.买卖股票的最佳时机III最大的区别就是这里要类比j为奇数是买，偶数是卖剩的状态。</span><br><span class="line"></span><br><span class="line">******3.dp数组如何初始化******</span><br><span class="line">第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;</span><br><span class="line"></span><br><span class="line">第0天做第一次买入的操作，dp[0][1] = -prices[0];</span><br><span class="line"></span><br><span class="line">第0天做第一次卖出的操作，这个初始值应该是多少呢？</span><br><span class="line"></span><br><span class="line">首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，</span><br><span class="line"></span><br><span class="line">从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。</span><br><span class="line"></span><br><span class="line">所以dp[0][2] = 0;</span><br><span class="line"></span><br><span class="line">第0天第二次买入操作，初始值应该是多少呢？</span><br><span class="line"></span><br><span class="line">不用管第几次，现在手头上没有现金，只要买入，现金就做相应的减少。</span><br><span class="line"></span><br><span class="line">第二次买入操作，初始化为：dp[0][3] = -prices[0];</span><br><span class="line"></span><br><span class="line">所以同理可以推出dp[0][j]当j为奇数的时候都初始化为 -prices[0]</span><br><span class="line"></span><br><span class="line">代码如下：</span><br><span class="line"></span><br><span class="line">for (int j = 1; j &lt; 2 * k; j += 2) {</span><br><span class="line">    dp[0][j] = -prices[0];</span><br><span class="line">}</span><br><span class="line">在初始化的地方同样要类比j为偶数是卖、奇数是买的状态。</span><br><span class="line"></span><br><span class="line">******4.确定遍历顺序******</span><br><span class="line">从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</span><br></pre></td></tr></tbody></table></figure><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStock4</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j += <span class="number">2</span>) {</span><br><span class="line">            dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j+= <span class="number">20</span>) {</span><br><span class="line">                dp[i][j + <span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][j] - prices[i], dp[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">                dp[i][j + <span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i], dp[i - <span class="number">1</span>][j + <span class="number">2</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-最佳买卖股票时机含冷冻期"><a href="#6-最佳买卖股票时机含冷冻期" class="headerlink" title="6.最佳买卖股票时机含冷冻期"></a>6.最佳买卖股票时机含冷冻期</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p><strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</strong></p><p><strong>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</strong></p><p>示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p><ul><li>思路分析</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">动规五部曲，分析如下：</span><br><span class="line"></span><br><span class="line">******1.确定dp数组以及下标的含义******</span><br><span class="line">dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。</span><br><span class="line"></span><br><span class="line">其实本题很多同学搞的比较懵，是因为出现冷冻期之后，状态其实是比较复杂度，例如今天买入股票、今天卖出股票、今天是冷冻期，都是不能操作股票的。 具体可以区分出如下四个状态：</span><br><span class="line"></span><br><span class="line">状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</span><br><span class="line">卖出股票状态，这里就有两种卖出股票状态</span><br><span class="line">状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</span><br><span class="line">状态三：今天卖出了股票</span><br><span class="line">状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</span><br><span class="line"></span><br><span class="line">j的状态为：</span><br><span class="line">0：状态一</span><br><span class="line">1：状态二</span><br><span class="line">2：状态三</span><br><span class="line">3：状态四</span><br><span class="line">很多题解为什么讲的比较模糊，是因为把这四个状态合并成三个状态了，其实就是把状态二和状态四合并在一起了。</span><br><span class="line"></span><br><span class="line">从代码上来看确实可以合并，但从逻辑上分析合并之后就很难理解了，所以我下面的讲解是按照这四个状态来的，把每一个状态分析清楚。</span><br><span class="line"></span><br><span class="line">注意这里的每一个状态，例如状态一，是买入股票状态并不是说今天已经就买入股票，而是说保存买入股票的状态即：可能是前几天买入的，之后一直没操作，所以保持买入股票的状态。</span><br><span class="line"></span><br><span class="line">******2.确定递推公式******</span><br><span class="line">达到买入股票状态（状态一）即：dp[i][0]，有两个具体操作：</span><br><span class="line"></span><br><span class="line">操作一：前一天就是持有股票状态（状态一），dp[i][0] = dp[i - 1][0]</span><br><span class="line">操作二：今天买入了，有两种情况</span><br><span class="line">前一天是冷冻期（状态四），dp[i - 1][3] - prices[i]</span><br><span class="line">前一天是保持卖出股票状态（状态二），dp[i - 1][1] - prices[i]</span><br><span class="line">所以操作二取最大值，即：max(dp[i - 1][3], dp[i - 1][1]) - prices[i]</span><br><span class="line"></span><br><span class="line">那么dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);</span><br><span class="line"></span><br><span class="line">达到保持卖出股票状态（状态二）即：dp[i][1]，有两个具体操作：</span><br><span class="line"></span><br><span class="line">操作一：前一天就是状态二</span><br><span class="line">操作二：前一天是冷冻期（状态四）</span><br><span class="line">dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);</span><br><span class="line"></span><br><span class="line">达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作：</span><br><span class="line"></span><br><span class="line">操作一：昨天一定是买入股票状态（状态一），今天卖出</span><br><span class="line">即：dp[i][2] = dp[i - 1][0] + prices[i];</span><br><span class="line"></span><br><span class="line">达到冷冻期状态（状态四），即：dp[i][3]，只有一个操作：</span><br><span class="line"></span><br><span class="line">操作一：昨天卖出了股票（状态三）</span><br><span class="line">p[i][3] = dp[i - 1][2];</span><br><span class="line"></span><br><span class="line">综上分析，递推代码如下：</span><br><span class="line">dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i];</span><br><span class="line">dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);</span><br><span class="line">dp[i][2] = dp[i - 1][0] + prices[i];</span><br><span class="line">dp[i][3] = dp[i - 1][2];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">******3.dp数组如何初始化******</span><br><span class="line">这里主要讨论一下第0天如何初始化。</span><br><span class="line"></span><br><span class="line">如果是持有股票状态（状态一）那么：dp[0][0] = -prices[0]，买入股票所省现金为负数。</span><br><span class="line"></span><br><span class="line">保持卖出股票状态（状态二），第0天没有卖出dp[0][1]初始化为0就行，</span><br><span class="line"></span><br><span class="line">今天卖出了股票（状态三），同样dp[0][2]初始化为0，因为最少收益就是0，绝不会是负数。</span><br><span class="line"></span><br><span class="line">同理dp[0][3]也初始为0。</span><br><span class="line"></span><br><span class="line">******4.确定遍历顺序******</span><br><span class="line">从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。</span><br></pre></td></tr></tbody></table></figure><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStockWithCooldown</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">4</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]));</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">3</span>], Math.max(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 买卖股票 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划刷题笔记②</title>
      <link href="/posts/91bd.html"/>
      <url>/posts/91bd.html</url>
      
        <content type="html"><![CDATA[<h1 id="完全背包理论"><a href="#完全背包理论" class="headerlink" title="完全背包理论"></a>完全背包理论</h1><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><p>同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理。</p><p>在下面的讲解中，我依然举这个例子：</p><p>背包最大重量为4。</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p><strong>每件商品都有无限个！</strong></p><p>问背包能背的物品最大价值是多少？</p><p>01背包和完全背包唯一不同就是体现在遍历顺序上</p><ul><li>思路分析：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html">完全背包理论基础</a></li></ul><ul><li><p>代码详情</p><p><strong>对于纯完全背包问题，两层for循环的先后循环是可以颠倒的！</strong>并且内层for循环采用正序遍历(从小到大)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。</span></span><br><span class="line"><span class="comment"> * 每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</span></span><br><span class="line"><span class="comment"> * (完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletePack</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testCompletePack</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> bagWeight)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = weight.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[bagWeight + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = weight[i]; j &lt;= bagWeight; j++) {</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">        <span class="keyword">return</span> dp[bagWeight];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] weight = {<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">        <span class="keyword">int</span>[] value = {<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>};</span><br><span class="line">        testCompletePack(weight,value,<span class="number">4</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br></li></ul><h1 id="1-零钱兑换"><a href="#1-零钱兑换" class="headerlink" title="1.零钱兑换"></a>1.零钱兑换</h1><p><a href="https://leetcode-cn.com/problems/coin-change-2/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><p>示例 1:</p><p>输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</p><p>示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。</p><p>示例 3: 输入: amount = 10, coins = [10] 输出: 1</p><p>注意，你可以假设：</p><p>0 &lt;= amount (总金额) &lt;= 5000</p><p>1 &lt;= coin (硬币面额) &lt;= 5000</p><p>硬币种类不超过 500 种</p><p>结果符合 32 位符号整数</p><ul><li>思路分析</li></ul><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[j]：凑成总金额j的货币组合数为dp[j]</p><ol start="2"><li>确定递推公式</li></ol><p>dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。</p><p>所以递推公式：dp[j] += dp[j - coins[i]];</p><ol start="3"><li>dp数组如何初始化</li></ol><p>首先dp[0]一定要为1，dp[0] = 1是 递归公式的基础。</p><p>从dp[i]的含义上来讲就是，凑成总金额0的货币组合数为1。</p><p>下标非0的dp[j]初始化为0，这样累计加dp[j - coins[i]]的时候才不会影响真正的dp[j]</p><ol start="4"><li>确定遍历顺序</li></ol><p>因为本题是求组合数，所以先遍历物品，再遍历背包容量</p><ol start="5"><li>举例推导dp数组</li></ol><p>输入: amount = 5, coins = [1, 2, 5] ，dp状态图如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210925153233.jpeg"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/coin-change-2/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinChange</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = coins.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];  <span class="comment">//dp[i] 表示 装满容量为i的背包有多少种方法</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {  <span class="comment">//遍历物品(也就是硬币)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) {  <span class="comment">//遍历背包</span></span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        CoinChange change = <span class="keyword">new</span> CoinChange();</span><br><span class="line">        <span class="keyword">int</span> change1 = change.change(<span class="number">5</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>});</span><br><span class="line"></span><br><span class="line">        System.out.println(change1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-组合总和-Ⅳ"><a href="#2-组合总和-Ⅳ" class="headerlink" title="2. 组合总和 Ⅳ"></a>2. 组合总和 Ⅳ</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p><p>示例:</p><p>nums = [1, 2, 3] target = 4</p><p>所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)</p><p>请注意，顺序不同的序列被视作不同的组合。</p><p>因此输出为 7</p><ul><li>思路分析</li></ul><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i] 凑成目标正整数为i的排列数为dp[i]</p><ol start="2"><li>dp数组的初始化</li></ol><p>dp[0] = 1;</p><ol start="3"><li>确定遍历顺序</li></ol><p>因为是求排列数，所以先遍历背包容量，再遍历物品</p><ol start="4"><li>递推表达式</li></ol><p>dp[j] += dp[j - nums[j]];</p><ol start="5"><li>举例推导dp数组</li></ol><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210925154850.jpeg"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/combination-sum-iv/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum4</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];  <span class="comment">//dp[i] 表示 容量为i的背包 一共有多少种排列</span></span><br><span class="line">                                         <span class="comment">//即-dp[i]: 凑成目标正整数为i的排列个数为dp[i]</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) { <span class="comment">//先遍历背包，再遍历物品，求排列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                <span class="comment">//背包比物品大，才可放入</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) dp[j] += dp[j - nums[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-爬楼梯-进阶版"><a href="#3-爬楼梯-进阶版" class="headerlink" title="3.爬楼梯(进阶版)"></a>3.爬楼梯(进阶版)</h1><ul><li>题目</li></ul><p><strong>一步一个台阶，两个台阶，三个台阶，…….，直到 m个台阶。问有多少种不同的方法可以爬到楼顶n呢？</strong></p><ul><li>思路分析</li></ul><p>1阶，2阶，…. m阶就是物品，楼顶就是背包。</p><p>每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。</p><p>问跳到楼顶有几种方法其实就是问装满背包有几种方法。</p><p><strong>此时大家应该发现这就是一个完全背包问题了！</strong></p><p>并且这是完全背包里求排列问题，即：<strong>1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！</strong></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改为：一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。</span></span><br><span class="line"><span class="comment"> * 问有多少种不同的方法可以爬到楼顶呢？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClimbingStairs2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climStairs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{ <span class="comment">//n表示一共有n个台阶，m表示一次最多可以跳m步</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完全背包中的排列问题</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {   <span class="comment">//先遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {  <span class="comment">//再遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i) dp[j] += dp[j - i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-零钱兑换"><a href="#4-零钱兑换" class="headerlink" title="4.零钱兑换"></a>4.零钱兑换</h1><p><a href="https://leetcode-cn.com/problems/coin-change/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1</p><p>示例 2： 输入：coins = [2], amount = 3 输出：-1</p><p>示例 3： 输入：coins = [1], amount = 0 输出：0</p><p>示例 4： 输入：coins = [1], amount = 1 输出：1</p><p>示例 5： 输入：coins = [1], amount = 2 输出：2</p><ul><li>思路分析</li></ul><ol start="0"><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p><ol><li>确定递推公式</li></ol><p>得到dp[j]（考虑coins[i]），只有一个来源，dp[j - coins[i]]（没有考虑coins[i]）。</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p><p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</p><ol start="2"><li>dp数组如何初始化</li></ol><p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;</p><p>其他下标对应的数值呢？</p><p>考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p><p>所以下标非0的元素都是应该是最大值。</p><ol start="3"><li>确定遍历顺序</li></ol><p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。</strong>。</p><p>所以本题并不强调集合是组合还是排列。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p><strong>所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！</strong></p><p>本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序</p><p>综上所述，<em>遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。</em></p><ol start="4"><li>举例推导dp数组</li></ol><p>以输入：coins = [1, 2, 5], amount = 5为例</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210925162533.jpeg"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinChange2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount ; j++) {</span><br><span class="line">                <span class="keyword">if</span> (dp[j - coins[i]] != Integer.MAX_VALUE) {  <span class="comment">//如果dp[j - coins[i]]是初始值则跳过</span></span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//============</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        CoinChange2 coinChange2 = <span class="keyword">new</span> CoinChange2();</span><br><span class="line">        <span class="keyword">int</span> i = coinChange2.coinChange(<span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>}, <span class="number">5</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-完全平方数"><a href="#5-完全平方数" class="headerlink" title="5.完全平方数"></a>5.完全平方数</h1><p><a href="https://leetcode-cn.com/problems/perfect-squares/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>示例 1： 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4</p><p>示例 2： 输入：n = 13 输出：2 解释：13 = 4 + 9</p><p>提示：1 &lt;= n &lt;= 10^4</p><ul><li>思路分析</li></ul><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><strong>dp[i]：和为i的完全平方数的最少数量为dp[i]</strong></p><ol start="2"><li>确定递推公式</li></ol><p>dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。</p><p>此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。</p><ol start="4"><li>确定遍历顺序</li></ol><p><strong>本题外层for遍历背包，里层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！</strong></p><p>这里给出外层遍历物品，里层遍历背包容量的代码</p><ol start="5"><li>举例推导dp数组</li></ol><p>已输入n为5例，dp状态图如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210925164445.jpeg"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerfectSquares</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; <span class="comment">//组成i,所需的完全平方数的最小个数dp[i]</span></span><br><span class="line"></span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) {  <span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j++) {   <span class="comment">//遍历背包</span></span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="6-单词拆分"><a href="#6-单词拆分" class="headerlink" title="6.单词拆分"></a>6.单词拆分</h1><p><a href="https://leetcode-cn.com/problems/word-break/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。</p><p>你可以假设字典中没有重复的单词。</p><p>示例 1： 输入: s = “leetcode”, wordDict = [“leet”, “code”] 输出: true 解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p><p>示例 2： 输入: s = “applepenapple”, wordDict = [“apple”, “pen”] 输出: true 解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。  注意你可以重复使用字典中的单词。</p><p>示例 3： 输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”] 输出: false</p><ul><li><p>思路分析</p><p>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</p><p>拆分时可以重复使用字典中的单词，说明就是一个完全背包！</p></li></ul><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p><ol start="2"><li>确定递推公式</li></ol><p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</p><p>所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</p><ol start="3"><li>dp数组如何初始化</li></ol><p>从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</p><ol start="4"><li>遍历顺序</li></ol><p><strong>遍历背包放在外循环，将遍历物品放在内循环。内循环从前到后</strong></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/word-break/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordBreak</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>{</span><br><span class="line">        <span class="comment">//dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。</span></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) {</span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(s.substring(j,i)) &amp;&amp; dp[j]) {</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><hr><h1 id="7-打家劫舍"><a href="#7-打家劫舍" class="headerlink" title="7.打家劫舍"></a>7.打家劫舍</h1><p><a href="https://leetcode-cn.com/problems/house-robber/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  偷窃到的最高金额 = 1 + 3 = 4 。</p><p>示例 2： 输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。  偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><ul><li>思路分析</li></ul><p>打家劫舍是dp解决的经典问题，动规五部曲分析如下：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。</p><ol start="2"><li>确定递推公式</li></ol><p>决定dp[i]的因素就是第i房间偷还是不偷。</p><p>如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p><p>如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房，（<strong>注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点</strong>）</p><p>然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]</p><p>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);</p><ol start="4"><li>确定遍历顺序</li></ol><p>dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</p><ol start="5"><li>举例推导dp数组</li></ol><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210925195655.jpeg"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/house-robber/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobber</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">//dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="comment">//决定dp[i] 的因素就是 第i房间 偷还是不偷</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="8-打家劫舍2"><a href="#8-打家劫舍2" class="headerlink" title="8.打家劫舍2"></a>8.打家劫舍2</h1><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p><p>示例 2： 输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4 。</p><p>示例 3： 输入：nums = [0] 输出：0</p><ul><li>思路分析</li></ul><p>分两种情况考虑，1.考虑抢劫第一家，最后一家放弃，2.考虑抢劫最后一家，第一家放弃</p><p>然后利用<strong>7.打家劫舍</strong>的代码进行判断即可</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/house-robber-ii/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobber2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result1 = robRange(<span class="number">0</span>, nums.length - <span class="number">2</span>, nums);  <span class="comment">//考虑抢劫第一家，最后一家放弃</span></span><br><span class="line">        <span class="keyword">int</span> result2 = robRange(<span class="number">1</span>, nums.length - <span class="number">1</span>, nums);  <span class="comment">//考虑抢劫最后一家，第一家放弃</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(result1, result2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通的打家劫舍逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">robRange</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = Math.max(nums[start + <span class="number">1</span>], nums[start]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) {</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="9-打家劫舍3"><a href="#9-打家劫舍3" class="headerlink" title="9.打家劫舍3"></a>9.打家劫舍3</h1><p><a href="https://leetcode-cn.com/problems/house-robber-iii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210927142315.png" alt="337.打家劫舍III"></p><ul><li>思路分析</li></ul><p>1.确定递归函数的参数和返回值</p><p>这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。</p><p>参数为当前节点，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* cur)</span> </span>{</span><br></pre></td></tr></tbody></table></figure><p>其实这里的返回数组就是dp数组。</p><p>所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。</p><p><strong>所以本题dp数组就是一个长度为2的数组！</strong></p><p>那么有同学可能疑惑，长度为2的数组怎么标记树中每个节点的状态呢？</p><p><strong>别忘了在递归的过程中，系统栈会保存每一层递归的参数</strong>。</p><p>如果还不理解的话，就接着往下看，看到代码就理解了哈。</p><br><p>2.确定终止条件</p><p>在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (cur == NULL) return vector&lt;int&gt;{0, 0};</span><br></pre></td></tr></tbody></table></figure><p>这也相当于dp数组的初始化</p><p>3.确定遍历顺序</p><p>首先明确的是使用后序遍历。 因为通过递归函数的返回值来做下一步计算。</p><p>通过递归左节点，得到左节点偷与不偷的金钱。</p><p>通过递归右节点，得到右节点偷与不偷的金钱。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下标0：不偷，下标1：偷</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line"><span class="comment">// 中</span></span><br></pre></td></tr></tbody></table></figure><p>4.确定单层递归的逻辑</p><p>如果是偷当前节点，那么左右孩子就不能偷，val1 = cur-&gt;val + left[0] + right[0]; （<strong>如果对下标含义不理解就在回顾一下dp数组的含义</strong>）</p><p>如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 = max(left[0], left[1]) + max(right[0], right[1]);</p><p>最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 偷cur</span></span><br><span class="line"><span class="keyword">int</span> val1 = cur-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 不偷cur</span></span><br><span class="line"><span class="keyword">int</span> val2 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> {val2, val1};</span><br></pre></td></tr></tbody></table></figure><p>5.举例推导dp数组</p><p>以示例1为例，dp数组状态如下：（<strong>注意用后序遍历的方式推导</strong>）</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210927142428.jpeg" alt="337.打家劫舍III"></p><p><strong>最后头结点就是 取下标0 和 下标1的最大值就是偷得的最大金钱</strong>。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/house-robber-iii/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobber3</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//长度为2的数组，0:不偷当前节点，1:偷当前节点</span></span><br><span class="line">        <span class="keyword">int</span>[] res = robTree(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] robTree(TreeNode root) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后序递归遍历 左 右 中</span></span><br><span class="line">        <span class="keyword">int</span>[] left = robTree(root.left);   <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">int</span>[] right = robTree(root.right); <span class="comment">//右</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不偷当前节点，偷取的最大金额</span></span><br><span class="line">        <span class="keyword">int</span> val0 = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果偷当前节点，偷取的最大金额</span></span><br><span class="line">        <span class="keyword">int</span> val1 = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{val0, val1};</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>以上题目参考：LeetCode，思路分析参考：<a href="https://programmercarl.com/">代码随想录</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 完全背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP基础①</title>
      <link href="/posts/942d.html"/>
      <url>/posts/942d.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是cookie"><a href="#1-什么是cookie" class="headerlink" title="1.什么是cookie"></a>1.什么是cookie</h1><p>Cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态</p><ol><li>cookie会根据从服务器端发送的响应报文中的一个叫做Set-Cookie的首部字段信息，通知客户端保存cookie.</li><li>当下次客户端再向服务器端发送请求时，客户端会自动在请求报文中加入cookie值后发送出去</li><li>服务器端发现客户端发来的cookie后，会检查是哪一个客户端发送过来的连接请求，然后得到之前的状态信息</li></ol><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922163505.png" alt="无cookie的请求"></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922163858.png" alt="带有cookie的请求"></p><h1 id="2-HTTP报文"><a href="#2-HTTP报文" class="headerlink" title="2.HTTP报文"></a>2.HTTP报文</h1><p>HTTP报文的主体用于传输请求或响应的实体主体</p><p>通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异</p><h2 id="2-1请求和响应的报文首部"><a href="#2-1请求和响应的报文首部" class="headerlink" title="2.1请求和响应的报文首部"></a>2.1请求和响应的报文首部</h2><p>请求报文和响应报文的首部内容有以下数据组成：</p><ol><li><p>请求行</p><p>包含请求方法，请求URI,http版本</p></li><li><p>状态行</p><p>包含响应结果的状态码，原因短语，http版本</p></li><li><p>首部字段</p><p>包含请求和响应的各种条件，以及属性的各类首部</p><p>一般有4中首部，分别是：通用首部，请求首部，响应首部，实体首部</p></li><li><p>其他</p><p>可能包含http的RFC里未定义的首部(cookie等)</p></li></ol><br><h1 id="3-HTTP状态码"><a href="#3-HTTP状态码" class="headerlink" title="3.HTTP状态码"></a>3.HTTP状态码</h1><ul><li>状态码的作用是当客户端向服务器端发送请求时，描述返回的请求结果</li></ul><h2 id="3-1状态码的类别"><a href="#3-1状态码的类别" class="headerlink" title="3.1状态码的类别"></a>3.1状态码的类别</h2><table><thead><tr><th align="center"></th><th align="center">类别</th><th align="center">原因短语</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">information(信息性状态码)</td><td align="center">接受的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">Success(成功状态码)</td><td align="center">请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">Redirection(重定向状态码)</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">Client Error(客户端错误状态码)</td><td align="center">服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">Server Error(服务器错误状态码)</td><td align="center">服务器处理请求出错</td></tr></tbody></table><br><h2 id="3-2常见状态码"><a href="#3-2常见状态码" class="headerlink" title="3.2常见状态码"></a>3.2常见状态码</h2><h3 id="2XX开头"><a href="#2XX开头" class="headerlink" title="2XX开头"></a>2XX开头</h3><ol><li><p>200 OK</p><p>表示从客户端发来的请求在服务器端被正常处理了</p></li><li><p>204 No Content</p><p>一般只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用</p></li><li><p>206 Partial Content</p><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由</p><p>Content-Range指定范围的实体内容</p></li></ol><h3 id="3XX开头"><a href="#3XX开头" class="headerlink" title="3XX开头"></a>3XX开头</h3><ul><li>3XX响应结果表示浏览器需要执行某些特殊的处理以正确处理请求</li></ul><ol><li><p>301 Moved Permanently</p><p>永久性重定向。该状态码表示请求的资源已经被分配了新的URI,以后应使用资源现在所指的URI</p></li><li><p>302 Found</p><p>临时性重定向。该状态码表示请求的资源已被分配了新的URI,希望用户本次能使用新的URI访问</p></li><li><p>303 See Other</p><p>该状态码表示由于请求对应的资源存在着另一个URI,应使用GET方法定向获取请求资源</p></li></ol><h3 id="4XX开头"><a href="#4XX开头" class="headerlink" title="4XX开头"></a>4XX开头</h3><ul><li>4XX的响应结果表明客户端是发生错误的原因所在</li></ul><ol><li><p>400 Bad Request</p><p>该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求内容后再次发送请求</p></li><li><p>401 Unauthorized</p><p>该状态码表示发送的请求需要有通过HTTP认证的认证信息。另外，若之前已经进行过1次请求，</p><p>则表示用户认证失败</p></li><li><p>403 Forbidden</p><p>该状态码表明对请求资源的访问被服务器拒绝了。</p><p>未获得文件系统的访问授权，访问权限出现某些问题等，都可能是发生403的原因</p></li><li><p>404 Not Found</p><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明原因时使用</p></li></ol><h3 id="5XX开头"><a href="#5XX开头" class="headerlink" title="5XX开头"></a>5XX开头</h3><ul><li>5XX的响应结果表明服务器本身发生错误</li></ul><ol><li><p>500 Internal Server Error</p><p>该状态码表明服务器在执行请求过程中发生了错误。也有可能是Web应用存在的bug或某些临时的故障</p></li><li><p>503 Service Unavailable</p><p>该状态码表示服务器暂时处于超负载或停机维护状态，现在无法处理请求。</p><p>如果事先得知解除以上状况所需要的时间，最好写入Retry-After首部字段再返回给客户端。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 图解HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> http报文 </tag>
            
            <tag> http状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划刷题笔记①</title>
      <link href="/posts/517c.html"/>
      <url>/posts/517c.html</url>
      
        <content type="html"><![CDATA[<ul><li>动态规划五部曲<ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol></li></ul><h1 id="1-斐波那契数"><a href="#1-斐波那契数" class="headerlink" title="1.斐波那契数"></a>1.斐波那契数</h1><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p><p>示例 1： 输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1</p><p>示例 2： 输入：3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2</p><p>示例 3： 输入：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3</p><p>提示：</p><p>0 &lt;= n &lt;= 30</p><ul><li>思路分析</li></ul><p>1.确定dp数组以及下标的含义</p><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><p>2.确定递推公式</p><p><strong>题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p><p>3.dp数组初始化</p><p>dp[0] = 0;</p><p>dp[1]  = 1;</p><p>4.确定遍历顺序</p><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><p>5.举例推导dp数组</p><p>0 1 1 2 3 5 8 13 21 34 55</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/fibonacci-number/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciNumber</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">            sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = sum;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;  <span class="comment">//return dp[1]也可以</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-爬楼梯"><a href="#2-爬楼梯" class="headerlink" title="2.爬楼梯"></a>2.爬楼梯</h1><p><a href="">leetcode题目链接</a></p><ul><li>题目</li></ul><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol><p>示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><ul><li>思路分析</li></ul><p>此题与<em>菲波那切数</em>几乎一样，只不过初始条件不一样罢了</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClimbingStairs</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-使用最小花费爬楼梯"><a href="#3-使用最小花费爬楼梯" class="headerlink" title="3.使用最小花费爬楼梯"></a>3.使用最小花费爬楼梯</h1><p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例 1：</p><p>输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。  示例 2：</p><p>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</p><p>提示：</p><ul><li>cost 的长度范围是 [2, 1000]。</li><li>cost[i] 将会是一个整型数据，范围为 [0, 999] </li></ul><br><ul><li>思路分析</li></ul><ol><li><p>确定dp数组以及下标的含义</p><p>**dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]**。</p></li><li><p>确定递推公式</p><p>**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。</p><p>那么究竟是选dp[i-1]还是dp[i-2]呢？</p><p>一定是选最小的，所以dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];</p><p><strong>注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的</strong>，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值</p></li><li><p>dp数组的初始化</p><p>dp[i]由dp[i-1]，dp[i-2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[0] = cost[0];</span><br><span class="line">dp[1] = cost[1];</span><br></pre></td></tr></tbody></table></figure></li><li><p>确定遍历顺序</p><p>因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了</p></li><li><p>举例推导dp数组</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922100952.png"></p></li></ol><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/min-cost-climbing-stairs/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinCostClimbingStairs</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length]; <span class="comment">//1.dp[i] 表示爬上i层楼所需的最小花费</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.dp数组的初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.确定遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= dp.length - <span class="number">1</span>; i++) {</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>],dp[i - <span class="number">2</span>]) + cost[i]; <span class="comment">//2.确定递推公式</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[dp.length - <span class="number">1</span>],dp[dp.length - <span class="number">2</span>]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-不同路径"><a href="#4-不同路径" class="headerlink" title="4.不同路径"></a>4.不同路径</h1><p><a href="https://leetcode-cn.com/problems/unique-paths/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><ul><li>思路分析</li></ul><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p><ol start="2"><li>确定递推公式</li></ol><p>想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。</p><p>此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。</p><p>那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。</p><ol start="3"><li>dp数组的初始化</li></ol><p>如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。</p><p>所以初始化代码为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">for (int j = 0; j &lt; n; j++) dp[0][j] = 1;</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>这里要看一下递归公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p><p>这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。</p><ol start="5"><li>举例推导dp数组</li></ol><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/unique-paths/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePaths</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n]; <span class="comment">//1.确定dp数组，dp[i][j] 表示 (0,0) -&gt; (i,j)一共有多少种路径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.dp数组的初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="comment">//4.确定递推表达式</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-不同路径-II"><a href="#5-不同路径-II" class="headerlink" title="5. 不同路径 II"></a>5. 不同路径 II</h1><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><ul><li>思路分析</li></ul><p>此题与<strong>4.不同路径</strong>类似，只是多了障碍物，需要注意障碍物的处理</p><p>初始化时的障碍物处理：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>递推遍历时，对于障碍物的处理：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;  <span class="comment">//如果遇到障碍物则跳过</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/unique-paths-ii/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePath2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-不同的二叉搜索树"><a href="#6-不同的二叉搜索树" class="headerlink" title="6.不同的二叉搜索树"></a>6.不同的二叉搜索树</h1><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922104340.png"></p><ul><li>思路分析</li></ul><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。</p><p>也可以理解是i的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。</p><p>以下分析如果想不清楚，就来回想一下dp[i]的定义</p><ol start="2"><li>确定递推公式</li></ol><p>在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</p><p>j相当于是头结点的元素，从1遍历到i为止。</p><p>所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p><ol start="3"><li>dp数组如何初始化</li></ol><p>初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。</p><p>那么dp[0]应该是多少呢？</p><p>从定义上来讲，空节点也是一颗二叉树，也是一颗二叉搜索树，这是可以说得通的。</p><p>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。</p><p>所以初始化dp[0] = 1</p><ol start="4"><li>确定遍历顺序</li></ol><p>首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p><p>那么遍历i里面每一个数作为头结点的状态，用j来遍历。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) {</span><br><span class="line">        dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><p>举例推导dp数组</p><p>n为5时候的dp数组状态如图：</p></li></ol><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922110842.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/unique-binary-search-trees/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];   <span class="comment">// 1到i为节点组成的二叉搜索树的个数为dp[i]。</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;     <span class="comment">//初始化，空节点也是一颗二叉树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="comment">//j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) {</span><br><span class="line">                dp[i] += dp[j-<span class="number">1</span>] * dp[i-j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = numTrees(<span class="number">3</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br><hr><h1 id="7-0-1背包理论基础-一"><a href="#7-0-1背包理论基础-一" class="headerlink" title="7.0-1背包理论基础(一)"></a>7.0-1背包理论基础(一)</h1><p>参见：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85">代码随想录</a>，使用二维数组实现0-1背包。</p><br><h1 id="8-0-1背包理论基础-二"><a href="#8-0-1背包理论基础-二" class="headerlink" title="8.0-1背包理论基础(二)"></a>8.0-1背包理论基础(二)</h1><ul><li><p>一维dp数组(滚动数组)</p></li><li><p>题目</p></li></ul><p>背包最大重量为4。</p><p>物品为：</p><table><thead><tr><th align="center">重量</th><th>价值</th><th></th></tr></thead><tbody><tr><td align="center">物品0</td><td>1</td><td>15</td></tr><tr><td align="center">物品1</td><td>3</td><td>20</td></tr><tr><td align="center">物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><ul><li>思路分析</li></ul><ol><li>确定dp数组的定义</li></ol><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><ol start="2"><li>一维dp数组的递推公式</li></ol><p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p><p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>所以递归公式为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></tbody></table></figure><p>可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。</p><ol start="3"><li>一维dp数组如何初始化</li></ol><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p><p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p><p>看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p><p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p><p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p><ol start="4"><li>一维dp数组遍历顺序</li></ol><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品</span><br><span class="line">    for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量</span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922140611.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 01背包问题，使用一维数组实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag01OneArray</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test01BagProblem</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> bagSize)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义dp数组，dp[j] 表示容量为j的背包 所放物品的总价值</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[bagSize + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//初始化dp数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定遍历顺序，以及递归的表达式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.length; i++) {  <span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = bagSize; j &gt;= weight[i] ; j--) {  <span class="comment">//遍历背包容量(倒序遍历)</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[weight.length];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] weight = {<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">        <span class="keyword">int</span>[] value = {<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>};</span><br><span class="line"></span><br><span class="line">        test01BagProblem(weight,value,<span class="number">4</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="9-分割等和子集"><a href="#9-分割等和子集" class="headerlink" title="9.分割等和子集"></a>9.分割等和子集</h1><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200</p><p>示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 200</p><p>1 &lt;= nums[i] &lt;= 100</p><ul><li>思路分析</li></ul><p>动规五部曲分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p>01背包中，dp[i] 表示： 容量为j的背包，所背的物品价值可以最大为dp[j]。</p><p>**套到本题，dp[i]表示 背包总容量是i，最大可以凑成i的子集总和为dp[i]**。</p><ol start="2"><li>确定递推公式</li></ol><p>01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p><p>本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</p><p>所以递推公式：<code>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</code></p><ol start="3"><li>dp数组如何初始化</li></ol><p>在01背包，一维dp如何初始化，已经讲过，</p><p>从dp[j]的定义来看，首先dp[0]一定是0。</p><p>如果如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p><p>本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。</p><ol start="4"><li>确定遍历顺序</li></ol><p>如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒叙遍历！</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始 01背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= nums[i]; j--) { <span class="comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>dp[i]的数值一定是小于等于i的。</p><p><strong>如果dp[i] == i 说明，集合中的子集总和正好可以凑成总和i，理解这一点很重要。</strong></p><p>用例1，输入[1,5,11,5] 为例，如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922143059.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/partition-equal-subset-sum/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualSubsetSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">            sum += num;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//如果是奇数，则不能平分为两个相等的子集</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>]; <span class="comment">//dp[j] 表示 容量为j 可放入的最大元素和</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;                     <span class="comment">//初始化dp</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定遍历顺序以及，递归表达式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i] ; j--) {</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="10-最后一块石头的重量-II"><a href="#10-最后一块石头的重量-II" class="headerlink" title="10.最后一块石头的重量 II"></a>10.最后一块石头的重量 II</h1><p><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><p>如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><ul><li>思路分析</li></ul><p>本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，<strong>这样就化解成01背包问题了</strong>。</p><p>和<a href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">9. 分割等和子集</a>非常像了。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LastStone</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) {</span><br><span class="line">            sum += stone;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = sum &gt;&gt; <span class="number">1</span>; <span class="comment">//sum / 2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>]; <span class="comment">//dp[j] 表示容量j 可以 装入的最大重量 dp[j]</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定遍历顺序以及状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= stones[i]; j--) {</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum - dp[target] - dp[target];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="11目标和"><a href="#11目标和" class="headerlink" title="11目标和"></a>11目标和</h1><p><a href="https://leetcode-cn.com/problems/target-sum/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5</p><p>解释：<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3</p><p>一共有5种方法让最终目标和为3。</p><ul><li>思路分析</li></ul><p>如何转化为01背包问题呢。</p><p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p><p>所以我们要求的是 x - (sum - x) = S</p><p>x = (S + sum) / 2</p><p><strong>此时问题就转化为，装满容量为x背包，有几种方法</strong>。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[i]种方法</p><ol start="2"><li>确定递推公式</li></ol><p>不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。</p><p>那么只要搞到nums[i]的话，凑成dp[j]就有dp[j - nums[i]] 种方法。</p><p>举一个例子,nums[i] = 2： dp[3]，填满背包容量为3的话，有dp[3]种方法。</p><p>那么只需要搞到一个2（nums[i]），有dp[3]方法可以凑齐容量为3的背包，相应的就有多少种方法可以凑齐容量为5的背包。</p><p>那么需要把 这些方法累加起来就可以了，dp[j] += dp[j - nums[i]]</p><p>所以求组合类问题的公式，都是类似这种：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>dp数组如何初始化</li></ol><p>从递归公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递归结果将都是0。</p><p>dp[0] = 1，理论上也很好解释，装满容量为0的背包，有1种方法，就是装0件物品。</p><p>dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。</p><ol start="4"><li>确定遍历顺序</li></ol><p>物品放在外循环，背包容量放在内循环，且内循环倒序</p><ol start="5"><li>举例推导dp数组</li></ol><p>输入：nums: [1, 1, 1, 1, 1], S: 3</p><p>bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4</p><p>dp数组状态变化如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210925141228.jpeg"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/target-sum/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">            sum += num;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bagSize = (sum + target) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[bagSize + <span class="number">1</span>];   <span class="comment">//dp[i] 表示装满容量为i的有多少种组合</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = bagSize; j &gt;= nums[i]; j--) {</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>以上题目参考：LeetCode，思路分析参考：<a href="https://programmercarl.com/">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法刷题笔记②-贪心解决区间问题</title>
      <link href="/posts/c9cc.html"/>
      <url>/posts/c9cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-用最少数量的箭引爆气球"><a href="#1-用最少数量的箭引爆气球" class="headerlink" title="1.用最少数量的箭引爆气球"></a>1.用最少数量的箭引爆气球</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p>示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]]</p><p>输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</p><ul><li>思路分析</li></ul><p>局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。</p><p><strong>算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？</strong></p><p>如果真实的模拟射气球的过程，应该射一个，气球数组就remove一个元素，这样最直观，毕竟气球被射了。</p><p>但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remove气球，只要记录一下箭的数量就可以了。</p><p>以上为思考过程，已经确定下来使用贪心了，那么开始解题。</p><p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。</p><p><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong>。</p><p>以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序）</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210912155250.png"></p><p>可以看出首先第一组重叠气球，一定是需要一个箭，气球3，的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了.</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BurstBalloons</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() { <span class="comment">//按照左边界排序,从小到大排序</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>{</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] &lt; o2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (o1[<span class="number">0</span>] &gt; o2[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) {  <span class="comment">//两个气球如果不挨着</span></span><br><span class="line">                result++;  <span class="comment">//需要一支箭</span></span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {  <span class="comment">//气球i和i-1挨着</span></span><br><span class="line">                points[i][<span class="number">1</span>] = Math.min(points[i-<span class="number">1</span>][<span class="number">1</span>],points[i][<span class="number">1</span>]); <span class="comment">// 更新重叠气球最小右边界</span></span><br><span class="line">                                                                      <span class="comment">// 即：取两者之中较小的右边界作为气球i的右边界</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-无重叠区间"><a href="#2-无重叠区间" class="headerlink" title="2.无重叠区间"></a>2.无重叠区间</h1><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。</p><p>示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p><p>示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了</p><ul><li>思路分析</li></ul><p>如果遇到重叠的区间，则将result+1，并且缩减当前区间的右边界(相当于把这个区间移除了)</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonOverlapping</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (intervals.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() { <span class="comment">//按照区间左边界排序</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>{</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] &gt; o2[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (o1[<span class="number">0</span>] &lt; o2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>]) { <span class="comment">//如果有重叠部分</span></span><br><span class="line">                result++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//相当于删除一个</span></span><br><span class="line">                intervals[i][<span class="number">1</span>] = Math.min(intervals[i - <span class="number">1</span>][<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-划分字母区间"><a href="#3-划分字母区间" class="headerlink" title="3.划分字母区间"></a>3.划分字母区间</h1><p><a href="https://leetcode-cn.com/problems/partition-labels/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>示例： 输入：S = “ababcbacadefegdehijhklij” 输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p><p>提示：</p><p>S的长度在[1, 500]之间。</p><p>S只包含小写字母 ‘a’ 到 ‘z’ 。</p><ul><li>思路分析</li></ul><p>在遍历的过程中相当于是要找每一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</p><p>可以分为如下两步：</p><p>统计每一个字符最后出现的位置</p><p>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</p><p>如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210912160310.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionLabels</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] edge = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">            edge[s.charAt(i) - <span class="string">'a'</span>] = i;  <span class="comment">//找到字符出现的最远下标</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line"></span><br><span class="line">            right = Math.max(edge[s.charAt(i) - <span class="string">'a'</span>],right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == right) {            <span class="comment">//找到字符出现的最远边界,说明到了划分点</span></span><br><span class="line">                <span class="keyword">int</span> partition = right - left + <span class="number">1</span>;</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">                result.add(partition);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-合并区间"><a href="#4-合并区间" class="headerlink" title="4.合并区间"></a>4.合并区间</h1><p><a href="https://leetcode-cn.com/problems/merge-intervals/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1: 输入: intervals = [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p><p>示例 2: 输入: intervals = [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。</p><p>提示：</p><p><code>intervals[i][0] &lt;= intervals[i][1]</code></p><ul><li>思路分析</li></ul><p>按照左边界从小到大排序之后，先将intervals[0]，加入到result集合中。</p><p>如果 <code>intervals[i][0] &lt;= result.getLast()[1]</code> 即<code>intervals[i]左边界 &lt; result.getLast()右边界</code>，则一定有重复</p><p>知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？</p><p>其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result集合里就可以了。</p><p>如果没有重复区间就把原区间加入到result集合。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeIntervals</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) {</span><br><span class="line"></span><br><span class="line">        Arrays.sort(intervals, (o1, o2) -&gt; Integer.compare(o1[<span class="number">0</span>],o2[<span class="number">0</span>]));<span class="comment">//按照左边界排序</span></span><br><span class="line">        LinkedList&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        result.add(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= result.getLast()[<span class="number">1</span>]) { <span class="comment">//如果有重叠的部分</span></span><br><span class="line">                <span class="keyword">int</span> start = result.getLast()[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> end = Math.max(result.getLast()[<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                result.removeLast();     <span class="comment">//先把result集合中的取出来</span></span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="keyword">int</span>[]{start,end});  <span class="comment">//再加入新的数组进到result集合中</span></span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                result.add(intervals[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[result.size()][]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><hr><p>以上题目及思路分析参考：leetcode及<a href="https://programmercarl.com/">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法刷题笔记①</title>
      <link href="/posts/2a28.html"/>
      <url>/posts/2a28.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-分发饼干"><a href="#1-分发饼干" class="headerlink" title="1.分发饼干"></a>1.分发饼干</h1><p><a href="https://leetcode-cn.com/problems/assign-cookies/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 2: 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2.</p><ul><li>代码详情</li></ul><p>思路：用小饼干先喂小胃口的孩子</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分发饼干</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/assign-cookies/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssignCookies</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *小饼干先喂饱小胃口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> g 小孩的胃口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 饼干的尺寸</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 饼干能满足小孩的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>{</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index &lt; g.length &amp;&amp; s[i] &gt;= g[index]){ <span class="comment">//如果满足了小孩的胃口</span></span><br><span class="line">                result++;</span><br><span class="line">                index++;  <span class="comment">//看下一个小孩的胃口</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-摆动序列"><a href="#2-摆动序列" class="headerlink" title="2.摆动序列"></a>2.摆动序列</h1><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1: 输入: [1,7,4,9,2,5] 输出: 6 解释: 整个序列均为摆动序列。</p><p>示例 2: 输入: [1,17,5,10,13,15,10,5,16,8] 输出: 7 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</p><ul><li>思路分析</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210911134723.png"></p><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiggleSubsequence</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> preDiff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curDiff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) {</span><br><span class="line">            curDiff = nums[i+<span class="number">1</span>] - nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前差值和上一个差值为一正一负</span></span><br><span class="line">            <span class="comment">//等于0的情况表示初始时的preDiff</span></span><br><span class="line">            <span class="keyword">if</span> ((curDiff &gt; <span class="number">0</span> &amp;&amp; preDiff &lt;= <span class="number">0</span>) || (curDiff &lt; <span class="number">0</span> &amp;&amp; preDiff &gt;= <span class="number">0</span>)){</span><br><span class="line">                count++;</span><br><span class="line">                preDiff = curDiff;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-最大子序列和"><a href="#3-最大子序列和" class="headerlink" title="3.最大子序列和"></a>3.最大子序列和</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">LeetCode题目链接</a></p><ul><li>题目</li></ul><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><ul><li>思路分析</li></ul><p><strong>贪心贪的是哪里呢？</strong></p><p>如果 -2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！</p><p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p><p>全局最优：选取最大“连续和”</p><p><strong>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优</strong>。</p><p>从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。</p><p><strong>这相当于是暴力解法中的不断调整最大子序和区间的起始位置</strong>。</p><p><strong>那有同学问了，区间终止位置不用调整么？ 如何才能得到最大“连续和”呢？</strong></p><p>区间的终止位置，其实就是如果count取到最大值了，及时记录下来了。例如如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &gt; result) result = count;</span><br></pre></td></tr></tbody></table></figure><p><strong>这样相当于是用result记录最大子序和区间和（变相的算是调整了终止位置）</strong>。</p><p>如动画所示:</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif"></p><p>红色的起始位置就是贪心每次取count为正数的时候，开始一个区间的统计。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubarray</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**方法一：</span></span><br><span class="line"><span class="comment">     * 暴力解法，时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) {</span><br><span class="line">                count += nums[j];</span><br><span class="line">                result = count &gt; result ? count : result;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**方法二：</span></span><br><span class="line"><span class="comment">     * 贪心算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            count += nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取区间累计的最大值（相当于不断确定最大子序终止位置）</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; result) result = count;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) count = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-买卖股票的最佳时机II"><a href="#4-买卖股票的最佳时机II" class="headerlink" title="4.买卖股票的最佳时机II"></a>4.买卖股票的最佳时机II</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p>示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p>示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><ul><li>思路分析</li></ul><p>计算相邻两天的价格差，若为正，则说明有利润可图，则加入到总利润中</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStock</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组求两天的价格差，只要是正(说明有利润)，就累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> temp = prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; <span class="number">0</span>){</span><br><span class="line">                result += temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-跳跃游戏"><a href="#5-跳跃游戏" class="headerlink" title="5.跳跃游戏"></a>5.跳跃游戏</h1><p><a href="https://leetcode-cn.com/problems/jump-game/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p>示例 1: 输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p><p>示例 2: 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p><ul><li>思路分析</li></ul><p>刚看到本题一开始可能想：当前位置元素如果是3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？</p><p>其实跳几步无所谓，关键在于可跳的覆盖范围！</p><p>不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。</p><p>这个范围内，别管是怎么跳的，反正一定可以跳过来。</p><p><strong>那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！</strong></p><p>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p><p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p><p>局部最优推出全局最优，找不出反例，试试贪心！</p><p>如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210911144211.png"></p><p>i每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让i继续移动下去。</p><p>而cover每次只取 max(该元素数值补充后的范围, cover本身范围)。</p><p>如果cover大于等于了终点下标，直接return true就可以了。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpGame</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cover; i++){  <span class="comment">// 注意这里是小于等于cover</span></span><br><span class="line">            cover = Math.max(i + nums[i],cover);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 说明可以覆盖到终点了</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-跳跃游戏II"><a href="#6-跳跃游戏II" class="headerlink" title="6.跳跃游戏II"></a>6.跳跃游戏II</h1><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p><p>说明: 假设你总是可以到达数组的最后一个位置。</p><ul><li>思路分析</li></ul><p>移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。</p><p>想要达到这样的效果，只要让移动下标，最大只能移动到<code>nums.size - 2</code>的地方就可以了。</p><p>因为当移动下标指向<code>nums.size - 2</code>时：</p><p>1.如果移动下标等于当前覆盖最大距离下标， 需要再走一步（即ans++），因为最后一步一定是可以到的终点。（题目假设总是可以到达数组的最后一个位置），如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210911145857.png"></p><p>2.如果移动下标不等于当前覆盖最大距离下标，说明当前覆盖最远距离就可以直接达到终点了，不需要再走一步。如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210911150006.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpGame2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> curDistance = <span class="number">0</span>;    <span class="comment">// 当前覆盖的最远距离下标</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;            <span class="comment">// 记录走的最大步数</span></span><br><span class="line">        <span class="keyword">int</span> nextDistance = <span class="number">0</span>;   <span class="comment">// 下一步覆盖的最远距离下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) { <span class="comment">// 注意这里是小于nums.size() - 1，这是关键所在</span></span><br><span class="line">            nextDistance = Math.max(nums[i] + i, nextDistance); <span class="comment">// 更新下一步覆盖的最远距离下标</span></span><br><span class="line">            <span class="keyword">if</span> (i == curDistance) {                 <span class="comment">// 遇到当前覆盖的最远距离下标</span></span><br><span class="line">                curDistance = nextDistance;         <span class="comment">// 更新当前覆盖的最远距离下标</span></span><br><span class="line">                ans++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="7-加油站"><a href="#7-加油站" class="headerlink" title="7.加油站"></a>7.加油站</h1><p><a href="https://leetcode-cn.com/progress/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明:</p><p>如果题目有解，该答案即为唯一答案。</p><p>输入数组均为非空数组，且长度相同。</p><p>输入数组中的元素均为非负数。</p><p>示例 1: 输入: gas = [1,2,3,4,5] cost = [3,4,5,1,2]</p><p>输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。</p><ul><li>思路分析</li></ul><p>首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。</p><p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p><p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</p><p>如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210911153807.png"></p><p>那么为什么一旦[i，j] 区间和为负数，起始位置就可以是j+1呢，j+1后面就不会出现更大的负数？</p><p>如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了。</p><p>而且j之前出现了多少负数，j后面就会出现多少正数，因为耗油总和是大于零的（前提我们已经确定了一定可以跑完全程）。</p><p><strong>那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GasStation</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> totalRest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; i++) {</span><br><span class="line"></span><br><span class="line">            curSum += (gas[i] - cost[i]);</span><br><span class="line">            totalRest += (gas[i] - cost[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) {   <span class="comment">// 当前累加gas[i] - cost[i]的和 curSum一旦小于0</span></span><br><span class="line">                start = i + <span class="number">1</span>;  <span class="comment">// 起始位置更新为i+1</span></span><br><span class="line">                curSum = <span class="number">0</span>;     <span class="comment">// curSum从0开始</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (totalRest &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 说明怎么走都不可能跑一圈了</span></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="8-单调递增的数字"><a href="#8-单调递增的数字" class="headerlink" title="8.单调递增的数字"></a>8.单调递增的数字</h1><p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p><p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。）</p><p>示例 1: 输入: N = 10 输出: 9</p><p>示例 2: 输入: N = 1234 输出: 1234</p><p>示例 3: 输入: N = 332 输出: 299</p><ul><li>思路分析</li></ul><p>题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。</p><p>例如：98，一旦出现<code>strNum[i - 1] &gt; strNum[i]</code>的情况（非单调递增），首先想让<code>strNum[i - 1]--</code>，然后<code>strNum[i]给为9</code>，这样这个整数就是89，即小于98的最大的单调递增整数。</p><p>这一点如果想清楚了，这道题就好办了。</p><p><strong>局部最优：遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]–，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数</strong>。</p><p><strong>全局最优：得到小于等于N的最大单调递增的整数</strong>。</p><p><strong>但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9</strong>。</p><p>此时是从前向后遍历还是从后向前遍历呢？</p><p>从前向后遍历的话，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。</p><p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p><p><strong>所以从前后向遍历会改变已经遍历过的结果！</strong></p><p>那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p><p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonotoneIncreasingDigits</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String str = String.valueOf(n); <span class="comment">//将n转为String串</span></span><br><span class="line">        <span class="keyword">char</span>[] s = str.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flag用来标记赋值9从哪里开始</span></span><br><span class="line">        <span class="comment">// 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行</span></span><br><span class="line">        <span class="keyword">int</span> flag = str.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] &gt; s[i]) {</span><br><span class="line">                flag = i;</span><br><span class="line">                s[i - <span class="number">1</span>] = (<span class="keyword">char</span>) (s[i - <span class="number">1</span>] - <span class="number">1</span>); <span class="comment">//s[i - 1]  -&gt; int (转为int类型)</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; flag &lt; s.length; flag++) {  <span class="comment">//将下标flag及其后面的数，全部置为'9'</span></span><br><span class="line">            s[flag] = <span class="string">'9'</span>;</span><br><span class="line">        }</span><br><span class="line">        String result = String.valueOf(s);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(result);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//----------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MonotoneIncreasingDigits num = <span class="keyword">new</span> MonotoneIncreasingDigits();</span><br><span class="line">        <span class="keyword">int</span> i = num.monotoneIncreasingDigits(<span class="number">318</span>); <span class="comment">//322</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>本篇博文参考：<a href="https://programmercarl.com/">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法刷题笔记②</title>
      <link href="/posts/e46.html"/>
      <url>/posts/e46.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-分割回文串"><a href="#1-分割回文串" class="headerlink" title="1.分割回文串"></a>1.分割回文串</h1><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">力扣题目链接</a></p><ul><li>题目</li></ul><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例: 输入:<code> "aab" 输出: [ ["aa","b"], ["a","a","b"] ]</code></p><ul><li>思路分析</li></ul><p>先分析一下切割，<strong>其实切割问题类似组合问题</strong>。</p><p>例如对于字符串abcdef：</p><p>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。</p><p>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</p><p>所以切割问题，也可以抽象为一颗树形结构，如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210906171247.jpeg"></p><p>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目链接：https://leetcode-cn.com/problems/palindrome-partitioning/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</span></span><br><span class="line"><span class="comment"> * 返回 s 所有可能的分割方案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例: 输入: "aab" 输出: [ ["aa","b"], ["a","a","b"] ]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivisionPalindrome</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        backtracking(s,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String s, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.length()) {</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; s.length(); i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s,startIndex,i)){ <span class="comment">//如果s的[startIndex,i]之间是回文串，则加入到path中</span></span><br><span class="line">                String str = s.substring(startIndex,i+<span class="number">1</span>);</span><br><span class="line">                path.add(str);</span><br><span class="line"></span><br><span class="line">                backtracking(s,i+<span class="number">1</span>);  <span class="comment">//递归</span></span><br><span class="line"></span><br><span class="line">                path.removeLast(); <span class="comment">//回溯</span></span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span> {       <span class="comment">//如果不是回文串，进行下一次判断</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex,j = endIndex; i &lt; j; i++,j--) {</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String str = <span class="string">"aab"</span>.substring(<span class="number">0</span>,<span class="number">1</span>);  <span class="comment">//substring(begin,end),[begin,end),左闭右开</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(<span class="string">"aab"</span>.substring(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        DivisionPalindrome palindrome = <span class="keyword">new</span> DivisionPalindrome();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; s = palindrome.partition(<span class="string">"aab"</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; strings : s) {</span><br><span class="line">            System.out.println(strings);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-复原IP地址"><a href="#2-复原IP地址" class="headerlink" title="2.复原IP地址"></a>2.复原IP地址</h1><p><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">力扣题目链接</a></p><ul><li>题目</li></ul><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:192.168@1.1">192.168@1.1</a>“ 是 无效的 IP 地址。</p><p>示例 1： 输入：s = “25525511135” 输出：[“255.255.11.135”,”255.255.111.35”]</p><p>示例 2： 输入：s = “0000” 输出：[“0.0.0.0”]</p><p>示例 3： 输入：s = “1111” 输出：[“1.1.1.1”]</p><p>示例 4： 输入：s = “010010” 输出：[“0.10.0.10”,”0.100.1.0”]</p><p>示例 5： 输入：s = “101023” 输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</p><p>提示： 0 &lt;= s.length &lt;= 3000 s 仅由数字组成</p><ul><li>思路分析</li></ul><p>只要意识到这是切割问题，<strong>切割问题就可以使用回溯搜索法把所有可能性搜出来</strong>，和刚做过的<strong>1.分割回文串</strong>就十分类似了。</p><p>切割问题可以抽象为树型结构，如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210906190030.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目地址：https://leetcode-cn.com/problems/restore-ip-addresses/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</span></span><br><span class="line"><span class="comment"> * 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，</span></span><br><span class="line"><span class="comment"> * 但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 5： 输入：s = "101023" 输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestoreIP</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.length() &gt; <span class="number">12</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        backtracking(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String s, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> pointNum)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pointNum == <span class="number">3</span>){  <span class="comment">// 逗点数量为3时，分隔结束</span></span><br><span class="line">            <span class="comment">// 判断第四段⼦字符串是否合法，如果合法就放进result中</span></span><br><span class="line">            <span class="keyword">if</span> (isValid(s,startIndex,s.length()-<span class="number">1</span>)){</span><br><span class="line">                result.add(s);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; s.length(); i++) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果s的[startIndex,i]是合法的整数子串</span></span><br><span class="line">            <span class="keyword">if</span> (isValid(s,startIndex,i)){</span><br><span class="line">                s = s.substring(<span class="number">0</span>,i+<span class="number">1</span>) + <span class="string">"."</span> + s.substring(i+<span class="number">1</span>);</span><br><span class="line">                pointNum++;</span><br><span class="line"></span><br><span class="line">                backtracking(s,i+<span class="number">2</span>,pointNum);  <span class="comment">//递归</span></span><br><span class="line"></span><br><span class="line">                s = s.substring(<span class="number">0</span>,i+<span class="number">1</span>) + s.substring(i+<span class="number">2</span>);</span><br><span class="line">                pointNum--;</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果以0开头，不合法</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) == <span class="string">'0'</span> &amp;&amp; start != end) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= end;i++){</span><br><span class="line">            <span class="comment">//判断每一个数字是否合法</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt; <span class="string">'9'</span> || s.charAt(i) &lt; <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果[start,end]范围内的整数大于255，不合法</span></span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        RestoreIP ip = <span class="keyword">new</span> RestoreIP();</span><br><span class="line">        List&lt;String&gt; strings = ip.restoreIpAddresses(<span class="string">"101023"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : strings){</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-子集问题"><a href="#3-子集问题" class="headerlink" title="3.子集问题"></a>3.子集问题</h1><p><a href="https://leetcode-cn.com/problems/subsets/">力扣题目链接</a></p><ul><li>题目</li></ul><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]</p><ul><li>思路分析</li></ul><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p><p>以示例中nums = [1,2,3]为例把求子集抽象为树型结构，如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210906190638.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目地址：https://leetcode-cn.com/problems/subsets/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span></span><br><span class="line"><span class="comment"> * 说明：解集不能包含重复的子集。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例: 输入: nums = [1,2,3] 输出: [ [3], [1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subsets</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path  = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line"></span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));  <span class="comment">// 收集子集，要放在终止添加的上面，否则会漏掉自己</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) {</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-子集II"><a href="#4-子集II" class="headerlink" title="4.子集II"></a>4.子集II</h1><p><a href="https://leetcode-cn.com/problems/subsets-ii/">力扣题目链接</a></p><ul><li>题目</li></ul><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</p><ul><li>思路分析</li></ul><p>此题和<strong>3.子集问题</strong>很类似，唯一的区别就是，本题需要进行去重操作，因为题目中要求了<strong>解集不能包含重复的子集。</strong></p><p>而<strong>nums数组中可能包含重复元素</strong></p><p>去重关键代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]){ <span class="comment">//去重操作(结果节不能有重复元素，要去重)</span></span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目链接：https://leetcode-cn.com/problems/subsets-ii/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span></span><br><span class="line"><span class="comment"> * 说明：解集不能包含重复的子集。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubsetsNoRepeat</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) {</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">//先给nums数组排序</span></span><br><span class="line"></span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line"></span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path)); <span class="comment">// 收集子集，要放在终止条件的上面，否则会漏掉自己</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.length) <span class="keyword">return</span>;  <span class="comment">//终止条件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]){ <span class="comment">//去重操作(结果节不能有重复元素，要去重)</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            backtracking(nums,i+<span class="number">1</span>); <span class="comment">//递归</span></span><br><span class="line"></span><br><span class="line">            path.removeLast();  <span class="comment">//回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-递增子序列"><a href="#5-递增子序列" class="headerlink" title="5.递增子序列"></a>5.递增子序列</h1><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。</span></span><br><span class="line"><span class="comment"> * 你可以按 任意顺序 返回答案。</span></span><br><span class="line"><span class="comment"> * 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: [4, 6, 7, 7] 输出:</span></span><br><span class="line"><span class="comment"> * [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/increasing-subsequences</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncreasingSubsequences</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备注：</span></span><br><span class="line"><span class="comment">     * 这种写法，输入[4,6,7,7],可以得到想要的输出，</span></span><br><span class="line"><span class="comment">     * 但是不能被LeetCode AC,原因不明</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) {</span><br><span class="line"></span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (path.size() &gt;= <span class="number">2</span>) result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;  <span class="comment">//去重</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] &gt;= nums[i-<span class="number">1</span>]){</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line"></span><br><span class="line">                backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                path.removeLast();</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//break;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        IncreasingSubsequences subsequences = <span class="keyword">new</span> IncreasingSubsequences();</span><br><span class="line">        <span class="keyword">int</span>[] nums = {<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>};</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; subsequences1 = subsequences.findSubsequences(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : subsequences1) {</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-全排列"><a href="#6-全排列" class="headerlink" title="6.全排列"></a>6.全排列</h1><p><a href="https://leetcode-cn.com/problems/permutations/">力扣题目链接</a></p><ul><li>题目</li></ul><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例: 输入: nums = [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</p><ul><li>思路分析</li></ul><p>每一次递归都遍历nums数组，然后将nums[i]加入到<code>List&lt;Integer&gt; path</code>中，继续递归，回溯。</p><p>如果path已经包含了nums[i],就跳过本次循环，进行下一次循环。</p><p>如果path.size() == nums.length，就return.</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个 没有重复 数字的序列，返回其所有可能的全排列。</span></span><br><span class="line"><span class="comment"> * 示例: 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/permutations/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutations</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) {</span><br><span class="line">        backtracking(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == path.size()){</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过判断path中是否存在数字，排除已经选择的数字</span></span><br><span class="line">            <span class="keyword">if</span> (path.contains(nums[i])){</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            backtracking(nums);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="7-全排列-II"><a href="#7-全排列-II" class="headerlink" title="7.全排列 II"></a>7.全排列 II</h1><p><a href="https://leetcode-cn.com/problems/permutations-ii/">力扣题目链接</a></p><ul><li>题目</li></ul><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>示例 1： 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]]</p><p>示例 2： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><ul><li>思路分析</li></ul><p><strong>要强调的是去重一定要对元素经行排序，这样我们才方便通过相邻的节点来判断是否重复使用了</strong>。</p><p>以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210906194935.png"></p><p>图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。</p><p><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1： 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]]</span></span><br><span class="line"><span class="comment"> * 示例 2： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/permutations-ii/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermutationNoRepeat</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) {</span><br><span class="line"></span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        backtracking(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) {</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; used[i-<span class="number">1</span>] == <span class="keyword">false</span>){</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="keyword">false</span>){</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                backtracking(nums);</span><br><span class="line"></span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯刷题笔记①</title>
      <link href="/posts/cac8.html"/>
      <url>/posts/cac8.html</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法简介"><a href="#回溯算法简介" class="headerlink" title="回溯算法简介"></a>回溯算法简介</h1><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><h2 id="回溯算法模板"><a href="#回溯算法模板" class="headerlink" title="回溯算法模板"></a>回溯算法模板</h2><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) {</span><br><span class="line">    if (终止条件) {</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1-组合问题"><a href="#1-组合问题" class="headerlink" title="1.组合问题"></a>1.组合问题</h1><p><a href="https://leetcode-cn.com/problems/combinations/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:<br>输入: n = 4, k = 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><ul><li>思路分析</li></ul><p>把组合问题抽象为如下树形结构：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210903133703.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合问题，返回[1,n]，中所有的k个数的组合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Combine</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) {</span><br><span class="line">        combineHelper(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineHelper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> startIndex)</span></span>{</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k){</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++){  <span class="comment">//剪枝优化</span></span><br><span class="line">            path.add(i);</span><br><span class="line">            combineHelper(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();   <span class="comment">//回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-组合总和III"><a href="#2-组合总和III" class="headerlink" title="2.组合总和III"></a>2.组合总和III</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-iii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]</p><p>示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</p><ul><li>思路分析</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210903134858.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，</span></span><br><span class="line"><span class="comment"> * 并且每种组合中不存在重复的数字。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]</span></span><br><span class="line"><span class="comment"> * 示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) {</span><br><span class="line"></span><br><span class="line">        combination(k,n,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combination</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> targetSum, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k){</span><br><span class="line">            <span class="keyword">if</span> (targetSum == sum){</span><br><span class="line">                result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">//如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; targetSum) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= <span class="number">9</span>-(k-path.size())+<span class="number">1</span>; i++) {</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line"></span><br><span class="line">            combination(k,targetSum,i+<span class="number">1</span>);  <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line"></span><br><span class="line">            path.removeLast(); <span class="comment">//回溯</span></span><br><span class="line">            sum -= i;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-电话号码的字母组合"><a href="#3-电话号码的字母组合" class="headerlink" title="3.电话号码的字母组合"></a>3.电话号码的字母组合</h1><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210903135147.png"></p><p>示例: 输入：”23” 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><p>说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序</p><ul><li>思路分析</li></ul><p>首先定义一个String[]数组，用来做数字和字母的映射</p><p><code>String[] numString = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};</code></p><p>然后从这个数组中取字符串进行组合即可</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210903141836.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationOfPhoneNumber</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//用来储存最终的结果</span></span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();  <span class="comment">//用来储存最终结果的每一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造一个String[],下标对应字符串</span></span><br><span class="line">        String[] numString = {<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>};</span><br><span class="line"></span><br><span class="line">        backtracking(digits,numString,<span class="number">0</span>);<span class="comment">//回溯的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String digits, String[] numString, <span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (num == digits.length()){</span><br><span class="line">            result.add(str.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取digits数字串的第num个数字</span></span><br><span class="line">        <span class="keyword">int</span> index = digits.charAt(num) - <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数字index对应的字符串</span></span><br><span class="line">        String string = numString[index];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string.length(); i++) {</span><br><span class="line">            str.append(string.charAt(i));<span class="comment">//处理</span></span><br><span class="line"></span><br><span class="line">            backtracking(digits,numString,num + <span class="number">1</span>); <span class="comment">//递归，注意num + 1</span></span><br><span class="line"></span><br><span class="line">            str.deleteCharAt(num); <span class="comment">//回溯</span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-组合总和"><a href="#4-组合总和" class="headerlink" title="4.组合总和"></a>4.组合总和</h1><p><a href="https://leetcode-cn.com/problems/combination-sum/">leetcode题目链接</a></p><ul><li>题目</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">所有数字（包括 target）都是正整数。</span><br><span class="line">解集不能包含重复的组合。</span><br><span class="line">示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]</span><br><span class="line"></span><br><span class="line">示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [   [2,2,2,2],   [2,3,3],   [3,5] ]</span><br></pre></td></tr></tbody></table></figure><ul><li>思路分析</li></ul><p>本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。</p><p>本题搜索的过程抽象成树形结构如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210903142615.png"></p><p>注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span></span><br><span class="line"><span class="comment"> * candidates 中的数字可以无限制重复被选取。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [[2,2,2,2],[2,3,3],[3,5]]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/combination-sum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationRepeatedSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="keyword">if</span> (candidates.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (sum == target){</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">continue</span>; <span class="comment">//剪枝优化</span></span><br><span class="line"></span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line"></span><br><span class="line">            backtracking(candidates,target,i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=================</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        CombinationRepeatedSum combination = <span class="keyword">new</span> CombinationRepeatedSum();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] cadidates = {<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>};</span><br><span class="line">        combination.combinationSum(cadidates,<span class="number">8</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-组合总和II"><a href="#5-组合总和II" class="headerlink" title="5.组合总和II"></a>5.组合总和II</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。</p><p>示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</p><p>示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [  [1,2,2],  [5] ]</p><ul><li>思路分析</li></ul><p><strong>本题的难点在于：集合（数组candidates）有重复元素，但还不能有重复的组合</strong>。</p><p>所以就要就行去重操作(首先对数组candidates进行排序，才能有效去重)</p><p>去重代码:</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 要对同一树层使用过的元素进行跳过,是一个去重操作</span><br><span class="line">if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-1]){</span><br><span class="line">    continue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span></span><br><span class="line"><span class="comment"> * candidates 中的每个数字在每个组合中只能使用一次。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为:</span></span><br><span class="line"><span class="comment"> * [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/combination-sum-ii</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationNoRepeatSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) {</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line"></span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum == target){</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) {<span class="comment">//sum + candidates[i] &lt;= target为剪枝操作</span></span><br><span class="line">            <span class="comment">// 要对同一树层使用过的元素进行跳过,是一个去重操作</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>]){</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line"></span><br><span class="line">            backtracking(candidates,target,i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        CombinationNoRepeatSum combination = <span class="keyword">new</span> CombinationNoRepeatSum();</span><br><span class="line">        <span class="keyword">int</span>[] cadidates = {<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>};</span><br><span class="line">        combination.combinationSum2(cadidates,<span class="number">5</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树刷题笔记</title>
      <link href="/posts/9a06.html"/>
      <url>/posts/9a06.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、求二叉搜索树的属性"><a href="#一、求二叉搜索树的属性" class="headerlink" title="一、求二叉搜索树的属性"></a>一、求二叉搜索树的属性</h1><h2 id="1-二叉搜索树的搜索"><a href="#1-二叉搜索树的搜索" class="headerlink" title="1.二叉搜索树的搜索"></a>1.二叉搜索树的搜索</h2><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826191632.png"></p><ul><li>思路分析</li></ul><p>利用二叉搜索树的性质，如果<code>val &lt; root.val </code>就向左遍历，<code>root = root.left</code>,</p><p>如果<code>val &gt;  root.val</code> 就向右遍历，<code>root = root.right,如果val == root.val</code>就返回root节点</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法一：迭代，利用二叉搜索树的特性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST3</span><span class="params">(TreeNode root,<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.val) root = root.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) root = root.right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法二：递归</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST2</span><span class="params">(TreeNode root,<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.val == val) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) <span class="keyword">return</span> searchBST2(root.left,val);</span><br><span class="line">    <span class="keyword">if</span> (val &gt; root.val) <span class="keyword">return</span> searchBST2(root.right,val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h2 id="2-验证二叉搜索树"><a href="#2-验证二叉搜索树" class="headerlink" title="2.验证二叉搜索树"></a>2.验证二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><p>节点的左子树只包含小于当前节点的数。</p><p>节点的右子树只包含大于当前节点的数。</p><p>所有左子树和右子树自身必须也是二叉搜索树。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826192437.png"></p><ul><li>思路分析</li></ul><p>利用中序遍历，遍历二叉搜索树，可以得到一个序列，如果这个序列是严格递增的，</p><p>则该二叉树是二叉搜索树。</p><ul><li><p>代码详情</p><p>提供两个方法：</p><p>方法一：利用中序遍历将二叉搜索树变为一个序列，判断这个序列 是否是升序的 &lt;=&gt; 是否是二叉搜索树</p><p>方法二：利用双指针判断中序遍历时二叉搜索树 是否是严格递增的</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法一：利用中序遍历将二叉搜索树变为一个序列，判断这个序列 是否是升序的 &lt;=&gt; 是否是二叉搜索树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历得到一个序列</span></span><br><span class="line">        infixOrder(root,result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常的BST按照中序遍历可以得到一个升序序列，所以可以以此来判断是不是一个BST</span></span><br><span class="line">        <span class="keyword">int</span> size = result.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="keyword">if</span> (result.get(i) &lt;= result.get(i-<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        infixOrder(root.left,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        infixOrder(root.right,result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**方法二：</span></span><br><span class="line"><span class="comment">     *利用双指针判断中序遍历时二叉搜索树 是否是严格递增的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST2</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        infixOrder2(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">infixOrder2</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        infixOrder2(root.left);  <span class="comment">//左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) {       <span class="comment">//中</span></span><br><span class="line">            <span class="keyword">if</span> (root.val &lt;= pre.val){</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pre = root;</span><br><span class="line">        infixOrder2(root.right);   <span class="comment">//右</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h2 id="3-二叉搜索树的最小绝对差"><a href="#3-二叉搜索树的最小绝对差" class="headerlink" title="3.二叉搜索树的最小绝对差"></a>3.二叉搜索树的最小绝对差</h2><p><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826193252.png"></p><p>提示：树中至少有两个节点</p><ul><li><p>思路分析</p><p>方法一：转为有序数组</p></li></ul><p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p><p><strong>注意是二叉搜索树</strong>，二叉搜索树可是有序的。</p><p>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了</p><p>方法二：双指针法</p><p>需要用一个pre节点记录一下cur节点的前一个节点。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826200513.png"></p><ul><li>代码详情</li></ul><p>方法一：把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p><p>方法二：在中序遍历的过程中，利用双指针，即pre指向cur的前一个，然后做差比较，取最小</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinusTwo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**方法一：</span></span><br><span class="line"><span class="comment">     * 把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        infixOrder(root,result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> size = result.size();</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) {</span><br><span class="line">            temp = result.get(i) - result.get(i-<span class="number">1</span>);</span><br><span class="line">            min = min &lt; temp ? min : temp;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        infixOrder(root.left,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        infixOrder(root.right,result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二：在中序遍历的过程中，利用双指针，即pre指向cur的前一个，然后做差比较，取最小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference2</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode cur)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        traversal(cur.left);<span class="comment">//左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>){ <span class="comment">//中</span></span><br><span class="line">            result = Math.min(result,cur.val - pre.val);</span><br><span class="line">        }</span><br><span class="line">        pre = cur;  <span class="comment">// 记录前一个</span></span><br><span class="line"></span><br><span class="line">        traversal(cur.right);  <span class="comment">//右</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h2 id="4-二叉搜索树中的众数"><a href="#4-二叉搜索树中的众数" class="headerlink" title="4.二叉搜索树中的众数"></a>4.二叉搜索树中的众数</h2><p><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><p>结点左子树中所含结点的值小于等于当前结点的值</p><p>结点右子树中所含结点的值大于等于当前结点的值</p><p>左子树和右子树都是二叉搜索树</p><p>示例：给定 BST [1,null,2,2],</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826200218.png"></p><p>返回[2].</p><p>提示：如果众数超过1个，不需考虑输出顺序</p><ul><li>思路分析</li></ul><p>在<a href="https://mp.weixin.qq.com/s/Hwzml6698uP3qQCC1ctUQQ">二叉树：搜索树的最小绝对差 </a>中我们就使用了pre指针和cur指针的技巧，这次又用上了。</p><p>弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。</p><p>而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。</p><p>代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>) { <span class="comment">// 第一个节点</span></span><br><span class="line">    count = <span class="number">1</span>; <span class="comment">// 频率为1</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) { <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">    count++;</span><br><span class="line">} <span class="keyword">else</span> { <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">pre = cur; <span class="comment">// 更新上一个节点</span></span><br></pre></td></tr></tbody></table></figure><p>那么如何只遍历一遍就取出所有的众数呢？</p><p>如果 <code>频率count 等于 maxCount（最大频率）</code>，当然要把这个元素加入到结果集中（以下代码为result数组），代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count == maxCount) { <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>是不是感觉这里有问题，result怎么能轻易就把元素放进去了呢，万一，这个maxCount此时还不是真正最大频率呢。</p><p>所以下面要做如下操作：</p><p>频率count 大于 maxCount的时候，不仅要更新maxCount，而且要清空结果集（以下代码为result数组），因为结果集之前的元素都失效了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &gt; maxCount) { <span class="comment">// 如果计数大于最大值</span></span><br><span class="line">    maxCount = count;   <span class="comment">// 更新最大频率</span></span><br><span class="line">    result.<span class="built_in">clear</span>();     <span class="comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindModeInBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; resCount;</span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">//用来计数</span></span><br><span class="line">    <span class="keyword">int</span> maxCount;  <span class="comment">//出现的最大次数</span></span><br><span class="line">    TreeNode pre;  <span class="comment">//cur的前一个指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root){</span><br><span class="line">        resCount = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        infix(root);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[resCount.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resCount.size(); i++) {</span><br><span class="line">            res[i] = resCount.get(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">infix</span><span class="params">(TreeNode cur)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        infix(cur.left);  <span class="comment">//左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span>){  <span class="comment">//第一个节点</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (pre.val != cur.val){  <span class="comment">//与前一个节点数值不同</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{   <span class="comment">//与前一个节点数值相同</span></span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == maxCount){ <span class="comment">//如果和出现最多的频率相同</span></span><br><span class="line">            resCount.add(cur.val);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount){</span><br><span class="line">            resCount.clear();  <span class="comment">//将resCount清空</span></span><br><span class="line">            maxCount = count;  <span class="comment">//更新maxCount</span></span><br><span class="line">            resCount.add(cur.val);  <span class="comment">//将节点的值加进去</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pre = cur;  <span class="comment">//更新上一个指针</span></span><br><span class="line"></span><br><span class="line">        infix(cur.right);  <span class="comment">// 右</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h2 id="5-把二叉搜索树转换为累加树"><a href="#5-把二叉搜索树转换为累加树" class="headerlink" title="5.把二叉搜索树转换为累加树"></a>5.把二叉搜索树转换为累加树</h2><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826201645.png"></p><ul><li>思路分析</li></ul><p><strong>其实这就是一棵树，大家可能看起来有点别扭，换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]，是不是感觉这就简单了。</strong></p><p>为什么变成数组就是感觉简单了呢？</p><p>因为数组大家都知道怎么遍历啊，从后向前，挨个累加就完事了，这换成了二叉搜索树，看起来就别扭了一些是不是。</p><p>那么知道如何遍历这个二叉树，也就迎刃而解了，<strong>从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历（按照右 中 左）</strong></p><p><strong>这个二叉树，然后顺序累加就可以了</strong>。</p><ul><li><p>代码详情</p><p>依然使用双指针， 利用<code>cur.val += pre.val</code>,来更新当前节点的值</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），</span></span><br><span class="line"><span class="comment"> * 使每个节点 node的新值等于原树中大于或等于node.val的值之和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTToGreaterSumTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Uninfix(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照右 中 左 的顺序 遍历 累加 ，然后得到一个累加树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Uninfix</span><span class="params">(TreeNode cur)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        Uninfix(cur.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) cur.val += pre.val;</span><br><span class="line">        pre = cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        Uninfix(cur.left);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><hr><h1 id="二、树的公共祖先问题"><a href="#二、树的公共祖先问题" class="headerlink" title="二、树的公共祖先问题"></a>二、树的公共祖先问题</h1><h2 id="1-二叉树的最近公共祖先"><a href="#1-二叉树的最近公共祖先" class="headerlink" title="1.二叉树的最近公共祖先"></a>1.二叉树的最近公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826204338.png"></p><ul><li>思路分析</li></ul><p><a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">二叉树的最近公共祖先</a></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**找二叉树的公共祖先，这题不太好理解，最好是背一下</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosestAncestor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q || root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h2 id="2-二叉搜索树的最近公共祖先"><a href="#2-二叉搜索树的最近公共祖先" class="headerlink" title="2.二叉搜索树的最近公共祖先"></a>2.二叉搜索树的最近公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826205759.png"></p><ul><li>思路分析</li></ul><p>本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。</p><p>在有序树里，如果判断一个节点的左子树里有p，右子树里有q呢？</p><p>其实只要从上到下遍历的时候，cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了。</p><p>理解这一点，本题就很好解了。</p><p>和<a href="https://mp.weixin.qq.com/s/n6Rk3nc_X3TSkhXHrVmBTQ">二叉树：公共祖先问题</a>不同，普通二叉树求最近公共祖先需要使用回溯，从底向上来查找，二叉搜索树就不用了，因为搜索树有序（相当于自带方向），那么只要从上向下遍历就可以了。</p><p>那么我们可以采用前序遍历（其实这里没有中节点的处理逻辑，遍历顺序无所谓了）。</p><p>如图所示：p为节点3，q为节点5</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826210049.png"></p><p>可以看出直接按照指定的方向，就可以找到节点4，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉搜索树的公共祖先</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosestAncestorBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一，递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//root.val的值不在[p,q](假设p.val &lt; q.val),则递归查找</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) {</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) {</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            <span class="comment">//root.val的值在区间内，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法二：迭代法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor2</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) root = root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) root = root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><hr><h1 id="三、二叉搜索树的修改与构造"><a href="#三、二叉搜索树的修改与构造" class="headerlink" title="三、二叉搜索树的修改与构造"></a>三、二叉搜索树的修改与构造</h1><h2 id="1-二叉搜索树中的插入操作"><a href="#1-二叉搜索树中的插入操作" class="headerlink" title="1.二叉搜索树中的插入操作"></a>1.二叉搜索树中的插入操作</h2><p><a href="">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826211128.png"></p><p>提示：</p><p>给定的树上的节点数介于 0 和 10^4 之间</p><p>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</p><p>-10^8 &lt;= val &lt;= 10^8</p><p>新值和原始二叉搜索树中的任意节点值都不同</p><ul><li>思路分析</li></ul><p>利用二叉搜索树的性质，遍历，然后找到空节点插入即可，插入时注意插入的位置(左边还是右边)</p><ul><li><p>代码详情</p><p>提供两种方法，详情看代码以及注释</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。</span></span><br><span class="line"><span class="comment"> * 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/insert-into-a-binary-search-tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertIntoBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**方法一：迭代</span></span><br><span class="line"><span class="comment">     * 利用两个指针，当cur指针为空时，说明找到合适的位置，</span></span><br><span class="line"><span class="comment">     * 如果是val &lt; cur.val 的条件使得cur 指向 cur.left，后为空，则让pre.left = new TreeNode(val);</span></span><br><span class="line"><span class="comment">     * 如果是val &gt; cur.val 的条件使得cur 指向 cur.right，后为空，则让pre.right = new TreeNode(val);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST2</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line"></span><br><span class="line">            pre = cur;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (val &lt; cur.val) {</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">if</span> (cur == <span class="keyword">null</span>) {</span><br><span class="line">                    pre.left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; cur.val) {</span><br><span class="line">                cur = cur.right;</span><br><span class="line">                <span class="keyword">if</span> (cur == <span class="keyword">null</span>) {</span><br><span class="line">                    pre.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二：递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root,<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val) root.right = insertIntoBST(root.right,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val) root.left = insertIntoBST(root.left,val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h2 id="2-删除二叉搜索树中的节点"><a href="#2-删除二叉搜索树中的节点" class="headerlink" title="2.删除二叉搜索树中的节点"></a>2.删除二叉搜索树中的节点</h2><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p><p>示例:</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826220440.png"></p><ul><li>思路分析</li></ul><p><a href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">删除二叉搜索树中的节点</a></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteNodeInBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//没找到要删除的节点，直接返回null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val == val){</span><br><span class="line">            <span class="comment">//第一种情况，root节点的左右孩子都为空，说明要删除的是叶子节点，直接返回null</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第二种情况，左孩子为空，返回右孩子</span></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第三种情况，右孩子为空，返回左孩子</span></span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第四种情况，左右孩子都不为空，把，左孩子添加到以右孩子为头节点的树的最左边</span></span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                TreeNode cur = root.right;</span><br><span class="line">                <span class="keyword">while</span> (cur.left != <span class="keyword">null</span>){ <span class="comment">//一直往左遍历，找到root节点的右孩子的最左边</span></span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                }</span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里相当于把新的节点返回给上一层，上一层就要用 root-&gt;left 或者 root-&gt;right接住</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.val) root.left = deleteNode(root.left,val);</span><br><span class="line">        <span class="keyword">if</span> (val &gt; root.val) root.right = deleteNode(root.right,val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h2 id="3-修剪二叉搜索树"><a href="#3-修剪二叉搜索树" class="headerlink" title="3.修剪二叉搜索树"></a>3.修剪二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826221920.png"></p><ul><li>思路分析</li></ul><p><a href="https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">修剪二叉搜索树</a></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**这题不太好理解，最好是背住代码！！！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目：</span></span><br><span class="line"><span class="comment"> * 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，</span></span><br><span class="line"><span class="comment"> * 使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构</span></span><br><span class="line"><span class="comment"> * （即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。</span></span><br><span class="line"><span class="comment"> * 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/trim-a-binary-search-tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrimBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low){ <span class="comment">// 寻找符合区间[low, high]的节点</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high){  <span class="comment">// 寻找符合区间[low, high]的节点</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码走到这里，说明root.val的值，在[low,high]区间内</span></span><br><span class="line">        root.left = trimBST(root.left,low,high);  <span class="comment">// root-&gt;left接入符合条件的左孩子</span></span><br><span class="line">        root.right = trimBST(root.right,low,high);  <span class="comment">// root-&gt;right接入符合条件的右孩子</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl给大家大体分分类</strong>。</p><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序， <a href="https://mp.weixin.qq.com/s/Osw4LQD2xVUnCJ-9jrYxJA">二叉树：找所有路径</a>也用了前序，这是为了方便让父节点指向子节点。</p><p>所以求普通二叉树的属性还是要具体问题具体分析。</p><br><p>参考：以上题目解答来自：<a href="https://programmercarl.com/">代码随想录</a>，感谢carl哥！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树刷题笔记②</title>
      <link href="/posts/abcb.html"/>
      <url>/posts/abcb.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-左叶子之和"><a href="#1-左叶子之和" class="headerlink" title="1.左叶子之和"></a>1.左叶子之和</h1><p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>计算给定二叉树的所有左叶子之和。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210824134426.png"></p><ul><li>思路分析</li></ul><p><strong>首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。</strong></p><p>因为题目中其实没有说清楚左叶子究竟是什么节点，那么我来给出左叶子的明确定义：<strong>如果左节点不为空，且左节点没有左右孩子，那么这个节点就是左叶子</strong></p><p>如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>){</span><br><span class="line">          <span class="comment">//处理逻辑</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码实现</li></ul><p>分别使用递归法和迭代法实现</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算给定二叉树的所有左叶子之和。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumOfLeftLeaves</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法求二叉树的所有左叶子节点之和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//递归终止条件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左叶子节点的条件</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>){</span><br><span class="line">            mid = root.left.val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归root节点的左子树和右子树</span></span><br><span class="line">        <span class="keyword">int</span> left = sumOfLeftLeaves(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = sumOfLeftLeaves(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把所有找到的左叶子节点求和</span></span><br><span class="line">        <span class="keyword">int</span> sum = mid + left + right;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代法，使用栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves2</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="comment">//左叶子节点的条件</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>){</span><br><span class="line">                sum += root.left.val;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-找树左下角的值"><a href="#2-找树左下角的值" class="headerlink" title="2.找树左下角的值"></a>2.找树左下角的值</h1><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/v">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉树，在树的最后一行找到最左边的值。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210824135011.png"></p><ul><li>思路分析</li></ul><p>直接利用层序遍历，找到每一层最左边的节点即可</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BottomLeftValue</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) result = cur.val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-最大二叉树"><a href="#3-最大二叉树" class="headerlink" title="3.最大二叉树"></a>3.最大二叉树</h1><p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><p>  二叉树的根是数组中的最大元素。</p><p>  左子树是通过数组中最大值左边部分构造出的最大二叉树。</p><p>  右子树是通过数组中最大值右边部分构造出的最大二叉树。</p><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p>示例 ：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210824142814.png"></p><ul><li><p>思路分析</p><p>最大二叉树的构建过程如下：</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjuvioezg30dw0921ck.gif"></p><p>构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructMaximumBinaryTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> traversal(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">traversal</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{ <span class="comment">//递归的参数和返回值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分割点下标,因为下面比较要用到，所以要赋初始值</span></span><br><span class="line">        <span class="keyword">int</span> maxValueIndex = left;</span><br><span class="line">        <span class="comment">//寻找分割点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[maxValueIndex]) maxValueIndex = i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[maxValueIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左闭右开：[left, maxValueIndex)</span></span><br><span class="line">        root.left = traversal(nums,left,maxValueIndex);</span><br><span class="line">        <span class="comment">// 左闭右开：[maxValueIndex + 1, right)</span></span><br><span class="line">        root.right = traversal(nums,maxValueIndex+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-将有序数组转为二叉搜索树"><a href="#4-将有序数组转为二叉搜索树" class="headerlink" title="4.将有序数组转为二叉搜索树"></a>4.将有序数组转为二叉搜索树</h1><p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826170344.png"></p><ul><li>思路分析</li></ul><p>如果根据数组构造一颗二叉树。</p><p><strong>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong>。</p><p>本题其实要比<strong>第三题 ：最大二叉树</strong>简单一些，因为有序数组构造二叉搜索树，寻找分割点就比较容易了。</p><p>分割点就是数组中间位置的节点。</p><p>那么为问题来了，如果数组长度为偶数，中间节点有两个，取哪一个？</p><p>取哪一个都可以，只不过构成了不同的平衡二叉搜索树。</p><p>例如：输入：[-10,-3,0,5,9]</p><p>如下两棵树，都是这个数组的平衡二叉搜索树：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826173343.png"></p><p>如果要分割的数组长度为偶数的时候，中间元素为两个，是取左边元素 就是树1，取右边元素就是树2。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**题目：</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</span></span><br><span class="line"><span class="comment"> * 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题可以不用考虑是不是高度平衡的</span></span><br><span class="line"><span class="comment"> * 另外，此题和 最大二叉树 有点类似</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最大二叉树题目：</span></span><br><span class="line"><span class="comment"> * 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</span></span><br><span class="line"><span class="comment"> * 二叉树的根是数组中的最大元素。</span></span><br><span class="line"><span class="comment"> * 左子树是通过数组中最大值左边部分构造出的最大二叉树。</span></span><br><span class="line"><span class="comment"> * 右子树是通过数组中最大值右边部分构造出的最大二叉树。</span></span><br><span class="line"><span class="comment"> * 通过给定的数组构建最大二叉树，并且输出这个树的根节点。</span></span><br><span class="line"><span class="comment"> * 题目地址：https://leetcode-cn.com/problems/maximum-binary-tree/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertSortedArrayToBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = traversal(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">traversal</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左闭右闭</span></span><br><span class="line">        root.left = traversal(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = traversal(nums,mid+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-合并二叉树"><a href="#5-合并二叉树" class="headerlink" title="5.合并二叉树"></a>5.合并二叉树</h1><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826165331.png"></p></li></ul><ul><li>思路分析</li></ul><p>以Tree1为要返回的树，如果对应的节点中，有其中一个为空，就返回另一个，如果两个都不为空，则把节点的值相加</p><p>然后递归两棵树对应的左孩子和右孩子，最后返回Tree1的头节点</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeTrees</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>{</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">       <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">       root1.val += root2.val;</span><br><span class="line"></span><br><span class="line">       root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">       root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> root1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>1.前序、中序和后序遍历考虑使用栈</li><li>2.层序遍历考虑使用队列</li><li>3.其它情况先考虑队列，再考虑使用栈</li></ul><br><p>参考：<a href="https://programmercarl.com/">代码随想录</a>，感谢carl哥！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树刷题笔记①</title>
      <link href="/posts/6b0a.html"/>
      <url>/posts/6b0a.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-反转二叉树"><a href="#1-反转二叉树" class="headerlink" title="1.反转二叉树"></a>1.反转二叉树</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>反转一颗二叉树</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823095807.png"></p><ul><li><p>代码详情</p><p>1.DFS递归，可以使用前序和后序遍历，交换当前节点的左右孩子</p><p>2.BFS，利用层序遍历，交换当前节点的左右孩子</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvertBinaryTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**DFS递归</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不行，</span></span><br><span class="line"><span class="comment">     * 因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        invert(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invert</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        TreeNode temp = <span class="keyword">null</span>;</span><br><span class="line">        temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        invert(root.left);</span><br><span class="line">        invert(root.right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**BFS层序遍历</span></span><br><span class="line"><span class="comment">     *利用层序遍历，交换当前节点的左右孩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTreeBFS</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换当前层的节点的左右孩子</span></span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                temp = cur.left;</span><br><span class="line">                cur.left = cur.right;</span><br><span class="line">                cur.right = temp;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-对称二叉树"><a href="#2-对称二叉树" class="headerlink" title="2.对称二叉树"></a>2.对称二叉树</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/">leetcode题目链接</a></p><ul><li>题目:给定一个二叉树，检查它是否是镜像对称的。</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823100057.png"></p><h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><ul><li>思路分析</li></ul><p><strong>首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！</strong></p><p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>其实我们要比较的是两个树（这两个树是根节点的左右子树）</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。</p><p>那么如果比较呢？</p><p>比较的是两个子树的里侧和外侧的元素是否相等。如图所示：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823100721.png"></p><p>那么遍历的顺序应该是什么样的呢？</p><p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p><p><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p><p>但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方法一：递归法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">   }</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(TreeNode left, TreeNode right)</span> </span>{</span><br><span class="line"></span><br><span class="line">       <span class="comment">//首先判断节点为空的情况</span></span><br><span class="line">       <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">       <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">       <span class="keyword">boolean</span> outside = compare(left.left,right.right); <span class="comment">// 比较左节点的左孩子 和 右节点的右孩子</span></span><br><span class="line">       <span class="keyword">boolean</span> inside = compare(left.right,right.left); <span class="comment">// 比较左节点的右孩子 和 右节点的左孩子</span></span><br><span class="line">       <span class="keyword">boolean</span> isSame = outside &amp;&amp; inside;   <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">       <span class="keyword">return</span> isSame;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h2 id="方法二：迭代法"><a href="#方法二：迭代法" class="headerlink" title="方法二：迭代法"></a>方法二：迭代法</h2><ul><li><p>思路分析</p><p>通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif"></p></li><li><p>代码详情</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二：迭代法(使用一个队列实现)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric2</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root.left); <span class="comment">// 将左子树头结点加入队列</span></span><br><span class="line">        queue.offer(root.right); <span class="comment">// 将右子树头结点加入队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){ <span class="comment">// 接下来就要判断这这两个树是否相互翻转</span></span><br><span class="line">            TreeNode leftNode = queue.poll();</span><br><span class="line">            TreeNode rightNode = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> &amp;&amp; rightNode == <span class="keyword">null</span>){ <span class="comment">// 左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> || rightNode == <span class="keyword">null</span> || leftNode.val != rightNode.val){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            queue.offer(leftNode.left);   <span class="comment">// 加入左节点左孩子</span></span><br><span class="line">            queue.offer(rightNode.right); <span class="comment">// 加入右节点右孩子</span></span><br><span class="line">            queue.offer(leftNode.right);  <span class="comment">// 加入左节点右孩子</span></span><br><span class="line">            queue.offer(rightNode.left);  <span class="comment">// 加入右节点左孩子</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-完全二叉树的节点个数"><a href="#3-完全二叉树的节点个数" class="headerlink" title="3.完全二叉树的节点个数"></a>3.完全二叉树的节点个数</h1><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给出一个完全二叉树，求出该树的节点个数。</p></li></ul><h2 id="方法一：层序遍历"><a href="#方法一：层序遍历" class="headerlink" title="方法一：层序遍历"></a>方法一：层序遍历</h2><ul><li><p>思路分析</p><p>遍历模板稍稍修改一下，记录遍历的节点数量就可以了。</p></li><li><p>代码详情</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**方法一</span></span><br><span class="line"><span class="comment">    * 利用层序遍历的模板，统计二叉树的节点个数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">//LinkedList可以作为Queue的实现类</span></span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.offer(root);   <span class="comment">//将根节点加入队列</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">           <span class="keyword">int</span> size = queue.size(); <span class="comment">//取出当前队列的大小</span></span><br><span class="line"></span><br><span class="line">           TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//将队列中的元素依次取出，然后让其左右子树(如果不为空的话)入队列</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">               count++;   <span class="comment">//记录当前二叉树的节点个数</span></span><br><span class="line">               cur = queue.poll();</span><br><span class="line">               <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">               <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h2 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h2><ul><li>思路分析</li></ul><p>1.确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getNodesNum(TreeNode root) { }</span><br></pre></td></tr></tbody></table></figure><p>2.确定终止条件：如果为空节点的话，就返回0，表示节点数为0。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (root == null) return 0;   </span><br></pre></td></tr></tbody></table></figure><p>3.确定单层递归的逻辑：先求它的左子树的节点数量，再求的右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int leftNum = getNodesNum(root.left);  //左</span><br><span class="line">int rightNum = getNodesNum(root.right);  //右</span><br><span class="line">int treeNum = leftNum + rightNum + 1;  //中</span><br><span class="line">return treeNum;</span><br></pre></td></tr></tbody></table></figure><p>java整体代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**方法二</span></span><br><span class="line"><span class="comment">     * 利用递归统计二叉树的节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNode</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> getNodesNum(root);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNodesNum</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftNum = getNodesNum(root.left);  <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">int</span> rightNum = getNodesNum(root.right);  <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">int</span> treeNum = leftNum + rightNum + <span class="number">1</span>;  <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">return</span> treeNum;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h1 id="4-平衡二叉树"><a href="#4-平衡二叉树" class="headerlink" title="4.平衡二叉树"></a>4.平衡二叉树</h1><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823103347.png" alt="image-20210823103345548"></p><ul><li>二叉树的高度与深度</li></ul><p>​      二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</p><p>​      二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823103756.png"></p><ul><li>代码详情</li></ul><p>下面的方法通过层序遍历获得当前节点距离叶子节点的高度</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法可以获取当前root节点距离叶子节点的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">levelOrder</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> high = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            TreeNode cur;</span><br><span class="line">            high++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>然后再用栈来模拟前序遍历，遍历每一个节点的时候，再去判断左右孩子的高度是否符合，代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**:迭代法，使用层序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 用栈来模拟前序遍历，遍历每一个节点的时候，</span></span><br><span class="line"><span class="comment">     * 再去判断左右孩子的高度是否符合，代码如下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line">            cur = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(levelOrder(cur.left) - levelOrder(cur.right)) &gt; <span class="number">1</span>){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) stack.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) stack.push(cur.right);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h1 id="5-二叉树的所有路径"><a href="#5-二叉树的所有路径" class="headerlink" title="5. 二叉树的所有路径"></a>5. 二叉树的所有路径</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-paths/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823110448.png"></p><ul><li>思路分析</li></ul><p>这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。</p><p>在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。</p><p>前序遍历以及回溯的过程如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823111217.png"></p><p>我们先使用递归的方式，来做前序遍历。<strong>要知道递归和回溯就是一家的，本题也需要回溯。</strong></p><ul><li>递归三部曲</li></ul><p>1.递归函数函数参数以及返回值</p><p>要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, LinkedList&lt;Integer&gt; path, List&lt;String&gt; result)</span></span></span><br></pre></td></tr></tbody></table></figure><p>2.递归终止条件</p><p>当 root不为空，其左右孩子都为空的时候，就找到叶子节点。</p><p>所以本题的终止条件是：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历到了叶子节点</span></span><br><span class="line"><span class="comment">//将path保存的节点值，全部转为字符串sPath,这样就得到了路径，最后放入result集合中</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">int</span> size = path.size();</span><br><span class="line">            String sPath = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) {</span><br><span class="line">                sPath += path.get(i);</span><br><span class="line">                sPath += <span class="string">"-&gt;"</span>;</span><br><span class="line">            }</span><br><span class="line">            sPath += path.get(size - <span class="number">1</span>);   <span class="comment">//这里记录最后一个节点(叶子节点)，因为输出格式需要</span></span><br><span class="line">            result.add(sPath);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><p>if花括号里面的是，终止的处理逻辑</p><p>3.单层递归逻辑</p><p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.add(root.val);  <span class="comment">//将当前节点值加入到path集合中</span></span><br></pre></td></tr></tbody></table></figure><p>然后是递归和回溯的过程，上面说过没有判断root是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了(所以说能进递归函数的root节点一定是不为空的)。</p><p>所以递归前要加上判断语句，下面要递归的节点是否为空，如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="keyword">null</span>){</span><br><span class="line">    traversal(root.left,path,result); <span class="comment">//递归</span></span><br><span class="line">    path.removeLast();  <span class="comment">//回溯</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root.right != <span class="keyword">null</span>){</span><br><span class="line">    traversal(root.right,path,result); <span class="comment">//递归</span></span><br><span class="line">    path.removeLast();  <span class="comment">//回溯</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>整体代码</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.colorfor.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathsOfTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">treePaths</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//result集合作为最后的结果</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//path集合保存递归过程中的节点的值</span></span><br><span class="line">        traversal(root,path,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, LinkedList&lt;Integer&gt; path, List&lt;String&gt; result)</span> </span>{</span><br><span class="line">        path.add(root.val);  <span class="comment">//将当前节点值加入到path集合中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历到了叶子节点</span></span><br><span class="line">        <span class="comment">//将path保存的节点值，全部转为字符串sPath,这样就得到了路径，最后放入result集合中</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">int</span> size = path.size();</span><br><span class="line">            String sPath = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) {</span><br><span class="line">                sPath += path.get(i);</span><br><span class="line">                sPath += <span class="string">"-&gt;"</span>;</span><br><span class="line">            }</span><br><span class="line">            sPath += path.get(size - <span class="number">1</span>);</span><br><span class="line">            result.add(sPath);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>){</span><br><span class="line">            traversal(root.left,path,result); <span class="comment">//递归</span></span><br><span class="line">            path.removeLast();  <span class="comment">//回溯</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>){</span><br><span class="line">            traversal(root.right,path,result); <span class="comment">//递归</span></span><br><span class="line">            path.removeLast();  <span class="comment">//回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-----------main----------------</span></span><br><span class="line">   <span class="comment">/* public static void main(String[] args) {</span></span><br><span class="line"><span class="comment">        PathsOfTree tree = new PathsOfTree();</span></span><br><span class="line"><span class="comment">        TreeNode root = new TreeNode(1);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        TreeNode node2 = new TreeNode(2);</span></span><br><span class="line"><span class="comment">        TreeNode node3 = new TreeNode(3);</span></span><br><span class="line"><span class="comment">        root.left = node2;</span></span><br><span class="line"><span class="comment">        root.right = node3;</span></span><br><span class="line"><span class="comment">        node2.left = new TreeNode(4);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        List&lt;String&gt; strings = tree.treePaths(root);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for (String string : strings) {</span></span><br><span class="line"><span class="comment">            System.out.println(string);</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-路径总和"><a href="#6-路径总和" class="headerlink" title="6.路径总和"></a>6.路径总和</h1><p><a href="https://leetcode-cn.com/problems/path-sum/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例: 给定如下二叉树，以及目标和 sum = 22，</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210824140342.png"></p><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><ul><li>代码详情</li></ul><p>此题可在第5题代码的基础上稍加修改得到</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root,<span class="keyword">int</span> targetSum)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        traversal(root,path,result,targetSum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.contains(targetSum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, LinkedList&lt;Integer&gt; path, List&lt;Integer&gt; result,<span class="keyword">int</span> targetSum)</span> </span>{</span><br><span class="line">        path.add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">int</span> size = path.size();</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                sum += path.get(i);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            result.add(sum);</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) {</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>){</span><br><span class="line">            traversal(root.left,path,result,targetSum);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>){</span><br><span class="line">            traversal(root.right,path,result,targetSum);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-----------main----------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        PathSum tree = <span class="keyword">new</span> PathSum();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode node2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        TreeNode node3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.left = node2;</span><br><span class="line">        root.right = node3;</span><br><span class="line">        node2.left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b = tree.hasPathSum(root, <span class="number">4</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的层序遍历</title>
      <link href="/posts/bd66.html"/>
      <url>/posts/bd66.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-二叉树的层序遍历"><a href="#1-二叉树的层序遍历" class="headerlink" title="1.二叉树的层序遍历"></a>1.二叉树的层序遍历</h1><ul><li><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">leetcode题目链接</a></p></li><li><p>题目</p><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）</p></li></ul><p> <img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821202052.png"></p><ul><li><p>思路分析</p><p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif"></p></li><li><p>代码详情</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode {</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode left;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) {</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的层序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LevelOrder</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回层序遍历的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root){</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LinkedList可以作为Queue的实现类</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);   <span class="comment">//将根节点加入队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size(); <span class="comment">//取出当前队列的大小</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将队列中的元素依次取出，然后让其左右子树(如果不为空的话)入队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将每层遍历的结果放入result集合中</span></span><br><span class="line">            result.add(list);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>这份代码也可以作为二叉树层序遍历的模板</strong>,十分重要，一定要会</p><br><h1 id="2-二叉树的层次遍历-II"><a href="#2-二叉树的层次遍历-II" class="headerlink" title="2.二叉树的层次遍历 II"></a>2.二叉树的层次遍历 II</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p></li><li><p>代码详情</p><p>此题跟第一题差不多，可以使用<code>Collections.reverse()方法</code>，或者使用栈把第一题的结果反转一下即可，</p><p>直接给出代码</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，自底向上输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LevelOrder2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回层序遍历的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root){</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;List&lt;Integer&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LinkedList可以作为Queue的实现类</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);   <span class="comment">//将根节点加入队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size(); <span class="comment">//取出当前队列的大小</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将队列中的元素依次取出，然后让其左右子树(如果不为空的话)入队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将每层遍历的结果先放入stack</span></span><br><span class="line">            stack.push(list);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将栈中保存的每层的遍历结果，依次弹出，然后加入到result集合中</span></span><br><span class="line">        <span class="comment">//这样就实现了二叉树自底向上的层序遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line">            result.add(stack.pop());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-二叉树的右视图"><a href="#3-二叉树的右视图" class="headerlink" title="3.二叉树的右视图"></a>3.二叉树的右视图</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821203044.png"></p></li><li><p>思路分析</p></li></ul><p>层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树的 根节点 root，想象自己站在它的右侧，</span></span><br><span class="line"><span class="comment"> * 按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightSideView</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回层序遍历的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">levelOrder</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LinkedList可以作为Queue的实现类</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);   <span class="comment">//将根节点加入队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size(); <span class="comment">//取出当前队列的大小</span></span><br><span class="line">            LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将队列中的头元素取出，然后让其左右子树(如果不为空的话)入队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果是最后一个，就加入result集合</span></span><br><span class="line">                <span class="keyword">if</span> (i == size-<span class="number">1</span>) result.add(cur.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-二叉树的层平均值"><a href="#4-二叉树的层平均值" class="headerlink" title="4.二叉树的层平均值"></a>4.二叉树的层平均值</h1><p><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821203549.png"></p></li></ul><ul><li><p>代码详情</p><p>本题就是层序遍历的时候把一层求个总和在取一个均值。</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AverageOfLevels</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        List&lt;Double&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);  <span class="comment">//根节点入队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> size = queue.size(); <span class="comment">// 获取队列的大小</span></span><br><span class="line">            <span class="keyword">double</span> average = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                sum = sum + cur.val; <span class="comment">// sum累加，把每层的节点值相加</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == size-<span class="number">1</span>){ <span class="comment">// 遇到每层的最后一个节点，求该层的平均值</span></span><br><span class="line">                    average = sum / size;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">//让左右子树(如果不为空的话)入队列</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line">            result.add(average);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-N叉树的层序遍历"><a href="#5-N叉树的层序遍历" class="headerlink" title="5.N叉树的层序遍历"></a>5.N叉树的层序遍历</h1><p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。</p><p>例如，给定一个 3叉树 :</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821203829.png"></p></li></ul><p>返回其层序遍历:</p><p>[ [1], [3,2,4], [5,6] ]</p><ul><li>代码详情</li></ul><p>这道题依旧是模板题，只不过一个节点有多个孩子了</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*public class Node {</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">}*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NTreeLevelOrder</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root){</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);  <span class="comment">//将根节点加入队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            Node cur = <span class="keyword">null</span>;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">//队列的头节点出队列，并将节点的值加入该层list集合</span></span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果该节点的子节点不为空，则全部加入队列中</span></span><br><span class="line">                <span class="keyword">if</span> (cur.children != <span class="keyword">null</span>){</span><br><span class="line">                    List&lt;Node&gt; children = cur.children;</span><br><span class="line">                    <span class="keyword">int</span> len = children.size();</span><br><span class="line">                    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (index &lt; len){</span><br><span class="line">                        queue.offer(children.get(index++));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将当前层的节点值集合list加入到result集合中</span></span><br><span class="line">            result.add(list);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-在每个树行中找最大值"><a href="#6-在每个树行中找最大值" class="headerlink" title="6.在每个树行中找最大值"></a>6.在每个树行中找最大值</h1><p><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">leetcode题目链接</a></p><ul><li><p>题目</p><p>您需要在二叉树的每一行中找到最大的值。</p></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821204715.png"></p><ul><li>代码详情</li></ul><p>层序遍历，取每一层的最大值</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindLargestInTreeRow</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestValues</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);  <span class="comment">//将根节点加入到队列中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> maxRow = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将遍历当前层的节点，找出最大值，保存在maxRow中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                temp = cur.val;</span><br><span class="line">                maxRow = temp &gt; maxRow  ? temp : maxRow;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前节点的左右子树不为空，则加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            result.add(maxRow);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="7-填充每个节点的下一个右侧节点指针"><a href="#7-填充每个节点的下一个右侧节点指针" class="headerlink" title="7.填充每个节点的下一个右侧节点指针"></a>7.填充每个节点的下一个右侧节点指针</h1><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() {}</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p><img src="https://img-blog.csdnimg.cn/20210203152044855.jpg"></p></li></ul><ul><li>思路分析</li></ul><p>本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，</p><p>然后在遍历的时候让当前节点的next域指向下一个节点（next）就可以了</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。</span></span><br><span class="line"><span class="comment"> * 如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextConnectRight</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);  <span class="comment">//将根节点加入队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = queue.size(); <span class="comment">//获取队列的大小</span></span><br><span class="line"></span><br><span class="line">            Node cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!queue.isEmpty()){</span><br><span class="line">                cur = queue.poll();   <span class="comment">//使用cur指针，指向本层的第一个节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前节点的左右子节点不为空，将左右子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Node next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) { <span class="comment">//由于本层的第一个节点已经出队列，所以i从1开始</span></span><br><span class="line">                next = queue.poll();     <span class="comment">//让cur右边的节点出队列</span></span><br><span class="line">                cur.next = next;      <span class="comment">//cur的next域指向cur右边的节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前节点的左右子节点不为空，将左右子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (next.left != <span class="keyword">null</span>) queue.offer(next.left);</span><br><span class="line">                <span class="keyword">if</span> (next.right != <span class="keyword">null</span>) queue.offer(next.right);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//让cur往右边移动一位，为下一次循环做准备</span></span><br><span class="line">                cur = next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关联题目:<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">填充每个节点的下一个右侧节点指针II</a></p><br><h1 id="8-二叉树的最大深度"><a href="#8-二叉树的最大深度" class="headerlink" title="8.二叉树的最大深度"></a>8.二叉树的最大深度</h1><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821210453.png"></p><p>返回它的最大深度 3 。</p><ul><li>代码详情</li></ul><p>本题依旧使用层序遍历，每遍历一层，二叉树的深度就加1</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxDepthOfTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line"></span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            depth++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="9-二叉树的最小深度"><a href="#9-二叉树的最小深度" class="headerlink" title="9.二叉树的最小深度"></a>9.二叉树的最小深度</h1><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821211016.png" alt="image-20210821211015337"></p></li><li><p>代码详情</p></li></ul><p>相对于 104.二叉树的最大深度 ，本题还也可以使用层序遍历的方式来解决，思路是一样的。</p><p><strong>需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDepthOfTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            depth++;</span><br><span class="line"></span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前节点的左右孩子都为空，直接返回最小深度</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>){</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>以上题目参考:<a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">代码随想录</a></p><p>感谢哈工大师兄Carl！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 层序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用递归和非递归的方式实现二叉树的遍历</title>
      <link href="/posts/a2eb.html"/>
      <url>/posts/a2eb.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-用递归的方式实现二叉树的前序、中序和后序遍历"><a href="#1-用递归的方式实现二叉树的前序、中序和后序遍历" class="headerlink" title="1.用递归的方式实现二叉树的前序、中序和后序遍历"></a>1.用递归的方式实现二叉树的前序、中序和后序遍历</h1><ul><li>递归三要素</li></ul><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TreeNode节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"前序遍历二叉树(递归)"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中 左 右</span></span><br><span class="line">        System.out.println(root.val);</span><br><span class="line"></span><br><span class="line">        preOrderRecur(root.left);</span><br><span class="line"></span><br><span class="line">        preOrderRecur(root.right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历二叉树，递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderRecur</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前 中 右</span></span><br><span class="line">        inOrderRecur(root.left);</span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">        inOrderRecur(root.right);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历二叉树，递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderRecur</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左 右 中</span></span><br><span class="line">        postOrderRecur(root.left);</span><br><span class="line">        postOrderRecur(root.right);</span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br><h1 id="2-用非递归的方式实现二叉树的前序、中序和后序遍历"><a href="#2-用非递归的方式实现二叉树的前序、中序和后序遍历" class="headerlink" title="2.用非递归的方式实现二叉树的前序、中序和后序遍历"></a>2.用非递归的方式实现二叉树的前序、中序和后序遍历</h1><h2 id="2-1前序遍历"><a href="#2-1前序遍历" class="headerlink" title="2.1前序遍历"></a>2.1前序遍历</h2><ul><li><p>思路分析</p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif"></p></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**前序遍历，非递归</span></span><br><span class="line"><span class="comment">     *  * 思路分析:</span></span><br><span class="line"><span class="comment">     *  * 1.申请一个新的栈，即为stack,然后将root节点压入栈中</span></span><br><span class="line"><span class="comment">     *  *</span></span><br><span class="line"><span class="comment">     *  * 2.从stack中弹出栈顶节点，记为root,然后将root节点的值放入result集合，</span></span><br><span class="line"><span class="comment">     *  *     再将root节点的右子节点(不为空的话)先压入栈中，</span></span><br><span class="line"><span class="comment">     *  *      最后将root节点的左子节点(不为空的话)压入栈中</span></span><br><span class="line"><span class="comment">     *  *</span></span><br><span class="line"><span class="comment">     *  * 3.不断重复步骤2,直到stack为空，全部过程结束</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrderUnRecur</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//如果根节点不为空，将其压入栈中</span></span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            stack.push(root);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line">                <span class="comment">//从栈中弹出栈顶元素，并打印其节点的值</span></span><br><span class="line">                root = stack.pop();</span><br><span class="line">                result.add(root.val);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前节点的右子节点不为空，将右子节点压入栈中</span></span><br><span class="line">                <span class="keyword">if</span> (root.right != <span class="keyword">null</span>){</span><br><span class="line">                    stack.push(root.right);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前节点的左子节点不为空，将左子节点压入栈中</span></span><br><span class="line">                <span class="keyword">if</span> (root.left != <span class="keyword">null</span>){</span><br><span class="line">                    stack.push(root.left);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2中序遍历"><a href="#2-2中序遍历" class="headerlink" title="2.2中序遍历"></a>2.2中序遍历</h2><ul><li>思路分析</li></ul><p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif"></p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**中序遍历二叉树(非递归)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 思路分析：</span></span><br><span class="line"><span class="comment">     * 1.中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，</span></span><br><span class="line"><span class="comment">     * 直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result集合中），</span></span><br><span class="line"><span class="comment">     * 这就造成了处理顺序和访问顺序是不一致的。</span></span><br><span class="line"><span class="comment">     * 2.在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个list集合，保存中序遍历的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inOrderUnRecur</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()){</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>){ <span class="comment">//指针来访问节点，访问到最底层</span></span><br><span class="line">                stack.push(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur.left;  <span class="comment">//左</span></span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                cur = stack.pop();  <span class="comment">//从栈里面弹出的数据就是要处理的数据</span></span><br><span class="line">                result.add(cur.val);  <span class="comment">//放进result集合中</span></span><br><span class="line">                cur = cur.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-后序遍历"><a href="#2-3-后序遍历" class="headerlink" title="2.3 后序遍历"></a>2.3 后序遍历</h2><ul><li>思路分析</li></ul><p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200808200338924.png"></p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**后序遍历二叉树(非递归)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 思路分析:</span></span><br><span class="line"><span class="comment">    * 先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，</span></span><br><span class="line"><span class="comment">    * 就变成中右左的遍历顺序，然后在反转result集合，输出的结果顺序就是左右中了</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回一个list集合，保存中序遍历的结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postOrderUnRecur</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line"></span><br><span class="line">       List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       stack.push(root);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line">           root = stack.pop();</span><br><span class="line">           result.add(root.val);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (root.left != <span class="keyword">null</span>){</span><br><span class="line">               stack.push(root.left);</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (root.right != <span class="keyword">null</span>){</span><br><span class="line">               stack.push(root.right);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       Collections.reverse(result);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>参考：<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树的遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法匹配字符串</title>
      <link href="/posts/c86b.html"/>
      <url>/posts/c86b.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、KMP算法匹配字符串"><a href="#一、KMP算法匹配字符串" class="headerlink" title="一、KMP算法匹配字符串"></a>一、KMP算法匹配字符串</h2><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p><a href="https://leetcode-cn.com/problems/implement-strstr/">leetcode-链接</a></p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = <span class="string">"aabaabaaf"</span>, needle = <span class="string">"aabaaf"</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h2><h3 id="方法一：朴素解法"><a href="#方法一：朴素解法" class="headerlink" title="方法一：朴素解法"></a>方法一：朴素解法</h3><ul><li><p>思路分析</p><p>直观的解法的是：枚举原串 ss 中的每个字符作为「发起点」，每次从原串的「发起点」和匹配串的「首位」开始尝试匹配：</p><p>匹配成功：返回本次匹配的原串「发起点」。<br>匹配失败：枚举原串的下一个「发起点」，重新尝试匹配。</p><p>参考：<a href="https://leetcode-cn.com/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/">宫水三叶</a></p></li></ul><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String ss, String pp)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = ss.length(), m = pp.length();</span><br><span class="line">        <span class="keyword">char</span>[] s = ss.toCharArray(), p = pp.toCharArray();</span><br><span class="line">        <span class="comment">// 枚举原串的「发起点」</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++) {</span><br><span class="line">            <span class="comment">// 从原串的「发起点」和匹配串的「首位」开始，尝试匹配</span></span><br><span class="line">            <span class="keyword">int</span> a = i, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (b &lt; m &amp;&amp; s[a] == p[b]) {</span><br><span class="line">                a++;</span><br><span class="line">                b++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果能够完全匹配，返回原串的「发起点」下标</span></span><br><span class="line">            <span class="keyword">if</span> (b == m) <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><br><h3 id="方法二-KMP算法"><a href="#方法二-KMP算法" class="headerlink" title="方法二:KMP算法"></a>方法二:KMP算法</h3><p>参考：<a href="http://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">代码随想录</a></p><h4 id="一、构造next数组"><a href="#一、构造next数组" class="headerlink" title="一、构造next数组"></a>一、构造next数组</h4><p><strong>构造next数组其实就是计算模式串s，前缀表的过程。</strong> 主要有如下三步：</p><ol><li><p>初始化</p></li><li><p>处理前后缀不相同的情况</p></li><li><p>处理前后缀相同的情况</p><br><p>1.初始化：</p></li></ol><p>定义两个指针i和j，j指向前缀起始位置，i指向后缀起始位置。</p><p>然后还要对next数组进行初始化赋值，如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int j = -1;</span><br><span class="line">next[0] = j;</span><br></pre></td></tr></tbody></table></figure><p>j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。</p><p>next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）</p><p>所以初始化next[0] = j 。</p><p>2.处理前后缀不相同的情况</p><p>因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。</p><p>所以遍历模式串s的循环下标i 要从 1开始，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 1; i &lt; s.size(); i++) {</span><br></pre></td></tr></tbody></table></figure><p>如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。</p><p>怎么回退呢？</p><p>next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。</p><p>那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。</p><p>所以，处理前后缀不相同的情况代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了</span><br><span class="line">    j = next[j]; // 向前回退</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>3.处理前后缀相同的情况</p><p>如果s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (s[i] == s[j + 1]) { // 找到相同的前后缀</span><br><span class="line">    j++;</span><br><span class="line">}</span><br><span class="line">next[i] = j;</span><br></pre></td></tr></tbody></table></figure><p>最后整体构建next数组的函数代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>* next, <span class="keyword">const</span> string&amp; s)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) { <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) { <span class="comment">// 前后缀不相同了</span></span><br><span class="line">            j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) { <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码构造next数组的逻辑流程动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif"></p><br><h4 id="二、使用next数组来做匹配"><a href="#二、使用next数组来做匹配" class="headerlink" title="二、使用next数组来做匹配"></a>二、使用next数组来做匹配</h4><p>在文本串s里 找是否出现过模式串t。</p><p>定义两个下标j 指向模式串起始位置，i指向文本串起始位置。</p><p>那么j初始值依然为-1，为什么呢？ <strong>依然因为next数组里记录的起始位置为-1。</strong></p><p>i就从0开始，遍历文本串，代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; s.size(); i++) </span><br></pre></td></tr></tbody></table></figure><p>接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。</p><p>如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) {</span><br><span class="line">    j = next[j];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (s[i] == t[j + 1]) {</span><br><span class="line">    j++; // i的增加在for循环里</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。</p><p>本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (j == (t.size() - 1) ) {</span><br><span class="line">    return (i - t.size() + 1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么使用next数组，用模式串匹配文本串的整体代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">-1</span>; <span class="comment">// 因为next数组里记录的起始位置为-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) { <span class="comment">// 注意i就从0开始</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>]) { <span class="comment">// 不匹配</span></span><br><span class="line">        j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s[i] == t[j + <span class="number">1</span>]) { <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">        j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j == (t.<span class="built_in">size</span>() - <span class="number">1</span>) ) { <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">        <span class="keyword">return</span> (i - t.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><p>此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPStr</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String pattern){</span><br><span class="line">        <span class="keyword">char</span>[] s = pattern.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[s.length];  <span class="comment">//初始化一个next数组</span></span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;   <span class="comment">//j+1指向前缀起始位置</span></span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length; i++) {  <span class="comment">//i指向后缀起始位置,从1 开始</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]){<span class="comment">// 前后缀不相同了</span></span><br><span class="line">                j = next[j];  <span class="comment">//让j+1向前回退</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]){<span class="comment">// 找到相同的前后缀</span></span><br><span class="line">                j++;   <span class="comment">//j+1后移一位</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            next[i] = j; <span class="comment">//将j（前缀的长度）赋给next[i]</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack,String needle)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] s = haystack.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] t = needle.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;  <span class="comment">// 因为next数组里记录的起始位置为-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(needle); <span class="comment">//获取next数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) {  <span class="comment">// 注意i就从0开始</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j+<span class="number">1</span>]){  <span class="comment">// 不匹配</span></span><br><span class="line">                j = next[j];  <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j+<span class="number">1</span>]){  <span class="comment">// 匹配，j和i同时向后移动,i的增加在for循环里</span></span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j == t.length-<span class="number">1</span>){  <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">                <span class="keyword">return</span> i - t.length + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------main------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        KMPStr kmp = <span class="keyword">new</span> KMPStr();</span><br><span class="line">        <span class="keyword">int</span>[] next = kmp.getNext(<span class="string">"aabaaf"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = kmp.strStr(<span class="string">"aabaabaaf"</span>, <span class="string">"aabaaf"</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="二、重复的子字符串"><a href="#二、重复的子字符串" class="headerlink" title="二、重复的子字符串"></a>二、重复的子字符串</h1><p><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: "abab"</span><br><span class="line">输出: True</span><br><span class="line">解释: 可由子字符串 "ab" 重复两次构成。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: "aba"</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: "abcabcabcabc"</span><br><span class="line">输出: True</span><br><span class="line">解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>思路分析</p><p>参考：<a href="http://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a></p></li></ul><p>此题依旧需要用到KMP算法的next数组。</p><p>next 数组记录的就是最长相同前后缀( <a href="https://mp.weixin.qq.com/s/MoRBHbS4hQXn7LcPdmHmIg">字符串：KMP算法精讲 </a>这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。</p><p>最长相等前后缀的长度为：next[len - 1] + 1。</p><p>数组长度为：len</p><p>如果len % (len - (next[len - 1] + 1)) == 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被 数组的长度整除，说明有该字符串有重复的子字符串。</p><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><p><strong>强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法</strong></p><p>如图：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2_1.png"></p><p>next[len - 1] = 7，next[len - 1] + 1 = 8，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。</p><p>(len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatedSubstringKMP</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String pattern){</span><br><span class="line">        <span class="keyword">char</span>[] s = pattern.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[s.length];</span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length; i++) {</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]){</span><br><span class="line">                j = next[j];  <span class="comment">//当前缀和后缀不相等时，j+1前移</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j+<span class="number">1</span>]){  <span class="comment">//当前缀和后缀相等时，i,j+1分别后移</span></span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRepeated</span><span class="params">(String pattern)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (pattern.length() == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(pattern);</span><br><span class="line">        <span class="keyword">int</span> len = next.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用next数组判断，一个字符串是否可以由它的一个子串重复多次构成</span></span><br><span class="line">        <span class="keyword">if</span> (next[len-<span class="number">1</span>] != -<span class="number">1</span> &amp;&amp; len%(len-(next[len-<span class="number">1</span>]+<span class="number">1</span>)) == <span class="number">0</span>){<span class="comment">//核心代码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------main---------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        RepeatedSubstringKMP kmp = <span class="keyword">new</span> RepeatedSubstringKMP();</span><br><span class="line">        <span class="keyword">int</span>[] next = kmp.getNext(<span class="string">"aabaaf"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">        System.out.println(kmp.isRepeated(<span class="string">"aabaab"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> KMP算法 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组刷题笔记</title>
      <link href="/posts/7dec.html"/>
      <url>/posts/7dec.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-数组的二分查找"><a href="#1-数组的二分查找" class="headerlink" title="1.数组的二分查找"></a>1.数组的二分查找</h1><ul><li><p>题目</p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span>     </span><br><span class="line">输出: <span class="number">4</span>       </span><br><span class="line">解释: <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span>   </span><br></pre></td></tr></tbody></table></figure></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>{</span><br><span class="line">       <span class="comment">//先判断要查找的值是否在数组的范围内</span></span><br><span class="line">       <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length-<span class="number">1</span>]){</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right){</span><br><span class="line">           <span class="keyword">int</span> middle = (left+right)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[middle] == target){</span><br><span class="line">               <span class="keyword">return</span> middle;</span><br><span class="line">           }<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[middle]){ <span class="comment">//如果要查找的值在左边</span></span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">           }<span class="keyword">else</span> { <span class="comment">//如果要查找的值在右边</span></span><br><span class="line">               left = middle+<span class="number">1</span>;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------main-------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        BinarySearch binarySearch = <span class="keyword">new</span> BinarySearch();</span><br><span class="line">        <span class="keyword">int</span>[] arr = {-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>};</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> res = binarySearch.binarySearch(arr,target);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>参考：<a href="http://programmercarl.com/">代码随想录</a></p><hr><h1 id="2-移除数组中的元素"><a href="#2-移除数组中的元素" class="headerlink" title="2.移除数组中的元素"></a>2.移除数组中的元素</h1><p><a href="http://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#_27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">题目链接</a></p><ul><li>题目</li></ul><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变，你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 </p><p>​            你不需要考虑数组中超出新长度后面的元素。</p><h2 id="方法一：暴力求解"><a href="#方法一：暴力求解" class="headerlink" title="方法一：暴力求解"></a>方法一：暴力求解</h2><ul><li><p>思路分析</p><p>这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrc7x9tjg30du09m1ky.gif"></p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveElement</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**暴力移除数组的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 输入的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要移除的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回新的数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="comment">//如果找到要删除的值,就利用一个for循环,将下标i后面的值统统后移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] == val){</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) {</span><br><span class="line">                    arr[j-<span class="number">1</span>] = arr[j];</span><br><span class="line">                }</span><br><span class="line">                i--;  <span class="comment">// 因为此时i后面的值后移了，i位置上是新的值，所以i要减去1</span></span><br><span class="line">                      <span class="comment">//这样下一次循环时(i++)，i上的值相当于原先i位置上的下一个</span></span><br><span class="line">                size--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------main------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        RemoveElement remove = <span class="keyword">new</span> RemoveElement();</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>};</span><br><span class="line">        <span class="keyword">int</span> length = remove.removeElement(arr, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="方法二：双指针法"><a href="#方法二：双指针法" class="headerlink" title="方法二：双指针法"></a>方法二：双指针法</h2><ul><li><strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif"></p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveElement2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.length; fastIndex++) {</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fastIndex]) {</span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        RemoveElement2 remove = <span class="keyword">new</span> RemoveElement2();</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>};</span><br><span class="line">        <span class="keyword">int</span> length = remove.removeElement(arr, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="3-有序数组的平方"><a href="#3-有序数组的平方" class="headerlink" title="3.有序数组的平方"></a>3.有序数组的平方</h1><ul><li>题目</li></ul><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><ul><li><p>思路：双指针法</p><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> </p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> </p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif"></p></li><li><p>代码详情</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SquareOfSortArray</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquare(<span class="keyword">int</span>[] arr){</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">int</span> k = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right){</span><br><span class="line">            <span class="keyword">if</span> (arr[right]*arr[right] &gt; arr[left]*arr[left]){</span><br><span class="line">                res[k--] = arr[right]*arr[right];</span><br><span class="line">                right--;</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                res[k--] = arr[left]*arr[left];</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------main------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SquareOfSortArray sortArray = <span class="keyword">new</span> SquareOfSortArray();</span><br><span class="line">        <span class="keyword">int</span>[] arr = {-<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>};</span><br><span class="line">        <span class="keyword">int</span>[] square = sortArray.sortedSquare(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : square) {</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参考：<a href="http://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95">代码随想录</a></p><hr><h1 id="4-长度最小的子数组"><a href="#4-长度最小的子数组" class="headerlink" title="4.长度最小的子数组"></a>4.长度最小的子数组</h1><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">题目链接</a></p><ul><li>题目</li></ul><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><h2 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h2><ul><li><p>代码详情</p><p>这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2)</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 长度最小的子数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinSubArrayLen</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 暴力求解，利用两个for循环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 输入的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 要求子数组的和 &gt;= s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回子数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE; <span class="comment">// 要返回的子数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> subLen = <span class="number">0</span>; <span class="comment">// 子数组的长度，中间变量，用于比较各个子数组</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;   <span class="comment">//用于计算子数组的和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {  <span class="comment">//遍历数组</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length ; j++) {  <span class="comment">//j从i的位置往后累加</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= s){</span><br><span class="line">                    subLen = j-i+<span class="number">1</span>;  <span class="comment">//当累加结果sum大于等于s时，保留此时的子数组长度</span></span><br><span class="line">                    result = subLen &lt; result ? subLen : result;  <span class="comment">//更新result的值</span></span><br><span class="line">                    <span class="keyword">break</span>;           <span class="comment">//跳出循环，进行下一轮</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result; <span class="comment">//如果result的值不变，</span></span><br><span class="line">                                                         <span class="comment">// 说明为找到符合条件的子数组，则返回0</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------main---------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MinSubArrayLen subArrayLen = <span class="keyword">new</span> MinSubArrayLen();</span><br><span class="line">        <span class="keyword">int</span>[] nums = {<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>};</span><br><span class="line">        <span class="keyword">int</span> len = subArrayLen.minSubArrayLen(nums, <span class="number">7</span>);</span><br><span class="line">        System.out.println(len);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a>方法二：滑动窗口</h2><ul><li>思路分析</li></ul><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif"></p><p>最后找到 4，3 是最短距离。</p><p>其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p><p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210312160441942.png"></p><p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p><p><strong>为什么时间复杂度是O(n)</strong>:</p><p>不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是$O(n)$。</p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 滑动窗口，也可以理解为双指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 输入的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 要求子数组的和 &gt;= s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回子数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLengthWindow</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE; <span class="comment">// 要返回的子数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> subLen = <span class="number">0</span>; <span class="comment">// 子数组的长度，中间变量，用于比较各个子数组</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;   <span class="comment">//用于计算子数组的和</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;     <span class="comment">//滑动窗口的起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) {  <span class="comment">//j表示滑动窗口的终止位置</span></span><br><span class="line">            sum += nums[j];   <span class="comment">//sum滑动窗口内保存的值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//滑动窗口的精髓</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s){  <span class="comment">//当滑动窗口内的值大于等于s时，滑动窗口的起始位置移动</span></span><br><span class="line">                subLen = j-i+<span class="number">1</span>;</span><br><span class="line">                result = result &lt; subLen ? result : subLen;  <span class="comment">//更新result的值</span></span><br><span class="line"></span><br><span class="line">                sum = sum - nums[i++];  <span class="comment">//滑动窗口内的值减去nums[i],同时，滑动窗口的起始位置右移</span></span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result; <span class="comment">//如果result的值不变，</span></span><br><span class="line">                                                         <span class="comment">// 说明为找到符合条件的子数组，则返回0</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>转载自：<a href="http://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">代码随想录</a>，向大佬表示感谢。</p><hr><h1 id="5-螺旋矩阵"><a href="#5-螺旋矩阵" class="headerlink" title="5.螺旋矩阵"></a>5.螺旋矩阵</h1><ul><li>题目</li></ul><p>题目地址：<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">https://leetcode-cn.com/problems/spiral-matrix-ii/</a> 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><ul><li>思路分析</li></ul><p>求解本题依然是要坚持循环不变量原则。</p><p>模拟顺时针画矩阵的过程:</p><p>  填充上行从左到右</p><p>  填充右列从上到下</p><p>  填充下行从右到左</p><p>  填充左列从下到上</p><p>由外向内一圈一圈这么画下去。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开又闭的原则，这样这一圈才能按照统一的规则画下来。</p><p>那么我按照左闭右开的原则，来画一圈，大家看一下：</p><p><img src="https://img-blog.csdnimg.cn/2020121623550681.png"></p><p>这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。</p><p>这也是坚持了每条边左闭右开的原则。</p><p>一些同学做这道题目之所以一直写不好，代码越写越乱。</p><p>就是因为在画每一条边的时候，一会左开又闭，一会左闭右闭，一会又来左闭右开，岂能不乱。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiralMatrix</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) {</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n]; <span class="comment">// 定义一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="keyword">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="keyword">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">1</span>; <span class="comment">// 每一圈循环，需要控制每一条边遍历的长度</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> ( loop &gt; <span class="number">0</span> ) {</span><br><span class="line"></span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; starty + n - offset; j++) {</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; startx + n - offset; i++) {</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) {</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) {</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            loop--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) {</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------main-------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[][] ints = generateMatrix(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] anInt : ints) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : anInt) {</span><br><span class="line">                System.out.print(i+<span class="string">"\t"</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>转载自：<a href="http://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">代码随想录</a>，向大佬表示感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer题解之链表</title>
      <link href="/posts/ae99.html"/>
      <url>/posts/ae99.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-返回链表中倒数最后k个结点"><a href="#1-返回链表中倒数最后k个结点" class="headerlink" title="1.返回链表中倒数最后k个结点"></a>1.返回链表中倒数最后k个结点</h1><p><a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&amp;&amp;tqId=11167&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网-JZ14</a></p><ul><li>题目：输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。</li></ul><p>如果该链表长度小于k，请返回一个长度为 0 的链表。</p><ul><li>思路分析</li></ul><p>设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K +1个节点处，该位置就是倒数第 K 个节点。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210810124830.png"></p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回链表中倒数最后k个结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：此题中链表的头节点即为第一个有效的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindKthToTail</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node head,Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(Node head)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.printf(<span class="string">"节点编号：%d \n"</span>, cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。</span></span><br><span class="line"><span class="comment">     * 如果该链表长度小于k，请返回一个长度为 0 的链表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 输入链表的头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 倒数第k个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 倒数第k个结点至尾节点的全部节点 的 头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">findKthToTail</span><span class="params">(Node head,<span class="keyword">int</span> k)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node p1 = head;</span><br><span class="line">        Node p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; k &gt; <span class="number">0</span>){</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            k--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>){</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------main-----------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        FindKthToTail list = <span class="keyword">new</span> FindKthToTail();</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        list.add(head,<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        list.add(head,<span class="keyword">new</span> Node(<span class="number">3</span>));</span><br><span class="line">        list.add(head,<span class="keyword">new</span> Node(<span class="number">4</span>));</span><br><span class="line">        list.add(head,<span class="keyword">new</span> Node(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        list.list(head);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------findKthToTail---------"</span>);</span><br><span class="line">        Node newHead = list.findKthToTail(head, <span class="number">3</span>);</span><br><span class="line">        list.list(newHead);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-两个链表的第一个公共结点"><a href="#2-两个链表的第一个公共结点" class="headerlink" title="2.两个链表的第一个公共结点"></a>2.两个链表的第一个公共结点</h1><p><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;&amp;tqId=11189&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网-JZ36</a></p><ul><li>题目：输入两个无环的单链表，找出它们的第一个公共结点。</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210810150024.png"></p><ul><li><p>解题思路</p><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p><p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p></li></ul><ul><li>核心代码</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>{</span><br><span class="line">    ListNode l1 = pHead1, l2 = pHead2;</span><br><span class="line">    <span class="keyword">while</span> (l1 != l2) {</span><br><span class="line">        l1 = (l1 == <span class="keyword">null</span>) ? pHead2 : l1.next;</span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span>) ? pHead1 : l2.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>本题转载自：<a href="http://www.cyc2018.xyz/">CyC2018</a></li></ul><hr><h1 id="3-环形链表II"><a href="#3-环形链表II" class="headerlink" title="3.环形链表II"></a>3.环形链表II</h1><ul><li>题目</li></ul><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明</strong>：不允许修改给定的链表。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210813130108.png"></p><ul><li>思路分析</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo58gauidg30fw0bi4qr.gif"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) {</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) {<span class="comment">// 有环</span></span><br><span class="line">                ListNode index1 = fast;</span><br><span class="line">                ListNode index2 = head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) {</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>转载自：<a href="http://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表刷题日记</title>
      <link href="/posts/3568.html"/>
      <url>/posts/3568.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-在单链表中删除倒数第K个节点"><a href="#1-在单链表中删除倒数第K个节点" class="headerlink" title="1.在单链表中删除倒数第K个节点"></a>1.在单链表中删除倒数第K个节点</h1><ul><li><p>题目</p><p>给定一个单链表，要求删除倒数第K个节点，并返回该节点</p></li></ul><br><ul><li>解答</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210808163210.jpg"></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210808163227.jpg"></p><br><br><ul><li><p>代码详情</p><p> Node节点类</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br><p>单链表类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.printf(<span class="string">"节点编号：%d \n"</span>, cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**在单链表中删除倒数第k个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastKth 倒数第k个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的倒数第k个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeLastKthNode</span><span class="params">(<span class="keyword">int</span> lastKth)</span></span>{</span><br><span class="line">        Node cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || lastKth &lt; <span class="number">1</span>){</span><br><span class="line">            System.out.println(<span class="string">"链表为空或者参数输入有误！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历链表，每移动一次，lathKth的值就减去1</span></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            lastKth--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node res = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastKth &gt; <span class="number">0</span>){ <span class="comment">//lastKth的值大于链表的长度，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(lastKth == <span class="number">0</span>){ <span class="comment">// 此时，lastKth就是第一个节点</span></span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.head;</span><br><span class="line">        }<span class="keyword">else</span> {   <span class="comment">//如果lastKth &lt; 0</span></span><br><span class="line">            cur = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">while</span> (lastKth != <span class="number">0</span>){</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                lastKth++;</span><br><span class="line">            }</span><br><span class="line">            res = cur.next; <span class="comment">//将要删除的节点赋值给res,用来返回</span></span><br><span class="line"></span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------main-----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SingleLinkedList linkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        linkedList.add(<span class="keyword">new</span> Node(<span class="number">1</span>));</span><br><span class="line">        linkedList.add(<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        linkedList.add(<span class="keyword">new</span> Node(<span class="number">3</span>));</span><br><span class="line">        linkedList.add(<span class="keyword">new</span> Node(<span class="number">4</span>));</span><br><span class="line">        linkedList.add(<span class="keyword">new</span> Node(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        Node node = linkedList.removeLastKthNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        linkedList.list();</span><br><span class="line">        System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        System.out.println(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br><h1 id="2-单链表的反转"><a href="#2-单链表的反转" class="headerlink" title="2.单链表的反转"></a>2.单链表的反转</h1><ul><li><p>题目</p><p>给定一个单链表，实现单链表的反转</p></li></ul><ul><li>思路分析</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210808221329.png" alt="反转单链表"></p><ul><li>代码实现</li></ul><p>Node节点类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><p>反转链表类ReverseList</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.printf(<span class="string">"节点编号：%d \n"</span>, cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转单链表的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseList</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span> ){</span><br><span class="line">            System.out.println(<span class="string">"不用反转该链表"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        Node newHead = <span class="keyword">new</span> Node(-<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>){  <span class="comment">//遍历链表，cur为遍历到的当前节点</span></span><br><span class="line">            next = cur.next;  <span class="comment">//next 指向当前节点[cur]的下一个节点</span></span><br><span class="line">            cur.next = newHead.next;  <span class="comment">//当前节点[cur]的next域指向新的头节点的下一个节点</span></span><br><span class="line">            newHead.next = cur;   <span class="comment">//newHead的next域指向当前节点[cur]</span></span><br><span class="line">            cur = next;   <span class="comment">//cur后移一位</span></span><br><span class="line">        }</span><br><span class="line">        head.next = newHead.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------main--------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ReverseList reverseList = <span class="keyword">new</span> ReverseList();</span><br><span class="line">        reverseList.add(<span class="keyword">new</span> Node(<span class="number">1</span>));</span><br><span class="line">        reverseList.add(<span class="keyword">new</span> Node(<span class="number">3</span>));</span><br><span class="line">        reverseList.add(<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        reverseList.add(<span class="keyword">new</span> Node(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        reverseList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---反转后的链表---"</span>);</span><br><span class="line">        reverseList.reverseList();</span><br><span class="line">        reverseList.list();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-判断一个链表是否为回文结构"><a href="#3-判断一个链表是否为回文结构" class="headerlink" title="3.判断一个链表是否为回文结构"></a>3.判断一个链表是否为回文结构</h1><ul><li>题目</li></ul><p>给定一个链表，请判断该链表是否为回文结构</p><p>例如：</p><p>1-&gt;2-&gt;1,返回true</p><p>1-&gt;2-&gt;2-&gt;1,返回true</p><p>1-&gt;2-&gt;3,返回false</p><ul><li><p>思路分析</p><p>1.遍历链表，将链表的节点依次压入一个栈中</p><p>2.依次弹出栈中的节点，与链表中的节点作比较，如果每次比较的节点的值都相等，则为回文结构</p></li></ul><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断链表是否是回文结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsPalindrome</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>){</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur = head.next;</span><br><span class="line">        Node popNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; cur != <span class="keyword">null</span>){</span><br><span class="line">            popNode = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (popNode.val != cur.val){</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------main----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        IsPalindrome palindrome = <span class="keyword">new</span> IsPalindrome();</span><br><span class="line">        palindrome.add(<span class="keyword">new</span> Node(<span class="number">1</span>));</span><br><span class="line">        palindrome.add(<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        palindrome.add(<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        palindrome.add(<span class="keyword">new</span> Node(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> palindrome1 = palindrome.isPalindrome();</span><br><span class="line">        System.out.println(palindrome1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-删除无序链表中值重复出现的节点"><a href="#4-删除无序链表中值重复出现的节点" class="headerlink" title="4.删除无序链表中值重复出现的节点"></a>4.删除无序链表中值重复出现的节点</h1><ul><li><p>题目(难度<strong>一星</strong>)</p><p>给定一个无序单链表，删除其中值重复出现的节点</p><p>例如:1-&gt;2-&gt;2-&gt;4-&gt;5-&gt;4-&gt;null,删除值重复之后的链表为：1-&gt;2-&gt;4-&gt;5-&gt;null</p></li></ul><ul><li>思路分析</li></ul><p>1.遍历当前链表，创建Node节点cur指向当前节点，pre指向cur的前一个节点</p><p>2.生成一个哈希表，如果cur的值已经存在于哈希表中，就将当前节点删除<code>(pre.next = cur.next)</code></p><p>​                                  如果cur的值不存在哈希表中，将其加入到哈希表中，同时令pre = cur(为下一次遍历做准备)</p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中的重复节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveRepeat</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.printf(<span class="string">"节点编号：%d \n"</span>, cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeRepeat</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Node cur = head.next;  <span class="comment">//cur指向当前节点</span></span><br><span class="line">        Node pre = head;   <span class="comment">//cur指向当前节点的前一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">if</span> (set.contains(cur.val)){  <span class="comment">//如果哈希表中包含当前节点cur的值，就删除cur节点</span></span><br><span class="line">                pre.next = cur.next;</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span> {     <span class="comment">//如果不包含，则将cur节点的值加入到哈希表中</span></span><br><span class="line">                set.add(cur.val);</span><br><span class="line">                pre = cur;  <span class="comment">//pre后移一位</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------main---------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        RemoveRepeat remove = <span class="keyword">new</span> RemoveRepeat();</span><br><span class="line"></span><br><span class="line">        remove.add(<span class="keyword">new</span> Node(<span class="number">1</span>));</span><br><span class="line">        remove.add(<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        remove.add(<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        remove.add(<span class="keyword">new</span> Node(<span class="number">4</span>));</span><br><span class="line">        remove.add(<span class="keyword">new</span> Node(<span class="number">5</span>));</span><br><span class="line">        remove.add(<span class="keyword">new</span> Node(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        remove.removeRepeat();</span><br><span class="line"></span><br><span class="line">        remove.list();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="5-合并两个有序的单链表"><a href="#5-合并两个有序的单链表" class="headerlink" title="5.合并两个有序的单链表"></a>5.合并两个有序的单链表</h1><ul><li>题目(难度<strong>一星</strong>)</li></ul><p>给定两个有序单链表的头节点head1,head2,请合并两个有序链表，合并后的链表依然有序，并返回合并后链表的头节点</p><p>例如：</p><p>0-&gt;2-&gt;3-&gt;7-&gt;null</p><p>1-&gt;3-&gt;5-&gt;7-&gt;9-&gt;null</p><p>合并后的链表：0-&gt;1-&gt;2-&gt;3-&gt;3-&gt;5-&gt;7-&gt;7-&gt;9-&gt;null</p><ul><li>思路分析</li></ul><p>1.当两个链表都不为空时，遍历两个链表，并比较链表中节点值的大小，将较小的节点加入到</p><p>新的以newHead为头节点的链表中，如果相等，则依次加入两个相等的节点。</p><p>2.若两个链表中其中一个遍历到了末尾，则把另一个链表中的节点加入到新的链表中</p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序的单链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeLinkedList</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node head,Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(Node head)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.printf(<span class="string">"节点编号：%d \n"</span>, cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个单链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 第一个链表的头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 第二个链表的头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回新的链表的头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">merge</span><span class="params">(Node head1,Node head2)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (head1.next == <span class="keyword">null</span> &amp;&amp; head2.next == <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"两个链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node newHead = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">        Node cur = newHead;</span><br><span class="line">        head1 = head1.next;</span><br><span class="line">        head2 = head2.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">if</span> (head1.val &lt; head2.val){</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (head2.val &lt; head1.val){</span><br><span class="line">                cur.next = head2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line"></span><br><span class="line">                cur.next = head2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="keyword">null</span>){</span><br><span class="line">            cur.next = head1;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head2 != <span class="keyword">null</span>){</span><br><span class="line">            cur.next = head2;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------main--------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MergeLinkedList merge = <span class="keyword">new</span> MergeLinkedList();</span><br><span class="line"></span><br><span class="line">        Node head1 = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">        Node head2 = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        merge.add(head1,<span class="keyword">new</span> Node(<span class="number">0</span>));</span><br><span class="line">        merge.add(head1,<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        merge.add(head1,<span class="keyword">new</span> Node(<span class="number">3</span>));</span><br><span class="line">        merge.add(head1,<span class="keyword">new</span> Node(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">        merge.add(head2,<span class="keyword">new</span> Node(<span class="number">1</span>));</span><br><span class="line">        merge.add(head2,<span class="keyword">new</span> Node(<span class="number">3</span>));</span><br><span class="line">        merge.add(head2,<span class="keyword">new</span> Node(<span class="number">5</span>));</span><br><span class="line">        merge.add(head2,<span class="keyword">new</span> Node(<span class="number">7</span>));</span><br><span class="line">        merge.add(head2,<span class="keyword">new</span> Node(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">        Node merge1 = merge.merge(head1, head2);</span><br><span class="line"></span><br><span class="line">        merge.list(merge1);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单向环形链表之约瑟夫环</title>
      <link href="/posts/d2de.html"/>
      <url>/posts/d2de.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>Josephus问题:</p><p>约瑟夫问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p><p>例如：</p><p>n = 5 , 即有5个人 </p><p>k = 1, 从第一个人开始报数</p><p>m = 2, 数2下</p><p>出圈的顺序</p><p>2-&gt;4-&gt;1-&gt;5-&gt;3</p></li></ul><br><ul><li>思路图解<ul><li>构建单向环形链表</li></ul></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210807164227.png"></p><br><ul><li><ul><li>节点出圈的思路图解</li></ul></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210807164339.png"></p><br><ul><li>代码详情</li></ul><p>Node节点类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小孩节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> no;</span><br><span class="line"></span><br><span class="line">    Boy next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><p>下面是单向环形链表类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向环形链表-约瑟夫环</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleCircle</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boy first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将小孩加入约瑟夫环的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 表示环中结点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Boy curBoy = <span class="keyword">null</span>;  <span class="comment">//辅助变量，用来帮助小孩进圈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) {</span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当加入第一个小孩时，让其自己成环</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>){</span><br><span class="line">                first = boy;  <span class="comment">//first始终指向第一个小孩</span></span><br><span class="line">                first.next = first;</span><br><span class="line">                curBoy = first;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//新的小孩结点的进圈操作</span></span><br><span class="line">            curBoy.next = boy;</span><br><span class="line">            curBoy = curBoy.next;</span><br><span class="line">            curBoy.next = first;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历圈中的小孩结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"圈中没有小孩结点"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Boy cur = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">            System.out.printf(<span class="string">"当前的小孩编号:%d \n"</span>,cur.no);</span><br><span class="line">            <span class="keyword">if</span> (cur.next == first){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 小孩出圈的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo 从第几个小孩开始数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 数几次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 圈中小孩的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> startNo,<span class="keyword">int</span> count,<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; num){</span><br><span class="line">            System.out.println(<span class="string">"参数输入有误！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Boy helper = first;<span class="comment">//创建一个辅助指针，让其始终位于first指针的前一个</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//先让first移动到startNo处，即开始报数的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= startNo-<span class="number">1</span>; i++) {</span><br><span class="line">            first = first.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再让helper 移动到first的前一位</span></span><br><span class="line">        <span class="keyword">while</span> (helper.next != first){</span><br><span class="line">            helper = helper.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (helper != first){</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开始报数，让helper和first移动到指定位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count-<span class="number">1</span>; i++) {</span><br><span class="line">                helper = helper.next;</span><br><span class="line">                first = first.next;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//此时first指向要移除的小孩结点</span></span><br><span class="line">            System.out.printf(<span class="string">"出圈小孩的编号：%d \n"</span>,first.no);</span><br><span class="line">            first = first.next;</span><br><span class="line">            helper.next = first;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"最后出圈小孩的编号：%d \n"</span>,first.no);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//***************写个main方法测试一下*******************</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SingleCircle singleCircle = <span class="keyword">new</span> SingleCircle();</span><br><span class="line"></span><br><span class="line">        singleCircle.add(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        singleCircle.remove(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 约瑟夫环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的增删改查和插入</title>
      <link href="/posts/64b9.html"/>
      <url>/posts/64b9.html</url>
      
        <content type="html"><![CDATA[<ul><li>本篇博文属于单链表的入门案例，包含单链表的一些基础操作:增删改查、插入</li></ul><ul><li><p>1.首先创建一个Node结点类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    Integer id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer id, String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><br><ul><li>2.然后创建一个单链表类(包含了单链表的增删改查等方法)</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleList</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为当前单向链表添加一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个临时结点指向头结点</span></span><br><span class="line">        Node temp = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一直遍历链表，直到temp.next == null</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>){</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//temp.next == null,说明找到了链表的尾部，将node加入链表中</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照id修改链表的name</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.id == node.id){</span><br><span class="line">                temp.name = node.name;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.next.id == id){</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照id编号的大小顺序插入，从小到大</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertById</span><span class="params">(Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果temp结点的下一个为空，直接跳出循环,从这里跳出循环flag=false;</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//程序走到这里，说明，temp.next != null</span></span><br><span class="line">            <span class="keyword">if</span> (node.id == temp.next.id){</span><br><span class="line"></span><br><span class="line">                flag = <span class="keyword">true</span>;  <span class="comment">//从这里跳出循环flag = true</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(node.id &lt; temp.next.id){</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//从这里跳出循环flag = false;</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里不用写出node.id &gt; temp.next.id的情况，</span></span><br><span class="line">            <span class="comment">//因为这种情况会一直遍历到链表的末尾，满足temp.next == null条件后，跳出循环，最后在链表末尾加上node</span></span><br><span class="line"></span><br><span class="line">            temp = temp.next;  <span class="comment">//temp 向后移动一位，用来遍历单链表</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag){</span><br><span class="line">            System.out.println(<span class="string">"编号已经存在"</span>);</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//在此处执行结点的插入操作(适用于在head结点后加结点(即temp.next == null)，以及node.id 小于 temp.next.id的情况)</span></span><br><span class="line">            node.next = temp.next;</span><br><span class="line">            temp.next = node;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SingleList list = <span class="keyword">new</span> SingleList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*list.add(new Node(1,"张三"));</span></span><br><span class="line"><span class="comment">        list.add(new Node(2,"lisi"));</span></span><br><span class="line"><span class="comment">        list.update(new Node(2,"李四"));</span></span><br><span class="line"><span class="comment">        list.add(new Node(3,"王五"));</span></span><br><span class="line"><span class="comment">        list.add(new Node(4,"赵六"));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        list.delete(1);</span></span><br><span class="line"><span class="comment">        list.delete(4);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        list.list();*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//*****************上面是增删改查的测试************</span></span><br><span class="line">        <span class="comment">//*****************下面是按顺序插入的测试************</span></span><br><span class="line"></span><br><span class="line">        list.insertById(<span class="keyword">new</span> Node(<span class="number">3</span>,<span class="string">"王3"</span>));</span><br><span class="line">        list.insertById(<span class="keyword">new</span> Node(<span class="number">2</span>,<span class="string">"王2"</span>));</span><br><span class="line">        list.insertById(<span class="keyword">new</span> Node(<span class="number">1</span>,<span class="string">"王1"</span>));</span><br><span class="line">        list.insertById(<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="string">"王5"</span>));</span><br><span class="line">        list.insertById(<span class="keyword">new</span> Node(<span class="number">4</span>,<span class="string">"王4"</span>));</span><br><span class="line">        list.insertById(<span class="keyword">new</span> Node(<span class="number">6</span>,<span class="string">"王6"</span>));</span><br><span class="line"></span><br><span class="line">        list.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列刷题笔记</title>
      <link href="/posts/f354.html"/>
      <url>/posts/f354.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-用一个栈实现另一个栈的排序"><a href="#1-用一个栈实现另一个栈的排序" class="headerlink" title="1.用一个栈实现另一个栈的排序"></a>1.用一个栈实现另一个栈的排序</h1><ul><li><p>题目：</p><p>​         一个栈中的类型为整型，现在想将该栈从顶到底按照从大到小的顺序排序，只允许申请一个栈，除此之外，可以申请新的变量，如何排序？</p></li><li><p>思路分析：</p><p>​        将要排序的栈记为stack,申请的辅助栈记为help，在stack上执行pop操作，弹出的元素记为cur</p><ul><li><p>如果cur小于或等于help的栈顶元素，直接将cur压入help</p></li><li><p>如果cur大于help的栈顶元素，则将help中的元素逐次弹出，然后压入stack中，直到cur小于或等于help的栈顶元素，再将cur压入help栈中；</p><p>如果在help栈的弹栈过程中，help已经空了，则说明cur是当前的最大元素，则直接将cur压入help中</p></li><li><p>最后，help中的数，从栈顶到栈底为从小到大的顺序，将help中的数依次弹出压入stack中，则stack从栈顶到栈底为从大到小的顺序</p></li></ul></li><li><p>难度：一星</p></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用一个栈实现另一个栈的排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortStackByStack</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stack <span class="title">sortStack</span><span class="params">(Stack&lt;Integer&gt; stack)</span></span>{</span><br><span class="line"></span><br><span class="line">       Stack&lt;Integer&gt; help = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> cur = stack.pop();</span><br><span class="line">           <span class="keyword">while</span>(!help.isEmpty() &amp;&amp; cur &gt; help.peek()){</span><br><span class="line">               stack.push(help.pop());</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           help.push(cur);</span><br><span class="line"></span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (!help.isEmpty()){</span><br><span class="line">           stack.push(help.pop());</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> stack;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">8</span>);</span><br><span class="line">        stack.push(<span class="number">7</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        stack = sortStack(stack);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br><h1 id="2-数组中元素与下一个比它大的元素之间的距离"><a href="#2-数组中元素与下一个比它大的元素之间的距离" class="headerlink" title="2.数组中元素与下一个比它大的元素之间的距离"></a>2.数组中元素与下一个比它大的元素之间的距离</h1><p><a href="https://leetcode-cn.com/problems/daily-temperatures/description/">力扣</a>（Medium）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">71</span>, <span class="number">69</span>, <span class="number">72</span>, <span class="number">76</span>, <span class="number">73</span>]</span><br><span class="line">Output: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li>说明：对于此题，提供两种解法，详情见下面代码</li><li>方法一：暴力求解,<strong>时间复杂度O(N^2)</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度为O(N^2),每个位置向右遍历一下即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyTemperature2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] rightWay(<span class="keyword">int</span> arr[]){</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="keyword">int</span> cur = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightMoreIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; arr.length){</span><br><span class="line">                <span class="keyword">if</span> (arr[cur] &gt; arr[i]){</span><br><span class="line">                    res[i] = cur - i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                cur++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写个main方法测试一下</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">73</span>,<span class="number">74</span>,<span class="number">75</span>,<span class="number">71</span>,<span class="number">69</span>,<span class="number">72</span>,<span class="number">76</span>,<span class="number">73</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = rightWay(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> re : res) {</span><br><span class="line">            System.out.println(re);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><ul><li><p>方法二：遍历数组时，使用<strong>栈</strong>把数组的下标存起来,<strong>时间复杂度O(N)</strong></p></li><li><p>思路分析：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *     1.用dist数组存放距离当前位置的距离，用stack存放原始数组temperature的下标</span></span><br><span class="line"><span class="comment"> *     2.用cur指向temperature数组的下标，pre指向stack栈的栈顶元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     3.如果stack不为空，并且当前遍历的数temperature[cur] 大于 栈顶对应的数temperature[stack.peek()]，</span></span><br><span class="line"><span class="comment"> *     就将stack的栈顶元素弹出，存到pre变量中，cur - pre即为与pre的距离dist[pre].之后再将cur压入stack中。</span></span><br><span class="line"><span class="comment"> *     4.如果stack为空，直接将cur压入stack中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyTemperatures</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] temperature = {<span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">71</span>, <span class="number">69</span>, <span class="number">72</span>, <span class="number">76</span>, <span class="number">73</span>};</span><br><span class="line">        <span class="keyword">int</span>[] dist = dailyTemperatures(temperature);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : dist) {</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[temperatures.length];</span><br><span class="line">        </span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cur = <span class="number">0</span>; cur &lt; temperatures.length; cur++) {</span><br><span class="line">            <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[cur] &gt; temperatures[stack.peek()]){</span><br><span class="line">                pre = stack.pop();</span><br><span class="line">                dist[pre] = cur - pre;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            stack.push(cur);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>  <br><br><h1 id="3-返回数组的最近邻位置（利用单调栈）"><a href="#3-返回数组的最近邻位置（利用单调栈）" class="headerlink" title="3.返回数组的最近邻位置（利用单调栈）"></a>3.返回数组的最近邻位置（利用单调栈）</h1><ul><li><p>题目：</p><p>给定一个不含重复值的数组arr,找到每一个位置i左边和右边离i位置最近且值比arr[i]小的位置，返回左右位置的相应信息</p></li><li><p>举例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">intput:</span><br><span class="line">      arr = {<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>}</span><br><span class="line">output:</span><br><span class="line">{</span><br><span class="line">        {-<span class="number">1</span>,<span class="number">2</span>},</span><br><span class="line">        {<span class="number">0</span>,<span class="number">2</span>},</span><br><span class="line">        {-<span class="number">1</span>,-<span class="number">1</span>},</span><br><span class="line">        {<span class="number">2</span>,<span class="number">5</span>},</span><br><span class="line">        {<span class="number">3</span>,<span class="number">5</span>},</span><br><span class="line">        {<span class="number">2</span>,-<span class="number">1</span>},</span><br><span class="line">        {<span class="number">5</span>,-<span class="number">1</span>},</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></li><li><p>解答：方法一</p><p>本题实现复杂度为O(N^2)的解释非常容易的，每个位置向左和向右遍历一下，总可以确定，见以下代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonotoneStack</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] rightWay(<span class="keyword">int</span>[] arr){</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> leftLessIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightLessIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = i-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cur &gt;= <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span> (arr[cur] &lt; arr[i]){</span><br><span class="line">                    leftLessIndex = cur;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                cur--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cur = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; arr.length){</span><br><span class="line">                <span class="keyword">if</span> (arr[cur] &lt; arr[i]){</span><br><span class="line">                    rightLessIndex = cur;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                cur++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            res[i][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">            res[i][<span class="number">1</span>] = rightLessIndex;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr2</span><span class="params">(<span class="keyword">int</span>[][] arr)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[<span class="number">0</span>].length; j++) {</span><br><span class="line">                System.out.print(arr[i][j]+<span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = rightWay(arr);</span><br><span class="line"></span><br><span class="line">        printArr2(res);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><br></li><li><p>方法二：利用单调栈结构，时间复杂度为O(N)</p></li><li><p>思路分析：</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单调栈——返回最近邻的位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 准备一个栈，记为Stack&lt;integer&gt;,栈中存放的元素是数组的位置，开始stack为空，如果找到每一个位置i左边</span></span><br><span class="line"><span class="comment"> * 和右边离i位置最近且值比arr[i]小的位置，那么需要让stack从栈顶到栈底的位置所代表的值是递减的(也就是从大到小)；</span></span><br><span class="line"><span class="comment"> * 如果找到每一个位置i左边和右边离i位置最近且值比arr[i]大的位置，那么需要让stack从栈顶到栈底的位置所代表的值是递增的。</span></span><br><span class="line"><span class="comment"> * 本题需要解决是前者。</span></span><br><span class="line"><span class="comment"> *     下面举例展示单调栈的使用和求解流程，以arr = {3,4,1,5,6,2,7}为例。</span></span><br><span class="line"><span class="comment"> *     1.初始时，arr = {3,4,1,5,6,2,7},stack为空。</span></span><br><span class="line"><span class="comment"> *     2.遍历arr数组，遍历到arr[0] = 3时，stack为空，直接将0压入stack中，此时，stack中从栈顶到栈底为{0(值为3)}</span></span><br><span class="line"><span class="comment"> *     3.遍历到arr[1]=4时，`arr[1] &gt; arr[stack.peek()]`，将1压入到stack中，此时，stack从栈顶到栈底为</span></span><br><span class="line"><span class="comment"> *     {1(值为4)，0(值为3)}</span></span><br><span class="line"><span class="comment"> *     4.遍历到arr[2] = 1时，如果将下标2压入stack中，会破坏stack从栈顶到栈底所代表的的值是递减的规律，</span></span><br><span class="line"><span class="comment"> *     那么，此时将stack的栈顶元素"1"弹出，位置1左边比它代表的值小的下标即为此时stack栈的栈顶元素"0"，</span></span><br><span class="line"><span class="comment"> *     位置1右边比它代表的值小的下标，即为当前遍历的下标"2"，那么res[1] = {0,2}。此时，stack从栈顶到栈底为{0(值为3)}，</span></span><br><span class="line"><span class="comment"> *     如果将下标2压入stack中，依旧会破坏stack从栈顶到栈底的元素所代表的值是递减的规律，此时将stack的栈顶元素"0"弹出，stack栈已经空了，</span></span><br><span class="line"><span class="comment"> *     位置0左边不存在比它小的数，默认取-1，位置0右边比它代表的值小的下标，即为当前遍历的下标"2"，那么res[0] = {-1,2}。</span></span><br><span class="line"><span class="comment"> *     这时，stack为空，将"2"压入stack中，stack从栈顶到栈底的元素为{2(值为1)}</span></span><br><span class="line"><span class="comment"> *     5.按照此规律继续遍历下去......</span></span><br><span class="line"><span class="comment"> *     6.遍历阶段结束后，stack从栈顶到栈底的元素为{6(值为7),5(值为2),2(值为1)}。</span></span><br><span class="line"><span class="comment"> *     下面清算stack中剩下的元素，将stack的栈顶元素"6"弹出，栈中它的下面位置是5，而由于6位置是清算阶段弹出的，所以res[6] = {5,-1};</span></span><br><span class="line"><span class="comment"> *     弹出5位置，栈中它的下面位置是2,5位置是清算阶段弹出的，所以res[5] = {2,-1};</span></span><br><span class="line"><span class="comment"> *     弹出2位置，栈中它的下面没有位置了,2位置是清算阶段弹出的，所以res[2] = {-1,-1};</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单调栈——返回最近邻的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonotoneStack2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getNearLessNoRepeat(<span class="keyword">int</span>[] arr){</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历阶段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line"></span><br><span class="line">             <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[stack.peek()]){</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">int</span> popIndex = stack.pop();</span><br><span class="line">                 <span class="keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                 res[popIndex][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">                 res[popIndex][<span class="number">1</span>] = i;</span><br><span class="line">             }</span><br><span class="line">             stack.push(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始清算阶段</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> popIndex = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            res[popIndex][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">            res[popIndex][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr2</span><span class="params">(<span class="keyword">int</span>[][] arr)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[<span class="number">0</span>].length; j++) {</span><br><span class="line">                System.out.print(arr[i][j]+<span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = getNearLessNoRepeat(arr);</span><br><span class="line"></span><br><span class="line">        printArr2(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="4-滑动窗口最大值"><a href="#4-滑动窗口最大值" class="headerlink" title="4.滑动窗口最大值"></a>4.滑动窗口最大值</h1><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">LeetCode题目链接</a></p><ul><li>题目</li></ul><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.png"></p><br><ul><li>思路分析</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210816162527.jpg" alt="fe6757733991d64dbbd79685024dae8"></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210816162604.jpg" alt="2"></p><p>参考：程序员代码面试指南第2版（18-20），左程云著</p><br><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取滑动窗口的最大值，使用双端队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxWindow</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getMaxWindow(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> w){</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length-w+<span class="number">1</span>];  <span class="comment">// res数组用来放每个滑动窗口的最大值</span></span><br><span class="line">        LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//qmax 可以理解为一个双向的队列结构，用来放arr的下标</span></span><br><span class="line">                                                         <span class="comment">//qmax从队列头到队列尾应该是单调递减的</span></span><br><span class="line">                                                        <span class="comment">//qmax的队列头始终保存当前滑动窗口的最大值</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;  <span class="comment">//res数组的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当双向递减队列不为空，并且当前的arr[i] 大于等于 arr[队列尾部(下标)]</span></span><br><span class="line">            <span class="comment">//就将队列尾部元素弹出</span></span><br><span class="line">            <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[i] &gt;= arr[qmax.peekLast()]){</span><br><span class="line">                qmax.pollLast();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//程序走到此处，说明队列为空，或者，arr[i] &lt; arr[qmax.peekLast()]</span></span><br><span class="line">            <span class="comment">//此时将下标i加到队列尾部</span></span><br><span class="line">            qmax.addLast(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (qmax.peekFirst() == i-w){  <span class="comment">//说明qmax的队列头已经过期了，或者说滑动窗口已经滑动到下一个位置了，必须更新队列头</span></span><br><span class="line">                qmax.pollFirst();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= w-<span class="number">1</span>){  <span class="comment">//当i==2,到达第一个滑动窗口，更新res[]</span></span><br><span class="line">                res[index++] = arr[qmax.peekFirst()];</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------main-----------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MaxWindow window = <span class="keyword">new</span> MaxWindow();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>};</span><br><span class="line">        <span class="keyword">int</span>[] maxWindow = window.getMaxWindow(arr, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(maxWindow));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><hr><h1 id="5-前-K-个高频元素"><a href="#5-前-K-个高频元素" class="headerlink" title="5.前 K 个高频元素"></a>5.前 K 个高频元素</h1><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">LeetCode题目链接</a></p><ul><li>题目</li></ul><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</span><br><span class="line">你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</span><br><span class="line">题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</span><br><span class="line">你可以按任意顺序返回答案。</span><br></pre></td></tr></tbody></table></figure><br><ul><li>思路分析</li></ul><p>题目最终需要返回的是前 <em>k</em> 个频率最大的元素，可以想到借助堆这种数据结构，对于 <em>k</em> 频率之后的元素不用再去处理，</p><p>进一步优化时间复杂度。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210816192735.jpeg"></p><p>具体操作为：</p><p>借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率<br>维护一个元素数目为 k 的最小堆<br>每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较<br>如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中<br>最终，堆中的 k个元素即为前 k 个高频元素</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210816192723.gif"></p><p>参考：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/">程序员吴师兄</a></p><br><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopKFrequent</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topK(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k){</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num)){  <span class="comment">//如果包含num</span></span><br><span class="line">                map.put(num,map.get(num)+<span class="number">1</span>); <span class="comment">//将value的值+1</span></span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//上面循环结束，统计到了每个num出现的次数，key=num,value=frequency</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map，用最小堆保存出现频率最大的前k个元素</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>{</span><br><span class="line">                <span class="keyword">return</span> map.get(o1)-map.get(o2);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Integer key : keySet) {</span><br><span class="line">            <span class="keyword">if</span> (priorityQueue.size() &lt; k){</span><br><span class="line">                priorityQueue.add(key);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (map.get(key) &gt; map.get(priorityQueue.peek())){</span><br><span class="line">                priorityQueue.remove();</span><br><span class="line">                priorityQueue.add(key);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> index = res.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty()){</span><br><span class="line">            res[index--] = priorityQueue.remove();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-----------main---------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        TopKFrequent topK = <span class="keyword">new</span> TopKFrequent();</span><br><span class="line">        <span class="keyword">int</span>[] nums = {<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line">        <span class="keyword">int</span>[] res = topK.topK(nums,<span class="number">2</span>);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode题解-栈和队列</title>
      <link href="/posts/b04a.html"/>
      <url>/posts/b04a.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-用栈实现队列"><a href="#1-用栈实现队列" class="headerlink" title="1.用栈实现队列"></a>1.用栈实现队列</h1><p>栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackForQueue</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先准备两个栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先将元素压入第一个栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer val)</span></span>{</span><br><span class="line">        in.push(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将入栈的数据弹出，压入出栈中</span></span><br><span class="line">    <span class="comment">//在这个过程中，必须保证出栈为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in2out</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (out.isEmpty()){  <span class="comment">//如果出栈为空，才操作</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!in.isEmpty()){</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于一个出队列的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//先将 入栈 中的数据 压入到出栈中，这样，经过栈的两次“先进后出”，就实现了队列的“先进先出”</span></span><br><span class="line">        in2out();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看当前的队列的头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>{</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main方法测试一下结果 ***********************************************</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        StackForQueue queue = <span class="keyword">new</span> StackForQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) {</span><br><span class="line">            queue.push(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {</span><br><span class="line">            System.out.println(queue.pop());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="2-用队列实现栈"><a href="#2-用队列实现栈" class="headerlink" title="2.用队列实现栈"></a>2.用队列实现栈</h1><p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队列这种数据结构中，最先插入的元素将是最先被删除的元素；</span></span><br><span class="line"><span class="comment"> * 反之最后插入的元素将是最后被删除的元素，因此队列又称为“先进先出”（FIFO—first in first out）的线性表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Queue用法小结：</span></span><br><span class="line"><span class="comment"> * Queue使用时要尽量避免Collection的add()和remove()方法，</span></span><br><span class="line"><span class="comment"> * 而是要使用offer()来加入元素，使用poll()来获取并移出元素。</span></span><br><span class="line"><span class="comment"> * 它们的优点是通过返回值可以判断成功与否。</span></span><br><span class="line"><span class="comment"> * 而add()和remove()方法在失败的时候会抛出异常。</span></span><br><span class="line"><span class="comment"> * 如果要使用前端而不移出该元素，使用element()或者peek()方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueForStack</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueForStack</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用</span></span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="comment">//首先将val加入到队列中，此时，val位于队列的最后一位</span></span><br><span class="line">        queue.offer(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取队列的大小</span></span><br><span class="line">        <span class="keyword">int</span> count = queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">1</span>){</span><br><span class="line">            <span class="comment">//将当前队列的除val之外的所有元素，先取出队列，再放入队列</span></span><br><span class="line">            <span class="comment">//此时，val就位于队列的首位，那么，就实现了栈的“后进先出”</span></span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//查看当前的队列头</span></span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main方法，测试一下  *****************************************</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        QueueForStack queue = <span class="keyword">new</span> QueueForStack();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) {</span><br><span class="line">            queue.push(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {</span><br><span class="line">            System.out.println(queue.pop());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><hr><h1 id="3-最小值栈：设计一个有getMin功能的栈"><a href="#3-最小值栈：设计一个有getMin功能的栈" class="headerlink" title="3.最小值栈：设计一个有getMin功能的栈"></a>3.最小值栈：设计一个有getMin功能的栈</h1><ul><li><p>题目：实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作</p></li><li><p>要求：</p><ul><li>1.pop,push,getMin操作的时间复杂度都是O(1)</li><li>设计的栈类型可以使用现成的栈结构</li></ul></li><li><p>思路分析：在设计时，使用两个栈，一个栈用来保存所有的元素，其功能和一个正常的栈没有区别，这个栈记为dataStack.</p><p>另一个用来保存每一步的最小值，这个栈的栈针始终指向当前放入栈中元素的最小值，这个栈记为minStack.</p></li><li><p>代码实现</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMinStack</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMinStack</span><span class="params">()</span></span>{</span><br><span class="line">        dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>{</span><br><span class="line">        dataStack.push(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当minStack为空时，放入data</span></span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty()){</span><br><span class="line">            minStack.push(data);</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">else</span> {  <span class="comment">//当minStack不为空时,如果minStack的栈顶元素大于data时，</span></span><br><span class="line">                 <span class="comment">// 将data放入minStack,此时就能保证,minStack的栈顶元素为dataStack的最小值</span></span><br><span class="line">            <span class="keyword">if</span>(minStack.peek() &gt; data){</span><br><span class="line">                minStack.push(data);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (dataStack.isEmpty()){</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your Stack is empty!!!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dataStack.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty()){</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your Stack is empty!"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> dataStack.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main测试一下******************************************</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MyMinStack stack = <span class="keyword">new</span> MyMinStack();</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">5</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">8</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(stack.getMin()); <span class="comment">//1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>​       对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。</p><h1 id="4-用栈实现括号的匹配（Easy）"><a href="#4-用栈实现括号的匹配（Easy）" class="headerlink" title="4. 用栈实现括号的匹配（Easy）"></a>4. 用栈实现括号的匹配（Easy）</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/description/">力扣</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case1:</span><br><span class="line">Input:<span class="string">"()[]{}"</span></span><br><span class="line"></span><br><span class="line">Output : <span class="keyword">true</span></span><br><span class="line">    </span><br><span class="line">case2:</span><br><span class="line">Input:<span class="string">"({})"</span></span><br><span class="line"></span><br><span class="line">Output : <span class="keyword">true</span>    </span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用栈实现括号的匹配</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input:"()[]{}"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Output : true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidParentheses</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()){</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'{'</span> || c == <span class="string">'['</span>){</span><br><span class="line">                <span class="comment">//当满足"左括号"的条件时，压入栈中</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果此时栈中还为空，则不满足条件</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()){</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">//走到这一步，说明栈中不为空，此时"c"，满足为括号的右半部分</span></span><br><span class="line">                <span class="comment">//此时弹栈拿出括号的坐半部分left</span></span><br><span class="line">                <span class="keyword">char</span> left = stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//以下三个条件说明，在弹栈得到的left时,括号右半部分匹配不上，就返回false;</span></span><br><span class="line">                <span class="keyword">boolean</span> b1 = left == <span class="string">'('</span> &amp;&amp; c != <span class="string">')'</span>;</span><br><span class="line">                <span class="keyword">boolean</span> b2 = left == <span class="string">'{'</span> &amp;&amp; c != <span class="string">'}'</span>;</span><br><span class="line">                <span class="keyword">boolean</span> b3 = left == <span class="string">'['</span> &amp;&amp; c != <span class="string">']'</span>;</span><br><span class="line">                <span class="keyword">if</span> (b1 || b2 || b3){</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试 *******************************</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ValidParentheses vp = <span class="keyword">new</span> ValidParentheses();</span><br><span class="line">        System.out.println(vp.isValid(<span class="string">"()"</span>));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(vp.isValid(<span class="string">"()[]{}"</span>));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(vp.isValid(<span class="string">"{[]}"</span>));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(vp.isValid(<span class="string">"(]"</span>));   <span class="comment">//false</span></span><br><span class="line">        System.out.println(vp.isValid(<span class="string">"([)]"</span>));  <span class="comment">//false</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="5-逆波兰表达式求值"><a href="#5-逆波兰表达式求值" class="headerlink" title="5.逆波兰表达式求值"></a>5.逆波兰表达式求值</h1><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">leetcode题目链接</a></p><ul><li>题目</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">根据 逆波兰表示法，求表达式的值。</span><br><span class="line"></span><br><span class="line">有效的运算符包括 + ,  - ,  * ,  / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: ["2", "1", "+", "3", " * "]</span><br><span class="line">输出: 9</span><br><span class="line">解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: ["4", "13", "5", "/", "+"]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: ["10", "6", "9", "3", "+", "-11", " * ", "/", " * ", "17", "+", "5", "+"]</span><br><span class="line">输出: 22</span><br></pre></td></tr></tbody></table></figure><ul><li>思路分析</li></ul><p>遍历String[]  tokens ,如果tokens[i] 是数字，则直接压入栈中，</p><p>如果是“+”，“-”，“*”，“/”运算符，则从栈中弹出两个数字，然后再把计算结果压入栈中</p><p>最后返回栈中的数字，即为最后的运算结果</p><p>注意：1.如果是运算符是“-”，“/”,注意计算的顺序</p><p>2.String的比较要用equals()方法</p><p>3.char类型的比较可以使用“==”</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆波兰表达式求值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvaluateReversePolishNotation</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span></span>{</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) { <span class="comment">// 遍历tokens数组</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(tokens[i].equals(<span class="string">"+"</span>)  || tokens[i].equals(<span class="string">"-"</span>) || tokens[i].equals(<span class="string">"*"</span>) || tokens[i].equals(<span class="string">"/"</span>)){<span class="comment">//如果是加减乘除字符</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果是操作符，直接弹出两个数字，准备进行运算</span></span><br><span class="line">                <span class="keyword">int</span> num1 = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tokens[i].equals(<span class="string">"+"</span>)){</span><br><span class="line">                    stack.push(num1+num2);</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">"-"</span>)){</span><br><span class="line">                    stack.push(num2-num1);</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">"*"</span>)){</span><br><span class="line">                    stack.push(num1*num2);</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    stack.push(num2 / num1);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span>{  <span class="comment">//如果是数字的话，直接压入</span></span><br><span class="line">                stack.push(stoi(tokens[i]));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Integer <span class="title">stoi</span><span class="params">(String token)</span> </span>{ <span class="comment">// 将String转为Integer</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(token);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------main-----------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        EvaluateReversePolishNotation RPN = <span class="keyword">new</span> EvaluateReversePolishNotation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该算式转化为常见的中缀算术表达式为：</span></span><br><span class="line"><span class="comment">         *   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span></span><br><span class="line"><span class="comment">         * = ((10 * (6 / (12 * -11))) + 17) + 5</span></span><br><span class="line"><span class="comment">         * = ((10 * (6 / -132)) + 17) + 5</span></span><br><span class="line"><span class="comment">         * = ((10 * 0) + 17) + 5</span></span><br><span class="line"><span class="comment">         * = (0 + 17) + 5</span></span><br><span class="line"><span class="comment">         * = 17 + 5</span></span><br><span class="line"><span class="comment">         * = 22</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i = RPN.evalRPN(<span class="keyword">new</span> String[]{<span class="string">"10"</span>, <span class="string">"6"</span>, <span class="string">"9"</span>, <span class="string">"3"</span>, <span class="string">"+"</span>, <span class="string">"-11"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>, <span class="string">"*"</span>, <span class="string">"17"</span>, <span class="string">"+"</span>, <span class="string">"5"</span>, <span class="string">"+"</span>});</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span></span><br><span class="line">        <span class="keyword">int</span> i1 = RPN.evalRPN(<span class="keyword">new</span> String[]{<span class="string">"4"</span>, <span class="string">"13"</span>, <span class="string">"5"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>});</span><br><span class="line">        System.out.println(i1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用数组实现栈</title>
      <link href="/posts/c93a.html"/>
      <url>/posts/c93a.html</url>
      
        <content type="html"><![CDATA[<p>   本例子利用数组实现”栈”这种数据结构，算一个栈的入门案例</p><ul><li>栈的特点：先进后出，后进先出</li><li>在实现栈的弹栈，压栈的操作之前，要判断栈是否为空栈或满栈</li><li>数组的长度即为栈的容量</li></ul><hr><ul><li><p>写一个ArrayForStack类，在这个类中，实现栈的弹栈、压栈等方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayForStack</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayForStack</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造方法，利用构造方法给属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayForStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> top == maxSize-<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">if</span> (isFull()){</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> Exception(<span class="string">"栈已经满了，不能继续压栈了"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        array[++top] = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()){</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"栈已经空了，不能弹栈"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = array[top--];</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>编写一个测试类，测试栈的方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//栈的容量</span></span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        ArrayForStack stack = <span class="keyword">new</span> ArrayForStack(maxSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//压栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxSize; i++) {</span><br><span class="line">            stack.push(i);  <span class="comment">//依次压入0 1 2 3 4 5</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxSize; i++) {</span><br><span class="line">            System.out.println(stack.pop());   <span class="comment">//依次弹出5 4 3 2 1 0</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>接下来利用上面编写的ArrayForStack类，再实现一个<strong>回文字符串</strong>判断的例子</p><p>所谓的回文字符串即为：从左往右 与 从右往左 读这个字符串，结果是一样的</p><p>比如：”aba”就是一个回文串，而:”hello”,从右往左为”olleh”,则”hello”不是一个回文串</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPalindrome</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(detection(<span class="string">"abcdedcba"</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">detection</span><span class="params">(String str)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = str.length();</span><br><span class="line">        </span><br><span class="line">        ArrayForStack stack = <span class="keyword">new</span> ArrayForStack(length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            stack.push(str.charAt(i));</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        String newStr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()){</span><br><span class="line">                <span class="keyword">char</span> s = (<span class="keyword">char</span>)stack.pop();</span><br><span class="line">                newStr += s;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (str.equals(newStr)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github高效搜索项目</title>
      <link href="/posts/2a1b.html"/>
      <url>/posts/2a1b.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>利用项目名(仓库名)</p><p>例如<code>in:name spring boot</code></p></li></ul><ul><li><p>利用项目名+stars</p><p><code>in:name spring boot stars:&gt;1000</code></p></li></ul><ul><li><p>利用项目名+stars+forks</p><p><code>in:name spring boot stars:&gt;1000 forks:&gt;100</code></p></li></ul><ul><li><p>利用readme</p><p><code>in:readme springboot</code></p></li></ul><ul><li><p>利用readme+stars</p><p><code>in:readme springboot stars:&gt;1000</code></p></li></ul><ul><li><p>利用description</p><p><code>in:description 微服务</code></p></li></ul><ul><li><p>利用description + language</p><p><code>in:description 微服务 language:java</code>  </p></li></ul><ul><li><p>利用description + language+日期</p><p><code>in:description 微服务 language:java pushed:&gt;2019-9-9</code>  </p></li></ul><ul><li>点进去查看项目的：描述利用了那些技术，代码结构、最新push日期、火热程度等，查看项目的readme文档</li><li>把github用起来，多去github看开源项目</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> github搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git和github的使用</title>
      <link href="/posts/ec43.html"/>
      <url>/posts/ec43.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="1-Git常用命令"><a href="#1-Git常用命令" class="headerlink" title="1.Git常用命令"></a>1.Git常用命令</h2><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210730164403.png"></p><h2 id="2-分支的操作"><a href="#2-分支的操作" class="headerlink" title="2.分支的操作"></a>2.分支的操作</h2><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210730165654.png"></p><h2 id="3-远程仓库操作"><a href="#3-远程仓库操作" class="headerlink" title="3.远程仓库操作"></a>3.远程仓库操作</h2><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210730190522.png"></p><h2 id="4-IDEA集成git、github"><a href="#4-IDEA集成git、github" class="headerlink" title="4.IDEA集成git、github"></a>4.IDEA集成git、github</h2><ul><li>1.确保idea已经集成了git和github</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731104620.png" alt="git"></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731104957.png" alt="github"></p><ul><li>2.回到idea主界面，创建一个git repository</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731105254.png" alt="创建git仓库"></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731105926.png"></p><ul><li>3.将代码加入暂存区</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731105744.png"></p><ul><li><p>代码加入暂存区后，文件名由红色变为蓝色</p></li><li><p>4.将代码提交至本地库</p></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731111519.png" alt="代码提交本地库"></p><ul><li>代码提交至本地库后，文件名由蓝色变为正常的白色</li></ul><ul><li>5.查看git的log和master信息</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731113511.png"></p><ul><li><ul><li>切换version</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731113939.png" alt="切换version"></li><li>创建分支</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731114259.png"></li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731114502.png" alt="创建一个hot_fix分支"></li></ul></li></ul><ul><li><p>6.合并分支</p></li><li><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731114742.png"></p></li><li><p>在hot_fix分支下，加一行代码，并提交至本地库</p></li></ul><ul><li>注意：master分支想要合并hot_fix分支，必须在master分支下merge</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731120213.png"></li></ul><ul><li>已经切换至master</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731115506.png"></p><ul><li>开始合并</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731120533.png"></li></ul><ul><li>成功合并</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731120755.png" alt="image-20210731120755672"></li></ul><p>备注：以上演示的为无冲突合并，如果遇到冲突合并(简单理解为：对代码做了不同的修改)，需要进行手动选择代码，然后合并</p><hr><ul><li><p>7.将代码推送至远程github仓库</p><ul><li>7.1 使用ssh免密登陆<ul><li> 进入C:/Users/Administrator/.ssh文件夹，右键选择“Git Bash Here ”</li><li>在命令行输入<code>ssh-keygen -t rsa -C 邮箱  </code>，连续三次回车(其中有一次问你，要不要覆盖文件)</li><li>然后输入<code>cat id_rsa.pub  </code>,得到其文件内容，如下图</li></ul></li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731135430.png"></li></ul></li><li><ul><li><ul><li>复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys →New SSH key</li><li>新建一个SSH key</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731140056.png"></li></ul></li></ul></li></ul><ul><li><ul><li>7.2新建一个远程github仓库，用来储存来自本地仓库的代码，如下图</li><li><ul><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731140751.png" alt="方式一，新建github仓库"></li></ul></li></ul></li><li><ul><li><ul><li>方式二，新建github仓库</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731141204.png" alt="idea中选择share project on github"></li></ul></li></ul></li><li><ul><li><ul><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731141455.png" alt="分享仓库到github"></li></ul></li></ul></li><li><ul><li>7.3push代码到github仓库</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731142219.png" alt="复制仓库的ssh链接"></li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731142602.png" alt="准备push代码到github仓库"></li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731142837.png" alt="push代码到github仓库"></li></ul></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731143015.png" alt="push成功后的github仓库"></p><ul><li><ul><li><p>push代码的重要提示</p><p>注意： push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，<br>push 的操作是会被拒绝的。也就是说， 要想 push 成功，一定要保证本地库的版本要比远程<br>库的版本高！ 因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地<br>代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地<br>代码更新到最新以后，然后再修改，提交，推送！  </p></li></ul></li></ul><ul><li>8 pull 拉取远程库到本地库  <ul><li>首先更新一下github仓库的代码，以示本地和远程的区别</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731145656.png" alt="本地远程比较"></li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731143931.png" alt="pull后的本地代码"></li></ul></li></ul><ul><li>9.克隆代码到本地，并利用idea打开<ul><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731144907.png" alt="克隆代码到本地"></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot集成mybatis-plus</title>
      <link href="/posts/667f.html"/>
      <url>/posts/667f.html</url>
      
        <content type="html"><![CDATA[<ul><li>本博客基于springboot-web项目，集成thymeleaf，和mybatis-plus可以实现数据的CRUD和分页显示数据功能</li></ul><h1 id="案例一：实现数据的CRUD"><a href="#案例一：实现数据的CRUD" class="headerlink" title="案例一：实现数据的CRUD"></a>案例一：实现数据的CRUD</h1><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210728140408.png" alt="代码的结构"></p><h2 id="依赖及配置"><a href="#依赖及配置" class="headerlink" title="依赖及配置"></a>依赖及配置</h2><ul><li>1.新建一个springboot-web项目，并选中thymeleaf模板引擎</li><li>2.加入依赖</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>3.配置mysql的账号密码</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=mysql密码</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="代码详情"><a href="#代码详情" class="headerlink" title="代码详情"></a>代码详情</h2><ul><li><p>1.控制层代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动注入业务层的StudentService</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/queryAll")</span>   <span class="comment">//请求路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryAll</span><span class="params">(Model model)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用业务层的方法，查询所有学生</span></span><br><span class="line">        List&lt;Student&gt; students = studentService.list();</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">"students"</span>,students);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将查询结果放入request作用域，并返回到视图层</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"mybatis-plus"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>2.业务层代码(包括一个接口和实现类)</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">Student</span>&gt; </span>{</span><br><span class="line">    <span class="comment">//IService&lt;T&gt; 中的 T 是实体</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>IService为mybatis-plus提供的接口，里面提供了CRUD的基本方法,我们的业务层接口需要实现IService这个接口</p><ul><li>3.业务接口实现类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">StudentMapper</span>, <span class="title">Student</span>&gt; <span class="keyword">implements</span> <span class="title">StudentService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; 中的泛型：M 是 mapper 对象，T 是实体</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>StudentServiceImpl 继承了ServiceImpl，而ServiceImpl是IService 实现类，它提供了IService中方法的具体实现。我们写的业务接口实现类需要继承ServiceImpl这个类，并且要实现我们自己写的StudentService这个接口</p><p>下面给出ServiceImpl类的部分代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IService 实现类（ 泛型：M 是 mapper 对象，T 是实体 ）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>{}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>4.持久层代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Student</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>StudentMapper继承了 BaseMapper<t>这一接口，当我们编写的Mapper接口 继承该接口后，无需编写 mapper.xml 文件，即可获得CRUD功能</t></p><p>说明：除了在该类的上面添加@Mapper,注明这是一个持久层之外，还可以在程序的主入口添加@MapperScan注解(两个注解选择一个使用即可)</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210728143021.png"></p></li></ul><ul><li><p>5.实体类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName("t_student")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    setter and getter</span><br><span class="line">        </span><br><span class="line">    toString</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>@TableName(“t_student”)由mybatis-plus提供，作用使该实体类与对应的数据库中的表名对应，例如类Student&lt;===&gt;表t_student</p><p>@TableField(exist = false)由mybatis-plus提供,作用是标注出，数据库中的表不存在该字段</p><ul><li>5.视图层的代码(由控制层转到视图层mybatis-plus.html)</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>查询所有学生<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"student:${students}"</span>&gt;</span>   <span class="comment">&lt;!--thymeleaf循环一个list--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[${student.id}]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span>       <span class="comment">&lt;!--thymeleaf的行内写法，取出相应的变量--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[${student.name}]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[${student.age}]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>6查询结果</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210728144549.png"></p></li></ul><p>与数据库中的数据一致</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210728144649.png"></p><h1 id="案例二：实现分页数据的展示"><a href="#案例二：实现分页数据的展示" class="headerlink" title="案例二：实现分页数据的展示"></a>案例二：实现分页数据的展示</h1><ul><li>数据的分页展示，在案例一的基础上修改而来</li></ul><h2 id="分页功能具体实现"><a href="#分页功能具体实现" class="headerlink" title="分页功能具体实现"></a>分页功能具体实现</h2><ul><li><p>1.新建一个配置类，用来加载分页插件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"加载分页插件"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li>2.修改控制层代码</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/queryAll")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryAll</span><span class="params">(<span class="meta">@RequestParam(value = "pn",defaultValue = "1")</span> Integer pn,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Model model)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分页查询，pn表示当前页，6表示每页几条数据</span></span><br><span class="line">        Page&lt;Student&gt; studentPage = <span class="keyword">new</span> Page&lt;&gt;(pn,<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//分页查询结果</span></span><br><span class="line">        Page&lt;Student&gt; page = studentService.page(studentPage, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        page.getCurrent(); <span class="comment">//获取当前页</span></span><br><span class="line">        page.getPages();   <span class="comment">//获取总的页数</span></span><br><span class="line">        page.getTotal();   <span class="comment">//获取总记录数</span></span><br><span class="line">        </span><br><span class="line">        model.addAttribute(<span class="string">"page"</span>,page);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"mybatis-plus"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><ul><li>访问路径为<code>“/queryAll”</code>,请求参数为<code>pn</code>,表示当前页，默认为1</li><li>调用<code>studentService.page()</code>,即可得到Page对象，其内部属性，就是我们想要的与分页功能相关的数据</li><li>将page放入request作用域</li></ul></li></ul><ul><li>3.修改视图显示的代码</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>查询所有学生<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"student:${page.records}"</span>&gt;</span> <span class="comment">&lt;!--thymeleaf循环一个list--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[${student.id}]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span>      <span class="comment">&lt;!--thymeleaf的行内写法，取出相应的变量--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[${student.name}]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[${student.age}]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上方展示的student详情的list集合，必须从page.records中取--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--#########################以下内容与分页功能相关###############################--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[[${page.current}]]为thymeleaf的写法，可以取出request域的变量--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--page.current、page.pages、page.total都是放在request作用域中的变量page的属性}--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>当前第 [[${page.current}]] 页 总计 [[${page.pages}]] 页 共 [[${page.total}]] 条记录<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--#numbers.sequence(1,page.pages)，该表达式是thymeleaf的写法。</span></span><br><span class="line"><span class="comment">            表示可以生成一个从"1"到"page.pages"的序列,然后用thymeleaf的foreach循环，就可以得到页码num了--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"num:${#numbers.sequence(1,page.pages)}"</span> &gt;</span></span><br><span class="line">                <span class="comment">&lt;!--下面的写法为thymeleaf的超链接写法</span></span><br><span class="line"><span class="comment">                    [[${num}]]用来显示页码数</span></span><br><span class="line"><span class="comment">                    @{/queryAll(pn=${num})}表示超链接的链接地址,(pn=${num})表示请求参数</span></span><br><span class="line"><span class="comment">                    @{/queryAll(pn=${num})}等价于@{/queryAll?pn=num}</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@{/queryAll(pn=${num})}"</span>&gt;</span>[[${num}]]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>前端分页功能代码的说明见注释</li></ul><hr><ul><li><p>结果展示</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210728190430.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatis-plus </tag>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot定制化组件的方式</title>
      <link href="/posts/4e7c.html"/>
      <url>/posts/4e7c.html</url>
      
        <content type="html"><![CDATA[<h2 id="定制化组件的常见方式"><a href="#定制化组件的常见方式" class="headerlink" title="定制化组件的常见方式"></a>定制化组件的常见方式</h2><ul><li><p>修改配置文件；</p></li><li><p><strong>xxxxxCustomizer；</strong></p></li><li><p><strong>编写自定义的配置类   xxxConfiguration；+</strong> <strong>@Bean替换、增加容器中默认组件；视图解析器</strong> </p></li><li><p><strong>Web应用 编写一个配置类实现</strong> <strong>WebMvcConfigurer 即可定制化web功能；(+ @Bean给容器中再扩展一些组件,可选的)</strong></p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminWebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>{}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>@EnableWebMvc + WebMvcConfigurer —— @Bean  可以全面接管SpringMVC，所有规则全部自己重新配置； </p><p>实现定制和扩展功能</p><ul><li><p>原理</p></li><li><p> 1、WebMvcAutoConfiguration  默认的SpringMVC的自动配置功能类。静态资源、欢迎页…..</p></li><li><p>2、一旦使用 @EnableWebMvc 会 @Import(DelegatingWebMvcConfiguration.<strong>class</strong>)</p></li><li><p>3、<strong>DelegatingWebMvcConfiguration</strong> 的 作用，只保证SpringMVC最基本的使用</p><ul><li><p>把所有系统中的 WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer  合起来一起生效</p></li><li><p>自动配置了一些非常底层的组件。<strong>RequestMappingHandlerMapping</strong>、这些组件依赖的组件都是从容器中获取</p><ul><li> <strong>public class</strong> DelegatingWebMvcConfiguration <strong>extends</strong> <strong>WebMvcConfigurationSupport</strong></li></ul></li></ul></li><li><p>4、<strong>WebMvcAutoConfiguration</strong> 里面的配置要能生效 必须  @ConditionalOnMissingBean(<strong>WebMvcConfigurationSupport</strong>.<strong>class</strong>)</p></li><li><p>5、@EnableWebMvc  导致了 <strong>WebMvcAutoConfiguration  没有生效。</strong></p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> springboot定制化组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot文件上传</title>
      <link href="/posts/c59d.html"/>
      <url>/posts/c59d.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>springboot中文件上传，可以将上传的文件保存到本地，或者保存到文件服务器，OSS</li><li>下面通过一个springboot-thymeleaf项目，演示这一过程</li></ul><h2 id="项目流程"><a href="#项目流程" class="headerlink" title="项目流程"></a>项目流程</h2><ul><li>1.浏览器地址栏访问：http:localhost:8080/,跳转到templates/file_form.html</li><li>2.在file_form.html页面，选择需要上传的文件(支持单个、多个文件上传，文件的最大值在配置文件中指定)，提交后转到控制层的upload方法</li><li>3.在upload方法中，上传的文件被保存到本地</li></ul><h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><ul><li>项目文件结构</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210727160921.png" alt="image-20210727160915269"></p><ul><li><p>控制层代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"file_form"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("/upload")</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(<span class="meta">@RequestPart("picture")</span> MultipartFile picture,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="meta">@RequestPart("photos")</span> MultipartFile[] photos)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="keyword">if</span>(!picture.isEmpty()){</span><br><span class="line">            String originalFilename = picture.getOriginalFilename();</span><br><span class="line">            <span class="comment">//保存文件到本地</span></span><br><span class="line">            picture.transferTo(<span class="keyword">new</span> File(<span class="string">"E:\\test\\"</span>+originalFilename));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (photos.length &gt; <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">for</span> (MultipartFile photo : photos) {</span><br><span class="line">                <span class="keyword">if</span> (!photo.isEmpty()){</span><br><span class="line">                    String originalFilename = photo.getOriginalFilename();</span><br><span class="line">                    <span class="comment">//保存文件到本地</span></span><br><span class="line">                    photo.transferTo(<span class="keyword">new</span> File(<span class="string">"E:\\test\\"</span>+originalFilename));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"文件上传成功"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>前端的file_form.html页面</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">th:action</span>=<span class="string">"@{/upload}"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> &gt;</span></span><br><span class="line">  单个文件:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"picture"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  多个文件:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"photos"</span> <span class="attr">multiple</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>项目的配置文件</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上传总文件的最大值</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.max-request-size</span>=<span class="string">100MB</span></span><br><span class="line"><span class="comment"># 单个文件的最大值</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.max-file-size</span>=<span class="string">10MB</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>启动程序</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootFileUploadApplication</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(SpringbootFileUploadApplication.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interceptor拦截器的使用</title>
      <link href="/posts/ce45.html"/>
      <url>/posts/ce45.html</url>
      
        <content type="html"><![CDATA[<h1 id="springboot项目中拦截器的使用"><a href="#springboot项目中拦截器的使用" class="headerlink" title="springboot项目中拦截器的使用"></a>springboot项目中拦截器的使用</h1><ul><li>1.编写一个拦截器实现HandlerInterceptor接口</li><li>2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）</li><li>3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】</li></ul><hr><h2 id="1-实现HandlerInterceptor接口"><a href="#1-实现HandlerInterceptor接口" class="headerlink" title="1.实现HandlerInterceptor接口"></a>1.实现HandlerInterceptor接口</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标方法执行之前，进行拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"preHandle方法执行了{}"</span>,request.getRequestURI());</span><br><span class="line">        String userName = (String) request.getSession().getAttribute(<span class="string">"userName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(userName != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/"</span>).forward(request,response);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标方法执行完成之后</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"postHandle方法执行了{}"</span>,modelAndView);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//页面渲染之后</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"afterCompletion方法执行了"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-拦截器注册到容器中"><a href="#2-拦截器注册到容器中" class="headerlink" title="2.拦截器注册到容器中"></a>2.拦截器注册到容器中</h2><ul><li><p>实现WebMvcConfigurer的addInterceptors</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>{</span><br><span class="line"></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>)              <span class="comment">//需要拦截的资源</span></span><br><span class="line">                .excludePathPatterns(<span class="string">"/"</span>,<span class="string">"/login"</span>);  <span class="comment">//需要放行的资源</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="3-拦截器原理"><a href="#3-拦截器原理" class="headerlink" title="3.拦截器原理"></a>3.拦截器原理</h2><p>1、根据当前请求，找到<strong>HandlerExecutionChain【</strong>可以处理请求的handler以及handler的所有 拦截器】</p><p>2、先来<strong>顺序执行</strong> 所有拦截器的 preHandle方法</p><ul><li>1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle</li><li>2、如果当前拦截器返回为false。直接    倒序执行所有已经执行了的拦截器的  afterCompletion；</li></ul><p><strong>3、如果任何一个拦截器返回false。直接跳出不执行目标方法</strong></p><p><strong>4、所有拦截器的prehandler都返回true，才执行目标方法</strong></p><p><strong>5、倒序执行所有拦截器的postHandle方法。</strong></p><p><strong>6、前面的步骤有任何异常都会直接倒序触发</strong> afterCompletion</p><p>7、页面成功渲染完成以后，也会倒序触发 afterCompletion</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210726223649.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Interceptor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot集成websocket实现聊天室的index.jsp代码</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight jsp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;script src="${pageContext.request.contextPath}/js/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;title&gt;SpringBoot+WebSocket+JSP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body style=<span class="string">"margin: 45px;"</span>&gt;</span><br><span class="line">    &lt;h4&gt;在线聊天室&lt;/h4&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">        &lt;label for="content"&gt;&lt;/label&gt;</span><br><span class="line">        &lt;textarea id="content" readonly="readonly" cols="80" rows="15"&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span> style=<span class="string">"margin-top: 8px"</span>&gt;</span><br><span class="line">        &lt;textarea id="message" cols="80" rows="5" placeholder="请输入消息"&gt;&lt;/textarea&gt;</span><br><span class="line">        &lt;div style=<span class="string">"margin-top: 10px"</span>&gt;</span><br><span class="line">            &lt;button id="toSend" class="btn btn-info"&gt;发送&lt;/button&gt;</span><br><span class="line">            &lt;button id="user_exit" class="btn btn-danger"&gt;离开&lt;/button&gt;</span><br><span class="line">            &lt;input id=<span class="string">"username"</span> value=<span class="string">"${username}"</span> style=<span class="string">"display: none"</span>&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        $(function () {</span><br><span class="line">            <span class="keyword">var</span> ws;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"WebSocket"</span> in window) {</span><br><span class="line">                <span class="keyword">var</span> baseUrl = <span class="string">'ws://localhost:8080/websocket/'</span>;</span><br><span class="line">                <span class="keyword">var</span> userName = $(<span class="string">'#username'</span>).val();</span><br><span class="line">                ws = <span class="keyword">new</span> WebSocket(baseUrl + userName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 连通之后的回调事件，建立连接</span></span><br><span class="line">                ws.onopen = function () {</span><br><span class="line">                    console.log(<span class="string">"建立 websocket 连接..."</span>);</span><br><span class="line">                };</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收后台服务端的消息</span></span><br><span class="line">                ws.onmessage = function (event) {</span><br><span class="line">                    $(<span class="string">'#content'</span>).append(event.data + <span class="string">'\n\n'</span>);</span><br><span class="line">                    console.log(<span class="string">"接收到服务端发送的消息..."</span> + event.data + <span class="string">'\n'</span>);</span><br><span class="line">                };</span><br><span class="line"></span><br><span class="line">                ws.onerror = function (event) {</span><br><span class="line">                    console.log(<span class="string">"websocket发生错误..."</span> + event + <span class="string">'\n'</span>);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 连接关闭的回调事件</span></span><br><span class="line">                ws.onclose = function () {</span><br><span class="line">                    $(<span class="string">'#content'</span>).append(<span class="string">'['</span> + userName + <span class="string">'] 已离开!'</span>);</span><br><span class="line">                    console.log(<span class="string">"关闭 websocket 连接..."</span>);</span><br><span class="line">                };</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 浏览器不支持 WebSocket</span></span><br><span class="line">                alert(<span class="string">"您的浏览器不支持WebSocket!"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 客户端发送消息到服务器</span></span><br><span class="line">            $(<span class="string">'#toSend'</span>).click(function () {</span><br><span class="line">                sendMsg();</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            $(document).keyup(function (event) {</span><br><span class="line">                <span class="comment">// 回车键事件</span></span><br><span class="line">                <span class="keyword">if</span> (event.keyCode == <span class="number">13</span>) {</span><br><span class="line">                    sendMsg();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="function">function <span class="title">sendMsg</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="comment">//websocket发送消息</span></span><br><span class="line">                ws.send($(<span class="string">'#message'</span>).val());</span><br><span class="line">                $(<span class="string">'#message'</span>).val(<span class="string">""</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 退出</span></span><br><span class="line">            $(<span class="string">'#user_exit'</span>).click(function () {</span><br><span class="line">                <span class="keyword">if</span> (ws) {</span><br><span class="line">                    ws.close();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--此页面的源代码即为index.jsp的代码--%&gt;</span><br><span class="line">&lt;%--点击右键即可查看网页源代码--%&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot集成websocket实现聊天室</title>
      <link href="/posts/3a35.html"/>
      <url>/posts/3a35.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-websocket简介"><a href="#1-websocket简介" class="headerlink" title="1.websocket简介"></a>1.websocket简介</h1><h2 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h2><p>WebSocket协议是由HTML5定义的，基于TCP协议实现的一种网络协议，通过该协议服务器可以主动向客户端发送信息；</p><p>WebSocket 协议在2008年诞生，2011年成为W3C国际标准；我们已经有了 HTTP 协议，为什么出现一个websocket协议？</p><p>http协议是短连接，因为请求之后，都会关闭连接，下次重新请求数据，需要再次打开链接；WebSocket协议是一种长连接，只需要通过一次请求来初始化连接，然后所有的请求和响应都是通过这个TCP连接进行通讯； 所以HTTP协议通信只能是客户端向服务器发出请求，服务器返回响应结果，HTTP 协议做不到服务器主动向客户端推送信息，而websocket能实现服务器和客户端全双工通信；</p><ul><li>何谓全双工</li></ul><p>信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工，信息能够同时双向传送则称为全双工；</p><ul><li>基本实现原理</li></ul><p>WebSocket协议基于TCP协议实现，客户端和服务器只需要做一个握手的动作之后，形成了一条基于客户端和服务器之间的快速通道，之后客户端与服务端之间便可以进行多次数据帧双向传输；这样实现的目的是客户端和服务器进行频繁双向通信时，可以使服务器避免频繁创建HTTP连接，节约资源，提高工作效率和资源利用率。</p><h2 id="传统Web推送实现"><a href="#传统Web推送实现" class="headerlink" title="传统Web推送实现"></a>传统Web推送实现</h2><p>​        在没有WebSocket协议之前，服务器如何向浏览器端推送消息？通常的实现方式是在页面通过Ajax定时轮询，比如每隔1秒中向服务器发送一次HTTP请求，询问服务器是否有新消息，服务器返回结果；这种形式缺点很明显，浏览器需要不断的向服务器发出HTTP请求，而HTTP请求包含较长的头部，有效信息相对较少，反复的无效请求占用了大量的带宽和 CPU 资源，造成很大的浪费，所以，WebSocket 应运而生；HTML5定义的WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯；</p><p>WebSocket协议本质上是一个基于TCP的协议，因此与HTTP协议没有什么关系；</p><h2 id="WebSocket的特点"><a href="#WebSocket的特点" class="headerlink" title="WebSocket的特点"></a>WebSocket的特点</h2><p>全双工通信，客户端和服务器可以双向平等通信；</p><p>建立在TCP协议之上，服务器端的实现比较容易；</p><p>数据格式比较轻量，性能开销小，通信高效；</p><p>可以发送文本，也可以发送二进制数据；</p><p>通信具有更强的实时性；</p><p>协议标识符是ws，服务器地址就是：ws://<a href="http://www.abc.com/some/path">www.abc.com/some/path</a></p><p>http协议： http://</p><h2 id="websocket的业务场景"><a href="#websocket的业务场景" class="headerlink" title="websocket的业务场景"></a>websocket的业务场景</h2><p>WebSocket聊天室；</p><p>股票实时价格显示等应用；</p><p>即时通讯、游戏、可视化大屏展示等领域；</p><p>企业内部管理通讯等功能，主要通讯协议websocket；</p><p>web网页聊天、客服系统实现；</p><p>系统提醒、用户上下线提醒、客户端同步，实时数据更新，多屏幕同步，用户在线状态，消息通知，扫描二维码登录/二维码支付，弹幕、各类信息提醒，在线选座，实时监控大屏等等；</p><br><h2 id="Java中的WebSocket-API"><a href="#Java中的WebSocket-API" class="headerlink" title="Java中的WebSocket API"></a>Java中的WebSocket API</h2><p>在Java EE 7中Java语言开始支持websocket协议，Java EE 7中定义了一套Websocket API规范，也就是一系列接口，没有实现，位于包javax.websocket下，包含客户端API和服务端API，WebSocket的Java API 只是规范，具体实现需要web容器（比如tomcat就实现了Java websocket api）、Java EE服务器或者框架提供；</p><ul><li><p>在java中服务端的实现</p><p>1、Tomcat：java中的websocket实现，需要tomcat 7.0.47+以上才支持，</p><p>Java EE7的支持；</p><p>2、Spring的websocket，需要Spring 4.x，所以springboot也可以用；</p></li></ul><h1 id="2-Websocket开发相关注解及API方法"><a href="#2-Websocket开发相关注解及API方法" class="headerlink" title="2.Websocket开发相关注解及API方法"></a>2.Websocket开发相关注解及API方法</h1><h2 id="websocket注解"><a href="#websocket注解" class="headerlink" title="websocket注解"></a>websocket注解</h2><ul><li><p>@ServerEndpoint(“/websocket/{uid}”)</p><p>申明这是一个websocket服务；</p><p>需要指定访问该服务的地址，在地址中可以指定参数，需要通过{}进行占位；</p></li><li><p>@OnOpen</p><p>用法：<code>public void onOpen(Session session, @PathParam("uid") String uid) throws IOException{}</code></p><p>该方法将在建立连接后执行，会传入session对象，就是客户端与服务端建立的长连接通道，通过@PathParam获取url中声明的参数；</p></li><li><p>@OnClose</p><p>用法：<code>public void onClose() {}</code></p><p>该方法是在连接关闭后执行；</p></li><li><p>@OnMessage</p><p>用法：<code>public void onMessage(String message, Session session) throws IOException {}</code></p><p>该方法用于接收客户端发送的消息；</p><p>message：发来的消息数据；</p><p>session：会话对象（也是长连接通道）；</p><p>发送消息到客户端；</p><p>用法：<code>session.getBasicRemote().sendText("hello,websocket.");</code></p><p>通过session进行消息发送；</p></li></ul><h2 id="前端技术对websocket的支持"><a href="#前端技术对websocket的支持" class="headerlink" title="前端技术对websocket的支持"></a>前端技术对websocket的支持</h2><p>Websocket是html5规范，主流浏览器都支持；（某些老浏览器不支持）</p><p>jQuery、vueJS、React JS、angularjs等都可以支持webscoket对象；</p><p>底层是javascript支持的一个webscoket的js对象，通过这个对象可以建立websocket的连接：<em>ws://localhost:8080/websocket/12345</em></p><hr><p>WebSocket有很多优点，弥补了http协议的不足，但是如果服务端维护很多长连接也是很耗费资源的，服务器集群带来了复杂性以及存在老版本浏览器兼容性问题，各大厂目前大多数还是基于轮询的方式实现的，比如：扫码登录、支付成功通知、秒杀成功通知等；</p><p>在秒杀场景中，用轮询即可，前端轮询一般不可能穿透到后端数据库查询，一般是采用高性能的缓存标记来判定秒杀是否成功，相对于websocket长连接以及其不确定因素，轮询依然是相对比较合适的方案；</p><p>Websocket各浏览器的支持情况：</p><p><a href="https://caniuse.com/#search=websocket">https://caniuse.com/#search=websocket</a></p><h1 id="3-springboot集成WebSocket实现多人聊天室"><a href="#3-springboot集成WebSocket实现多人聊天室" class="headerlink" title="3.springboot集成WebSocket实现多人聊天室"></a>3.springboot集成WebSocket实现多人聊天室</h1><ul><li><p>项目代码结构分布</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210725124045.png"></p><ul><li><p>pom文件依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--此项目的GAV坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>041-springboot-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--springboot web项目的起步依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--spring-boot-starter-websocket--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--lombok,需要在IDEA中安装lombok插件才能使用该依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--引入Spring Boot内嵌的Tomcat对JSP的解析包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--热部署插件(该依赖不是必选项)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--src/main/java下的.xml配置文件编译到target下去--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--src/main/resources下的配置文件编译到target下去--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--src/main/webapp下的jsp页面编译到META-INF/resources下才能访问--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF/resources<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><ul><li><p>项目的主配置文件application.properties</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#设置jsp文件的前缀和后缀</span><br><span class="line">spring.mvc.view.prefix=/</span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></tbody></table></figure></li><li><p>index.jsp文件详情</p><figure class="highlight jsp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo博客不能正常显示jsp格式的代码</span><br><span class="line">代码详情见本站的博文：<span class="string">"springboot集成websocket实现聊天室的index-jsp代码"</span>，</span><br><span class="line">进入该博文页面后，点击右键即可查看index.jsp的源代码</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>还需要一个jquery.min.js文件，可以去网上下载</li></ul></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210725132514.png"></p><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><ul><li><p>后端代码结构</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210725133127.png"></p></li><li><p>首先是endpoint包下的chatServerEndpoint.java 文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.PathParam;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * 1、<span class="doctag">@ServerEndpoint</span>注解中指定WebSocket协议的地址；</span></span><br><span class="line"><span class="comment"> * 2、<span class="doctag">@OnOpen</span>、<span class="doctag">@OnMessage</span>、<span class="doctag">@OnClose</span>、<span class="doctag">@OnError</span>注解与WebSocket中监听事件对应</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span> <span class="comment">//lombok jar包，帮我们自动生成一些代码：@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint("/websocket/{username}")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServerEndpoint</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立时触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openSession</span><span class="params">(<span class="meta">@PathParam("username")</span> String username, Session session)</span> </span>{</span><br><span class="line">        log.info(<span class="string">"用户{}登录"</span>, username);</span><br><span class="line">        String message = <span class="string">"用户["</span> + username + <span class="string">"] 已进入聊天室！"</span>;</span><br><span class="line">        <span class="comment">// 发送登录消息给其他人</span></span><br><span class="line">        WebSocketUtils.sendMessageAll(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前在线人数，发给自己</span></span><br><span class="line">        String onlineInfo = WebSocketUtils.getOnlineInfo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        WebSocketUtils.sendMessage(session, onlineInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加自己到map中</span></span><br><span class="line">        WebSocketUtils.CLIENTS.put(username, session);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端接收服务端数据时触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="meta">@PathParam("username")</span> String username, String message)</span> </span>{</span><br><span class="line">        log.info(<span class="string">"发送消息：{}, {}"</span>, username, message);</span><br><span class="line">        <span class="comment">//广播，把消息同步给其他客户端</span></span><br><span class="line">        WebSocketUtils.sendMessageAll(<span class="string">"["</span> + username + <span class="string">"] : "</span> + message);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭时触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(<span class="meta">@PathParam("username")</span> String username, Session session)</span> </span>{</span><br><span class="line">        <span class="comment">// 当前的Session移除某个用户</span></span><br><span class="line">        WebSocketUtils.CLIENTS.remove(username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 离开消息通知所有人</span></span><br><span class="line">        WebSocketUtils.sendMessageAll(<span class="string">"["</span> + username + <span class="string">"] 已离开！"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//关闭WebSocket Session会话</span></span><br><span class="line">            session.close();</span><br><span class="line">            log.info(<span class="string">"{} 已退出, onclose"</span>, username);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">"onClose error"</span>, e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通信发生错误时触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable throwable)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//关闭WebSocket Session会话</span></span><br><span class="line">            session.close();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">"onError Exception"</span>, e);</span><br><span class="line">        }</span><br><span class="line">        log.info(<span class="string">"Throwable msg "</span> + throwable.getMessage());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>endpoint包下的WebSocketUtils.java 文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.RemoteEndpoint;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketUtils</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WebSocketUtils.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储WebSocket session</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 用户名为key，WebSocket Session对象为value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Session&gt; CLIENTS = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用连接发送数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 用户session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 发送内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Session session, String message)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> RemoteEndpoint.Basic basic = session.getBasicRemote();</span><br><span class="line">        <span class="keyword">if</span> (basic == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//发送</span></span><br><span class="line">            basic.sendText(message);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(<span class="string">"sendMessage IOException "</span>, e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息给其他所有人</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessageAll</span><span class="params">(String message)</span> </span>{</span><br><span class="line">        CLIENTS.forEach((sessionId, session) -&gt; sendMessage(session, message));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有在线用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getOnlineInfo</span><span class="params">()</span> </span>{</span><br><span class="line">        Set&lt;String&gt; userNames = CLIENTS.keySet();</span><br><span class="line">        <span class="keyword">if</span> (userNames.size() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"当前无人在线..."</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> CLIENTS.keySet().toString() + <span class="string">"在线"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>接着是controller包下的ChatController.java文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger idProducer = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span> </span>{</span><br><span class="line">        model.addAttribute(<span class="string">"username"</span>,<span class="string">"user"</span> + idProducer.getAndIncrement());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>项目启动后，访问根路径，转发到index.jsp</p></li></ul><ul><li><p>最后是config包下的WebSocketConfig.java文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointExporter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableWebSocket</span> <span class="comment">//启用WebSocket支持</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//表示配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置ServerEndpointExporter的bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 该Bean会自动注册使用了<span class="doctag">@ServerEndpoint</span>注解声明的Websocket endpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>最后的最后，是程序的主入口Application.java，用来启动整个项目</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><hr><h2 id="项目启动运行"><a href="#项目启动运行" class="headerlink" title="项目启动运行"></a>项目启动运行</h2><ul><li>在浏览器地址栏输入<code>http://localhost:8080/</code></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210725134704.png"></p><ul><li><p>示例如下</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210725135015.png"></p></li><li><p>在另一个浏览器地址栏(或者相同浏览器新建一个窗口)输入<a href="http://localhost:8080/%EF%BC%8C%E5%8D%B3%E5%8F%AF%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9">http://localhost:8080/，即可实现多人聊天</a></p></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210725135417.png"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之-MatrixVariable注解使用</title>
      <link href="/posts/80aa.html"/>
      <url>/posts/80aa.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​        根据 URI 规范 RFC 3986 中 URL 的定义，路径片段中可以可以包含键值对。规范中没对对应的术语。一般 “URL 路径参数” 可以被应用，尽管更加独特的 “矩阵 URI” 也经常被使用并且相当有名。在 Spring MVC 它被称为矩阵变量。</p><p>    矩阵变量可以出现在任何路径片段中，每一个矩阵变量都用分号（;）隔开。比如 <code>/cars;color=red;year=2012</code>。多个值可以用逗号隔开，比如<code>color=red,green,blue</code>，或者分开写 <code>color=red;color=green;color=blue</code>。</p><p>    如果你希望一个 URL 包含矩阵变量，那么请求映射模式必须用 URI 模板来表示这些矩阵变量。这样的话，不管矩阵变量顺序如何，都能够保证请求可以正确的匹配。</p><p>Springboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。</p><hr><p>下面用一个springboot项目演示 @MatrixVariable的具体使用方法</p><hr><h1 id="1-前端代码部分"><a href="#1-前端代码部分" class="headerlink" title="1.前端代码部分"></a>1.前端代码部分</h1><ul><li><p>项目的结构分布</p><p> <img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210724221425.png" alt="Snipaste_2021-07-24_21-52-52"></p></li><li><p>前端index.html的代码如下</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>springboot注解之@MatrixVariable<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>springboot注解之@MatrixVariable<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/car/sell;num=10;brand=BYD,AuDi"</span>&gt;</span>@MatrixVariable（矩阵变量）/car/{sell}<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/boss/1;age=20/2;age=30"</span>&gt;</span>@MatrixVariable（矩阵变量）/boss/{bossId}/{empId}<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><p>​    </p><p>1.在<code>/car/sell</code>路径下访问，请求参数为num和brand</p><p>2.在<code>/boss/{bossId}/{empId}</code>路径下访问.请求参数age=20表示<code>/boss/bossId?age=20</code>.</p><p>而请求参数age=30则表示访问路径<code>/boss/bossId/empId?age=30</code></p><h1 id="2-后端代码部分"><a href="#2-后端代码部分" class="headerlink" title="2.后端代码部分"></a>2.后端代码部分</h1><h2 id="2-1-配置类MyConfig-java"><a href="#2-1-配置类MyConfig-java" class="headerlink" title="2.1 配置类MyConfig.java"></a>2.1 配置类MyConfig.java</h2><p>Springboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.springboot.conf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.PathMatchConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.util.UrlPathHelper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>{</span><br><span class="line"></span><br><span class="line">        UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">        urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);</span><br><span class="line">        configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-控制器AnnotationController-java"><a href="#2-2-控制器AnnotationController-java" class="headerlink" title="2.2 控制器AnnotationController.java"></a>2.2 控制器AnnotationController.java</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.springboot.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/car/{path}")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getCar</span><span class="params">(<span class="meta">@MatrixVariable("num")</span> Integer num,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="meta">@MatrixVariable("brand")</span> List&lt;String&gt; brand,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="meta">@PathVariable("path")</span> String path)</span></span>{</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"num"</span>,num);</span><br><span class="line">        map.put(<span class="string">"brand"</span>,brand);</span><br><span class="line">        map.put(<span class="string">"path"</span>,path);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping("/boss/{bossId}/{empId}")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getAge</span><span class="params">(<span class="meta">@PathVariable("bossId")</span> Integer bossId,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="meta">@PathVariable("empId")</span> Integer empId,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="meta">@MatrixVariable(value = "age",pathVar = "bossId")</span> Integer bossAge,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="meta">@MatrixVariable(value = "age",pathVar = "empId")</span> Integer empAge)</span></span>{</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">"bossId"</span>,bossId);</span><br><span class="line">        map.put(<span class="string">"empId"</span>,empId);</span><br><span class="line">        map.put(<span class="string">"bossAge"</span>,bossAge);</span><br><span class="line">        map.put(<span class="string">"empAge"</span>,empAge);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-主程序入口"><a href="#2-3-主程序入口" class="headerlink" title="2.3 主程序入口"></a>2.3 主程序入口</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.springboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootAnnotationApplication</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(SpringbootAnnotationApplication.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="3-结果演示"><a href="#3-结果演示" class="headerlink" title="3.结果演示"></a>3.结果演示</h1><ul><li>启动主程序<code>SpringbootAnnotationApplication</code>，在浏览器地址栏输入：<code>http://localhost:8080/</code>,可以得到如下页面</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210724223130.png" alt="image-20210724223130092"></p><ul><li><p>点击第一个链接，得到如下结果</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210724223208.png"></p></li><li><p>点击第二个链接，得到如下结果</p></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210724223237.png" alt="image-20210724223237483"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MatrixVariable </tag>
            
            <tag> springboot注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法的使用、博文标题的使用</title>
      <link href="/posts/9892.html"/>
      <url>/posts/9892.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="关于博文的Front-matter的使用"><a href="#关于博文的Front-matter的使用" class="headerlink" title="关于博文的Front-matter的使用"></a>关于博文的Front-matter的使用</h1><ul><li>Front-matter中的内容为非必填项，但建议至少填写title和date</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/Snipaste_2021-06-19_15-50-13.png"></p><ul><li>最全示例</li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">基于</span> <span class="string">Hexo</span> <span class="string">GitHub</span> <span class="string">从零开始搭建个人博客</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-12-30 09:25:00</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Sitoi</span></span><br><span class="line"><span class="attr">img:</span> <span class="string">/source/images/xxx.jpg</span></span><br><span class="line"><span class="attr">top:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">cover:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">coverImg:</span> <span class="string">/images/1.jpg</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">summary:</span> <span class="string">这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">Hexo</span> <span class="string">GitHub</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Blog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GitHub</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><ul><li>转载自:<a href="https://sitoi.cn/posts/63466.html">https://sitoi.cn/posts/63466.html</a></li></ul><hr><h1 id="markdown-的基本语法"><a href="#markdown-的基本语法" class="headerlink" title="markdown 的基本语法"></a>markdown 的基本语法</h1><h2 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1.斜体和粗体"></a>1.斜体和粗体</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. *斜体*或者_斜体_</span><br><span class="line">2. **粗体**</span><br><span class="line">3. ***加粗斜体***</span><br><span class="line">4. ~~删除线~~</span><br></pre></td></tr></tbody></table></figure><p>显示效果：</p><ol><li><em>斜体</em>或者_斜体_</li><li><strong>粗体</strong></li><li><em><strong>加粗斜体</strong></em></li><li><del>删除线</del></li></ol><h2 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2.分级标题"></a>2.分级标题</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></tbody></table></figure><h2 id="3-超链接"><a href="#3-超链接" class="headerlink" title="3.超链接"></a>3.超链接</h2><ul><li>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</li></ul><h3 id="3-1-行内式"><a href="#3-1-行内式" class="headerlink" title="3.1 行内式"></a>3.1 行内式</h3><ul><li>介绍：[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">1. 欢迎访问[我的博客](www.colorfo.top)</span><br><span class="line">2. 欢迎访问[我的博客](www.colorfo.top "colorfo")</span><br></pre></td></tr></tbody></table></figure><ol><li>欢迎访问<a href="www.colorfo.top">我的博客</a></li><li>欢迎访问<a href="www.colorfo.top" title="colorfo">我的博客</a></li></ol><h3 id="3-2-参考式"><a href="#3-2-参考式" class="headerlink" title="3.2 参考式"></a>3.2 参考式</h3><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p><p>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p><p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]</span><br><span class="line">[Leanote 笔记][2]是一个不错的[网站][]。</span><br><span class="line"></span><br><span class="line">[1]:http://www.google.com "Google"</span><br><span class="line">[2]:http://www.leanote.com "Leanote"</span><br><span class="line">[3]:http://www.colorfo.top "自己的博客"</span><br><span class="line">[网站]:http://http://blog.leanote.com/freewalk</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>显示效果：</p><p>我经常去的几个网站<a href="http://www.google.com/" title="Google">Google</a>、<a href="http://www.leanote.com/" title="Leanote">Leanote</a>以及<a href="http://www.colorfo.top/" title="自己的博客">自己的博客</a><br><a href="http://www.leanote.com/" title="Leanote">Leanote 笔记</a>是一个不错的<a href="http://http//blog.leanote.com/freewalk">网站</a>。</p><ul><li>更多内容请参考—&gt;原文链接：<a href="https://blog.csdn.net/witnessai1/article/details/52551362">https://blog.csdn.net/witnessai1/article/details/52551362</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> front-matter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客的启动和部署</title>
      <link href="/posts/be0d.html"/>
      <url>/posts/be0d.html</url>
      
        <content type="html"><![CDATA[<h1 id="本篇博客主要记录hexo博客的启动和部署"><a href="#本篇博客主要记录hexo博客的启动和部署" class="headerlink" title="本篇博客主要记录hexo博客的启动和部署"></a>本篇博客主要记录hexo博客的启动和部署</h1><h2 id="启动hexo博客"><a href="#启动hexo博客" class="headerlink" title="启动hexo博客"></a>启动hexo博客</h2><ul><li><p>在blog文件夹下，输入cmd,进入Windows的命令提示行窗口</p></li><li><p>输入”hexo server”即可启动 hexo 博客</p></li><li><p>打开浏览器，输入地址：<a href="http://localhost:4000/">http://localhost:4000</a>,即可从本地访问hexo博客</p></li></ul><hr><h2 id="添加部署信息"><a href="#添加部署信息" class="headerlink" title="添加部署信息"></a>添加部署信息</h2><ul><li><p>在_config.yml文件中操作(_config.yml文件的最下面修改)，可以将博客部署到github或者gitee</p></li><li><p>例如我的设置为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https://gitee.com/ColorQian/ColorQian.git</span><br><span class="line">branch: master</span><br></pre></td></tr></tbody></table></figure></li><li><p>修改好配置后，运行如下命令，将代码部署到gitee        </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo generate </span><br><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure></li><li><p>在gitee的Gitee Pages 页面更新部署</p></li><li><p>在浏览器地址栏输入：<a href="http://colorqian.gitee.io/">http://colorqian.gitee.io</a> 即可访问博客</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/posts/3d22.html"/>
      <url>/posts/3d22.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>姓名：钱佳乐<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>来自南京理工大学<br>你可以通过邮箱联系我：<a href="mailto:qjl@njust.edu.cn">qjl@njust.edu.cn</a></p><hr><h2 id="关于这个博客网站"><a href="#关于这个博客网站" class="headerlink" title="关于这个博客网站"></a>关于这个博客网站</h2><p>网站名：”<a href="http://colorqian.gitee.io&quot;/">http://colorqian.gitee.io"</a><br>我将会不定期的在这个网站上发布一些关于java的文章</p><hr><h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><p>程序羊</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
