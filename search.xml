<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划刷题笔记②</title>
      <link href="/posts/91bd.html"/>
      <url>/posts/91bd.html</url>
      
        <content type="html"><![CDATA[<h1 id="完全背包理论"><a href="#完全背包理论" class="headerlink" title="完全背包理论"></a>完全背包理论</h1><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><p>同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理。</p><p>在下面的讲解中，我依然举这个例子：</p><p>背包最大重量为4。</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p><strong>每件商品都有无限个！</strong></p><p>问背包能背的物品最大价值是多少？</p><p>01背包和完全背包唯一不同就是体现在遍历顺序上</p><ul><li>思路分析：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html">完全背包理论基础</a></li></ul><ul><li><p>代码详情</p><p><strong>对于纯完全背包问题，两层for循环的先后循环是可以颠倒的！</strong>并且内层for循环采用正序遍历(从小到大)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。</span></span><br><span class="line"><span class="comment"> * 每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</span></span><br><span class="line"><span class="comment"> * (完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletePack</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testCompletePack</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> bagWeight)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = weight.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[bagWeight + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = weight[i]; j &lt;= bagWeight; j++) {</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">        <span class="keyword">return</span> dp[bagWeight];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] weight = {<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">        <span class="keyword">int</span>[] value = {<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>};</span><br><span class="line">        testCompletePack(weight,value,<span class="number">4</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br></li></ul><h1 id="1-零钱兑换"><a href="#1-零钱兑换" class="headerlink" title="1.零钱兑换"></a>1.零钱兑换</h1><p><a href="https://leetcode-cn.com/problems/coin-change-2/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><p>示例 1:</p><p>输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</p><p>示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。</p><p>示例 3: 输入: amount = 10, coins = [10] 输出: 1</p><p>注意，你可以假设：</p><p>0 &lt;= amount (总金额) &lt;= 5000</p><p>1 &lt;= coin (硬币面额) &lt;= 5000</p><p>硬币种类不超过 500 种</p><p>结果符合 32 位符号整数</p><ul><li>思路分析</li></ul><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[j]：凑成总金额j的货币组合数为dp[j]</p><ol start="2"><li>确定递推公式</li></ol><p>dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。</p><p>所以递推公式：dp[j] += dp[j - coins[i]];</p><ol start="3"><li>dp数组如何初始化</li></ol><p>首先dp[0]一定要为1，dp[0] = 1是 递归公式的基础。</p><p>从dp[i]的含义上来讲就是，凑成总金额0的货币组合数为1。</p><p>下标非0的dp[j]初始化为0，这样累计加dp[j - coins[i]]的时候才不会影响真正的dp[j]</p><ol start="4"><li>确定遍历顺序</li></ol><p>因为本题是求组合数，所以先遍历物品，再遍历背包容量</p><ol start="5"><li>举例推导dp数组</li></ol><p>输入: amount = 5, coins = [1, 2, 5] ，dp状态图如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210925153233.jpeg"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/coin-change-2/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinChange</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = coins.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];  <span class="comment">//dp[i] 表示 装满容量为i的背包有多少种方法</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {  <span class="comment">//遍历物品(也就是硬币)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) {  <span class="comment">//遍历背包</span></span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        CoinChange change = <span class="keyword">new</span> CoinChange();</span><br><span class="line">        <span class="keyword">int</span> change1 = change.change(<span class="number">5</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>});</span><br><span class="line"></span><br><span class="line">        System.out.println(change1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-组合总和-Ⅳ"><a href="#2-组合总和-Ⅳ" class="headerlink" title="2. 组合总和 Ⅳ"></a>2. 组合总和 Ⅳ</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p><p>示例:</p><p>nums = [1, 2, 3] target = 4</p><p>所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)</p><p>请注意，顺序不同的序列被视作不同的组合。</p><p>因此输出为 7</p><ul><li>思路分析</li></ul><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i] 凑成目标正整数为i的排列数为dp[i]</p><ol start="2"><li>dp数组的初始化</li></ol><p>dp[0] = 1;</p><ol start="3"><li>确定遍历顺序</li></ol><p>因为是求排列数，所以先遍历背包容量，再遍历物品</p><ol start="4"><li>递推表达式</li></ol><p>dp[j] += dp[j - nums[j]];</p><ol start="5"><li>举例推导dp数组</li></ol><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210925154850.jpeg"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/combination-sum-iv/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum4</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];  <span class="comment">//dp[i] 表示 容量为i的背包 一共有多少种排列</span></span><br><span class="line">                                         <span class="comment">//即-dp[i]: 凑成目标正整数为i的排列个数为dp[i]</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) { <span class="comment">//先遍历背包，再遍历物品，求排列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                <span class="comment">//背包比物品大，才可放入</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) dp[j] += dp[j - nums[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-爬楼梯-进阶版"><a href="#3-爬楼梯-进阶版" class="headerlink" title="3.爬楼梯(进阶版)"></a>3.爬楼梯(进阶版)</h1><ul><li>题目</li></ul><p><strong>一步一个台阶，两个台阶，三个台阶，…….，直到 m个台阶。问有多少种不同的方法可以爬到楼顶n呢？</strong></p><ul><li>思路分析</li></ul><p>1阶，2阶，…. m阶就是物品，楼顶就是背包。</p><p>每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。</p><p>问跳到楼顶有几种方法其实就是问装满背包有几种方法。</p><p><strong>此时大家应该发现这就是一个完全背包问题了！</strong></p><p>并且这是完全背包里求排列问题，即：<strong>1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！</strong></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改为：一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。</span></span><br><span class="line"><span class="comment"> * 问有多少种不同的方法可以爬到楼顶呢？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClimbingStairs2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climStairs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{ <span class="comment">//n表示一共有n个台阶，m表示一次最多可以跳m步</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完全背包中的排列问题</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {   <span class="comment">//先遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {  <span class="comment">//再遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i) dp[j] += dp[j - i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-零钱兑换"><a href="#4-零钱兑换" class="headerlink" title="4.零钱兑换"></a>4.零钱兑换</h1><p><a href="https://leetcode-cn.com/problems/coin-change/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1</p><p>示例 2： 输入：coins = [2], amount = 3 输出：-1</p><p>示例 3： 输入：coins = [1], amount = 0 输出：0</p><p>示例 4： 输入：coins = [1], amount = 1 输出：1</p><p>示例 5： 输入：coins = [1], amount = 2 输出：2</p><ul><li>思路分析</li></ul><ol start="0"><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p><ol><li>确定递推公式</li></ol><p>得到dp[j]（考虑coins[i]），只有一个来源，dp[j - coins[i]]（没有考虑coins[i]）。</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p><p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</p><ol start="2"><li>dp数组如何初始化</li></ol><p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;</p><p>其他下标对应的数值呢？</p><p>考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p><p>所以下标非0的元素都是应该是最大值。</p><ol start="3"><li>确定遍历顺序</li></ol><p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。</strong>。</p><p>所以本题并不强调集合是组合还是排列。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p><strong>所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！</strong></p><p>本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序</p><p>综上所述，<em>遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。</em></p><ol start="4"><li>举例推导dp数组</li></ol><p>以输入：coins = [1, 2, 5], amount = 5为例</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210925162533.jpeg"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinChange2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount ; j++) {</span><br><span class="line">                <span class="keyword">if</span> (dp[j - coins[i]] != Integer.MAX_VALUE) {  <span class="comment">//如果dp[j - coins[i]]是初始值则跳过</span></span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//============</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        CoinChange2 coinChange2 = <span class="keyword">new</span> CoinChange2();</span><br><span class="line">        <span class="keyword">int</span> i = coinChange2.coinChange(<span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>}, <span class="number">5</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-完全平方数"><a href="#5-完全平方数" class="headerlink" title="5.完全平方数"></a>5.完全平方数</h1><p><a href="https://leetcode-cn.com/problems/perfect-squares/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>示例 1： 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4</p><p>示例 2： 输入：n = 13 输出：2 解释：13 = 4 + 9</p><p>提示：1 &lt;= n &lt;= 10^4</p><ul><li>思路分析</li></ul><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><strong>dp[i]：和为i的完全平方数的最少数量为dp[i]</strong></p><ol start="2"><li>确定递推公式</li></ol><p>dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。</p><p>此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。</p><ol start="4"><li>确定遍历顺序</li></ol><p><strong>本题外层for遍历背包，里层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！</strong></p><p>这里给出外层遍历物品，里层遍历背包容量的代码</p><ol start="5"><li>举例推导dp数组</li></ol><p>已输入n为5例，dp状态图如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210925164445.jpeg"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerfectSquares</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; <span class="comment">//组成i,所需的完全平方数的最小个数dp[i]</span></span><br><span class="line"></span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) {  <span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j++) {   <span class="comment">//遍历背包</span></span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="6-单词拆分"><a href="#6-单词拆分" class="headerlink" title="6.单词拆分"></a>6.单词拆分</h1><p><a href="https://leetcode-cn.com/problems/word-break/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。</p><p>你可以假设字典中没有重复的单词。</p><p>示例 1： 输入: s = “leetcode”, wordDict = [“leet”, “code”] 输出: true 解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p><p>示例 2： 输入: s = “applepenapple”, wordDict = [“apple”, “pen”] 输出: true 解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。  注意你可以重复使用字典中的单词。</p><p>示例 3： 输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”] 输出: false</p><ul><li><p>思路分析</p><p>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</p><p>拆分时可以重复使用字典中的单词，说明就是一个完全背包！</p></li></ul><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p><ol start="2"><li>确定递推公式</li></ol><p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</p><p>所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</p><ol start="3"><li>dp数组如何初始化</li></ol><p>从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</p><ol start="4"><li>遍历顺序</li></ol><p><strong>遍历背包放在外循环，将遍历物品放在内循环。内循环从前到后</strong></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/word-break/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordBreak</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>{</span><br><span class="line">        <span class="comment">//dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。</span></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) {</span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(s.substring(j,i)) &amp;&amp; dp[j]) {</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><hr><h1 id="7-打家劫舍"><a href="#7-打家劫舍" class="headerlink" title="7.打家劫舍"></a>7.打家劫舍</h1><p><a href="https://leetcode-cn.com/problems/house-robber/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  偷窃到的最高金额 = 1 + 3 = 4 。</p><p>示例 2： 输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。  偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><ul><li>思路分析</li></ul><p>打家劫舍是dp解决的经典问题，动规五部曲分析如下：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。</p><ol start="2"><li>确定递推公式</li></ol><p>决定dp[i]的因素就是第i房间偷还是不偷。</p><p>如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p><p>如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房，（<strong>注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点</strong>）</p><p>然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]</p><p>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);</p><ol start="4"><li>确定遍历顺序</li></ol><p>dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</p><ol start="5"><li>举例推导dp数组</li></ol><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210925195655.jpeg"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/house-robber/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobber</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">//dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="comment">//决定dp[i] 的因素就是 第i房间 偷还是不偷</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="8-打家劫舍2"><a href="#8-打家劫舍2" class="headerlink" title="8.打家劫舍2"></a>8.打家劫舍2</h1><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p><p>示例 2： 输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4 。</p><p>示例 3： 输入：nums = [0] 输出：0</p><ul><li>思路分析</li></ul><p>分两种情况考虑，1.考虑抢劫第一家，最后一家放弃，2.考虑抢劫最后一家，第一家放弃</p><p>然后利用<strong>7.打家劫舍</strong>的代码进行判断即可</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/house-robber-ii/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobber2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result1 = robRange(<span class="number">0</span>, nums.length - <span class="number">2</span>, nums);  <span class="comment">//考虑抢劫第一家，最后一家放弃</span></span><br><span class="line">        <span class="keyword">int</span> result2 = robRange(<span class="number">1</span>, nums.length - <span class="number">1</span>, nums);  <span class="comment">//考虑抢劫最后一家，第一家放弃</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(result1, result2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通的打家劫舍逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">robRange</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = Math.max(nums[start + <span class="number">1</span>], nums[start]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) {</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><hr><p>以上题目参考：LeetCode，思路分析参考：<a href="https://programmercarl.com/">代码随想录</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
            <tag> 完全背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP基础①</title>
      <link href="/posts/942d.html"/>
      <url>/posts/942d.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是cookie"><a href="#1-什么是cookie" class="headerlink" title="1.什么是cookie"></a>1.什么是cookie</h1><p>Cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态</p><ol><li>cookie会根据从服务器端发送的响应报文中的一个叫做Set-Cookie的首部字段信息，通知客户端保存cookie.</li><li>当下次客户端再向服务器端发送请求时，客户端会自动在请求报文中加入cookie值后发送出去</li><li>服务器端发现客户端发来的cookie后，会检查是哪一个客户端发送过来的连接请求，然后得到之前的状态信息</li></ol><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922163505.png" alt="无cookie的请求"></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922163858.png" alt="带有cookie的请求"></p><h1 id="2-HTTP报文"><a href="#2-HTTP报文" class="headerlink" title="2.HTTP报文"></a>2.HTTP报文</h1><p>HTTP报文的主体用于传输请求或响应的实体主体</p><p>通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异</p><h2 id="2-1请求和响应的报文首部"><a href="#2-1请求和响应的报文首部" class="headerlink" title="2.1请求和响应的报文首部"></a>2.1请求和响应的报文首部</h2><p>请求报文和响应报文的首部内容有以下数据组成：</p><ol><li><p>请求行</p><p>包含请求方法，请求URI,http版本</p></li><li><p>状态行</p><p>包含响应结果的状态码，原因短语，http版本</p></li><li><p>首部字段</p><p>包含请求和响应的各种条件，以及属性的各类首部</p><p>一般有4中首部，分别是：通用首部，请求首部，响应首部，实体首部</p></li><li><p>其他</p><p>可能包含http的RFC里未定义的首部(cookie等)</p></li></ol><br><h1 id="3-HTTP状态码"><a href="#3-HTTP状态码" class="headerlink" title="3.HTTP状态码"></a>3.HTTP状态码</h1><ul><li>状态码的作用是当客户端向服务器端发送请求时，描述返回的请求结果</li></ul><h2 id="3-1状态码的类别"><a href="#3-1状态码的类别" class="headerlink" title="3.1状态码的类别"></a>3.1状态码的类别</h2><table><thead><tr><th align="center"></th><th align="center">类别</th><th align="center">原因短语</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">information(信息性状态码)</td><td align="center">接受的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">Success(成功状态码)</td><td align="center">请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">Redirection(重定向状态码)</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">Client Error(客户端错误状态码)</td><td align="center">服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">Server Error(服务器错误状态码)</td><td align="center">服务器处理请求出错</td></tr></tbody></table><br><h2 id="3-2常见状态码"><a href="#3-2常见状态码" class="headerlink" title="3.2常见状态码"></a>3.2常见状态码</h2><h3 id="2XX开头"><a href="#2XX开头" class="headerlink" title="2XX开头"></a>2XX开头</h3><ol><li><p>200 OK</p><p>表示从客户端发来的请求在服务器端被正常处理了</p></li><li><p>204 No Content</p><p>一般只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用</p></li><li><p>206 Partial Content</p><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由</p><p>Content-Range指定范围的实体内容</p></li></ol><h3 id="3XX开头"><a href="#3XX开头" class="headerlink" title="3XX开头"></a>3XX开头</h3><ul><li>3XX响应结果表示浏览器需要执行某些特殊的处理以正确处理请求</li></ul><ol><li><p>301 Moved Permanently</p><p>永久性重定向。该状态码表示请求的资源已经被分配了新的URI,以后应使用资源现在所指的URI</p></li><li><p>302 Found</p><p>临时性重定向。该状态码表示请求的资源已被分配了新的URI,希望用户本次能使用新的URI访问</p></li><li><p>303 See Other</p><p>该状态码表示由于请求对应的资源存在着另一个URI,应使用GET方法定向获取请求资源</p></li></ol><h3 id="4XX开头"><a href="#4XX开头" class="headerlink" title="4XX开头"></a>4XX开头</h3><ul><li>4XX的响应结果表明客户端是发生错误的原因所在</li></ul><ol><li><p>400 Bad Request</p><p>该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求内容后再次发送请求</p></li><li><p>401 Unauthorized</p><p>该状态码表示发送的请求需要有通过HTTP认证的认证信息。另外，若之前已经进行过1次请求，</p><p>则表示用户认证失败</p></li><li><p>403 Forbidden</p><p>该状态码表明对请求资源的访问被服务器拒绝了。</p><p>未获得文件系统的访问授权，访问权限出现某些问题等，都可能是发生403的原因</p></li><li><p>404 Not Found</p><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明原因时使用</p></li></ol><h3 id="5XX开头"><a href="#5XX开头" class="headerlink" title="5XX开头"></a>5XX开头</h3><ul><li>5XX的响应结果表明服务器本身发生错误</li></ul><ol><li><p>500 Internal Server Error</p><p>该状态码表明服务器在执行请求过程中发生了错误。也有可能是Web应用存在的bug或某些临时的故障</p></li><li><p>503 Service Unavailable</p><p>该状态码表示服务器暂时处于超负载或停机维护状态，现在无法处理请求。</p><p>如果事先得知解除以上状况所需要的时间，最好写入Retry-After首部字段再返回给客户端。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 图解HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> http报文 </tag>
            
            <tag> http状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划刷题笔记①</title>
      <link href="/posts/517c.html"/>
      <url>/posts/517c.html</url>
      
        <content type="html"><![CDATA[<ul><li>动态规划五部曲<ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol></li></ul><h1 id="1-斐波那契数"><a href="#1-斐波那契数" class="headerlink" title="1.斐波那契数"></a>1.斐波那契数</h1><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p><p>示例 1： 输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1</p><p>示例 2： 输入：3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2</p><p>示例 3： 输入：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3</p><p>提示：</p><p>0 &lt;= n &lt;= 30</p><ul><li>思路分析</li></ul><p>1.确定dp数组以及下标的含义</p><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><p>2.确定递推公式</p><p><strong>题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p><p>3.dp数组初始化</p><p>dp[0] = 0;</p><p>dp[1]  = 1;</p><p>4.确定遍历顺序</p><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><p>5.举例推导dp数组</p><p>0 1 1 2 3 5 8 13 21 34 55</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/fibonacci-number/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciNumber</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">            sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = sum;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;  <span class="comment">//return dp[1]也可以</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-爬楼梯"><a href="#2-爬楼梯" class="headerlink" title="2.爬楼梯"></a>2.爬楼梯</h1><p><a href="">leetcode题目链接</a></p><ul><li>题目</li></ul><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol><p>示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><ul><li>思路分析</li></ul><p>此题与<em>菲波那切数</em>几乎一样，只不过初始条件不一样罢了</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClimbingStairs</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-使用最小花费爬楼梯"><a href="#3-使用最小花费爬楼梯" class="headerlink" title="3.使用最小花费爬楼梯"></a>3.使用最小花费爬楼梯</h1><p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例 1：</p><p>输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。  示例 2：</p><p>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</p><p>提示：</p><ul><li>cost 的长度范围是 [2, 1000]。</li><li>cost[i] 将会是一个整型数据，范围为 [0, 999] </li></ul><br><ul><li>思路分析</li></ul><ol><li><p>确定dp数组以及下标的含义</p><p>**dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]**。</p></li><li><p>确定递推公式</p><p>**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。</p><p>那么究竟是选dp[i-1]还是dp[i-2]呢？</p><p>一定是选最小的，所以dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];</p><p><strong>注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的</strong>，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值</p></li><li><p>dp数组的初始化</p><p>dp[i]由dp[i-1]，dp[i-2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[0] = cost[0];</span><br><span class="line">dp[1] = cost[1];</span><br></pre></td></tr></tbody></table></figure></li><li><p>确定遍历顺序</p><p>因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了</p></li><li><p>举例推导dp数组</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922100952.png"></p></li></ol><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/min-cost-climbing-stairs/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinCostClimbingStairs</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length]; <span class="comment">//1.dp[i] 表示爬上i层楼所需的最小花费</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.dp数组的初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.确定遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= dp.length - <span class="number">1</span>; i++) {</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>],dp[i - <span class="number">2</span>]) + cost[i]; <span class="comment">//2.确定递推公式</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[dp.length - <span class="number">1</span>],dp[dp.length - <span class="number">2</span>]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-不同路径"><a href="#4-不同路径" class="headerlink" title="4.不同路径"></a>4.不同路径</h1><p><a href="https://leetcode-cn.com/problems/unique-paths/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><ul><li>思路分析</li></ul><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p><ol start="2"><li>确定递推公式</li></ol><p>想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。</p><p>此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。</p><p>那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。</p><ol start="3"><li>dp数组的初始化</li></ol><p>如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。</p><p>所以初始化代码为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">for (int j = 0; j &lt; n; j++) dp[0][j] = 1;</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>这里要看一下递归公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p><p>这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。</p><ol start="5"><li>举例推导dp数组</li></ol><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/unique-paths/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePaths</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n]; <span class="comment">//1.确定dp数组，dp[i][j] 表示 (0,0) -&gt; (i,j)一共有多少种路径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.dp数组的初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="comment">//4.确定递推表达式</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-不同路径-II"><a href="#5-不同路径-II" class="headerlink" title="5. 不同路径 II"></a>5. 不同路径 II</h1><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><ul><li>思路分析</li></ul><p>此题与<strong>4.不同路径</strong>类似，只是多了障碍物，需要注意障碍物的处理</p><p>初始化时的障碍物处理：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>递推遍历时，对于障碍物的处理：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;  <span class="comment">//如果遇到障碍物则跳过</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/unique-paths-ii/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePath2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-不同的二叉搜索树"><a href="#6-不同的二叉搜索树" class="headerlink" title="6.不同的二叉搜索树"></a>6.不同的二叉搜索树</h1><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922104340.png"></p><ul><li>思路分析</li></ul><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。</p><p>也可以理解是i的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。</p><p>以下分析如果想不清楚，就来回想一下dp[i]的定义</p><ol start="2"><li>确定递推公式</li></ol><p>在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</p><p>j相当于是头结点的元素，从1遍历到i为止。</p><p>所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p><ol start="3"><li>dp数组如何初始化</li></ol><p>初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。</p><p>那么dp[0]应该是多少呢？</p><p>从定义上来讲，空节点也是一颗二叉树，也是一颗二叉搜索树，这是可以说得通的。</p><p>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。</p><p>所以初始化dp[0] = 1</p><ol start="4"><li>确定遍历顺序</li></ol><p>首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p><p>那么遍历i里面每一个数作为头结点的状态，用j来遍历。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) {</span><br><span class="line">        dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><p>举例推导dp数组</p><p>n为5时候的dp数组状态如图：</p></li></ol><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922110842.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/unique-binary-search-trees/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];   <span class="comment">// 1到i为节点组成的二叉搜索树的个数为dp[i]。</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;     <span class="comment">//初始化，空节点也是一颗二叉树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="comment">//j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) {</span><br><span class="line">                dp[i] += dp[j-<span class="number">1</span>] * dp[i-j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = numTrees(<span class="number">3</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br><hr><h1 id="7-0-1背包理论基础-一"><a href="#7-0-1背包理论基础-一" class="headerlink" title="7.0-1背包理论基础(一)"></a>7.0-1背包理论基础(一)</h1><p>参见：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85">代码随想录</a>，使用二维数组实现0-1背包。</p><br><h1 id="8-0-1背包理论基础-二"><a href="#8-0-1背包理论基础-二" class="headerlink" title="8.0-1背包理论基础(二)"></a>8.0-1背包理论基础(二)</h1><ul><li><p>一维dp数组(滚动数组)</p></li><li><p>题目</p></li></ul><p>背包最大重量为4。</p><p>物品为：</p><table><thead><tr><th align="center">重量</th><th>价值</th><th></th></tr></thead><tbody><tr><td align="center">物品0</td><td>1</td><td>15</td></tr><tr><td align="center">物品1</td><td>3</td><td>20</td></tr><tr><td align="center">物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><ul><li>思路分析</li></ul><ol><li>确定dp数组的定义</li></ol><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><ol start="2"><li>一维dp数组的递推公式</li></ol><p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p><p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>所以递归公式为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></tbody></table></figure><p>可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。</p><ol start="3"><li>一维dp数组如何初始化</li></ol><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p><p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p><p>看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p><p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p><p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p><ol start="4"><li>一维dp数组遍历顺序</li></ol><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品</span><br><span class="line">    for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量</span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922140611.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 01背包问题，使用一维数组实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag01OneArray</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test01BagProblem</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> bagSize)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义dp数组，dp[j] 表示容量为j的背包 所放物品的总价值</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[bagSize + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//初始化dp数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定遍历顺序，以及递归的表达式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.length; i++) {  <span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = bagSize; j &gt;= weight[i] ; j--) {  <span class="comment">//遍历背包容量(倒序遍历)</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[weight.length];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] weight = {<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">        <span class="keyword">int</span>[] value = {<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>};</span><br><span class="line"></span><br><span class="line">        test01BagProblem(weight,value,<span class="number">4</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="9-分割等和子集"><a href="#9-分割等和子集" class="headerlink" title="9.分割等和子集"></a>9.分割等和子集</h1><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200</p><p>示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 200</p><p>1 &lt;= nums[i] &lt;= 100</p><ul><li>思路分析</li></ul><p>动规五部曲分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p>01背包中，dp[i] 表示： 容量为j的背包，所背的物品价值可以最大为dp[j]。</p><p>**套到本题，dp[i]表示 背包总容量是i，最大可以凑成i的子集总和为dp[i]**。</p><ol start="2"><li>确定递推公式</li></ol><p>01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p><p>本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</p><p>所以递推公式：<code>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</code></p><ol start="3"><li>dp数组如何初始化</li></ol><p>在01背包，一维dp如何初始化，已经讲过，</p><p>从dp[j]的定义来看，首先dp[0]一定是0。</p><p>如果如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p><p>本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。</p><ol start="4"><li>确定遍历顺序</li></ol><p>如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒叙遍历！</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始 01背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= nums[i]; j--) { <span class="comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>dp[i]的数值一定是小于等于i的。</p><p><strong>如果dp[i] == i 说明，集合中的子集总和正好可以凑成总和i，理解这一点很重要。</strong></p><p>用例1，输入[1,5,11,5] 为例，如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210922143059.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/partition-equal-subset-sum/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualSubsetSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">            sum += num;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//如果是奇数，则不能平分为两个相等的子集</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>]; <span class="comment">//dp[j] 表示 容量为j 可放入的最大元素和</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;                     <span class="comment">//初始化dp</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定遍历顺序以及，递归表达式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i] ; j--) {</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="10-最后一块石头的重量-II"><a href="#10-最后一块石头的重量-II" class="headerlink" title="10.最后一块石头的重量 II"></a>10.最后一块石头的重量 II</h1><p><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><p>如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><ul><li>思路分析</li></ul><p>本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，<strong>这样就化解成01背包问题了</strong>。</p><p>和<a href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">9. 分割等和子集</a>非常像了。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LastStone</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) {</span><br><span class="line">            sum += stone;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = sum &gt;&gt; <span class="number">1</span>; <span class="comment">//sum / 2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>]; <span class="comment">//dp[j] 表示容量j 可以 装入的最大重量 dp[j]</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定遍历顺序以及状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= stones[i]; j--) {</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum - dp[target] - dp[target];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="11目标和"><a href="#11目标和" class="headerlink" title="11目标和"></a>11目标和</h1><p><a href="https://leetcode-cn.com/problems/target-sum/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5</p><p>解释：<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3</p><p>一共有5种方法让最终目标和为3。</p><ul><li>思路分析</li></ul><p>如何转化为01背包问题呢。</p><p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p><p>所以我们要求的是 x - (sum - x) = S</p><p>x = (S + sum) / 2</p><p><strong>此时问题就转化为，装满容量为x背包，有几种方法</strong>。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[i]种方法</p><ol start="2"><li>确定递推公式</li></ol><p>不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。</p><p>那么只要搞到nums[i]的话，凑成dp[j]就有dp[j - nums[i]] 种方法。</p><p>举一个例子,nums[i] = 2： dp[3]，填满背包容量为3的话，有dp[3]种方法。</p><p>那么只需要搞到一个2（nums[i]），有dp[3]方法可以凑齐容量为3的背包，相应的就有多少种方法可以凑齐容量为5的背包。</p><p>那么需要把 这些方法累加起来就可以了，dp[j] += dp[j - nums[i]]</p><p>所以求组合类问题的公式，都是类似这种：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>dp数组如何初始化</li></ol><p>从递归公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递归结果将都是0。</p><p>dp[0] = 1，理论上也很好解释，装满容量为0的背包，有1种方法，就是装0件物品。</p><p>dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。</p><ol start="4"><li>确定遍历顺序</li></ol><p>物品放在外循环，背包容量放在内循环，且内循环倒序</p><ol start="5"><li>举例推导dp数组</li></ol><p>输入：nums: [1, 1, 1, 1, 1], S: 3</p><p>bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4</p><p>dp数组状态变化如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210925141228.jpeg"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/target-sum/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">            sum += num;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bagSize = (sum + target) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[bagSize + <span class="number">1</span>];   <span class="comment">//dp[i] 表示装满容量为i的有多少种组合</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = bagSize; j &gt;= nums[i]; j--) {</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>以上题目参考：LeetCode，思路分析参考：<a href="https://programmercarl.com/">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法刷题笔记②-贪心解决区间问题</title>
      <link href="/posts/c9cc.html"/>
      <url>/posts/c9cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-用最少数量的箭引爆气球"><a href="#1-用最少数量的箭引爆气球" class="headerlink" title="1.用最少数量的箭引爆气球"></a>1.用最少数量的箭引爆气球</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p>示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]]</p><p>输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</p><ul><li>思路分析</li></ul><p>局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。</p><p><strong>算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？</strong></p><p>如果真实的模拟射气球的过程，应该射一个，气球数组就remove一个元素，这样最直观，毕竟气球被射了。</p><p>但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remove气球，只要记录一下箭的数量就可以了。</p><p>以上为思考过程，已经确定下来使用贪心了，那么开始解题。</p><p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。</p><p><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong>。</p><p>以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序）</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210912155250.png"></p><p>可以看出首先第一组重叠气球，一定是需要一个箭，气球3，的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了.</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BurstBalloons</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() { <span class="comment">//按照左边界排序,从小到大排序</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>{</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] &lt; o2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (o1[<span class="number">0</span>] &gt; o2[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) {  <span class="comment">//两个气球如果不挨着</span></span><br><span class="line">                result++;  <span class="comment">//需要一支箭</span></span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {  <span class="comment">//气球i和i-1挨着</span></span><br><span class="line">                points[i][<span class="number">1</span>] = Math.min(points[i-<span class="number">1</span>][<span class="number">1</span>],points[i][<span class="number">1</span>]); <span class="comment">// 更新重叠气球最小右边界</span></span><br><span class="line">                                                                      <span class="comment">// 即：取两者之中较小的右边界作为气球i的右边界</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-无重叠区间"><a href="#2-无重叠区间" class="headerlink" title="2.无重叠区间"></a>2.无重叠区间</h1><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。</p><p>示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p><p>示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了</p><ul><li>思路分析</li></ul><p>如果遇到重叠的区间，则将result+1，并且缩减当前区间的右边界(相当于把这个区间移除了)</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonOverlapping</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (intervals.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() { <span class="comment">//按照区间左边界排序</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>{</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] &gt; o2[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (o1[<span class="number">0</span>] &lt; o2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>]) { <span class="comment">//如果有重叠部分</span></span><br><span class="line">                result++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//相当于删除一个</span></span><br><span class="line">                intervals[i][<span class="number">1</span>] = Math.min(intervals[i - <span class="number">1</span>][<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-划分字母区间"><a href="#3-划分字母区间" class="headerlink" title="3.划分字母区间"></a>3.划分字母区间</h1><p><a href="https://leetcode-cn.com/problems/partition-labels/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>示例： 输入：S = “ababcbacadefegdehijhklij” 输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p><p>提示：</p><p>S的长度在[1, 500]之间。</p><p>S只包含小写字母 ‘a’ 到 ‘z’ 。</p><ul><li>思路分析</li></ul><p>在遍历的过程中相当于是要找每一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</p><p>可以分为如下两步：</p><p>统计每一个字符最后出现的位置</p><p>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</p><p>如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210912160310.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionLabels</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] edge = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">            edge[s.charAt(i) - <span class="string">'a'</span>] = i;  <span class="comment">//找到字符出现的最远下标</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line"></span><br><span class="line">            right = Math.max(edge[s.charAt(i) - <span class="string">'a'</span>],right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == right) {            <span class="comment">//找到字符出现的最远边界,说明到了划分点</span></span><br><span class="line">                <span class="keyword">int</span> partition = right - left + <span class="number">1</span>;</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">                result.add(partition);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-合并区间"><a href="#4-合并区间" class="headerlink" title="4.合并区间"></a>4.合并区间</h1><p><a href="https://leetcode-cn.com/problems/merge-intervals/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1: 输入: intervals = [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p><p>示例 2: 输入: intervals = [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。</p><p>提示：</p><p><code>intervals[i][0] &lt;= intervals[i][1]</code></p><ul><li>思路分析</li></ul><p>按照左边界从小到大排序之后，先将intervals[0]，加入到result集合中。</p><p>如果 <code>intervals[i][0] &lt;= result.getLast()[1]</code> 即<code>intervals[i]左边界 &lt; result.getLast()右边界</code>，则一定有重复</p><p>知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？</p><p>其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result集合里就可以了。</p><p>如果没有重复区间就把原区间加入到result集合。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeIntervals</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) {</span><br><span class="line"></span><br><span class="line">        Arrays.sort(intervals, (o1, o2) -&gt; Integer.compare(o1[<span class="number">0</span>],o2[<span class="number">0</span>]));<span class="comment">//按照左边界排序</span></span><br><span class="line">        LinkedList&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        result.add(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= result.getLast()[<span class="number">1</span>]) { <span class="comment">//如果有重叠的部分</span></span><br><span class="line">                <span class="keyword">int</span> start = result.getLast()[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> end = Math.max(result.getLast()[<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                result.removeLast();     <span class="comment">//先把result集合中的取出来</span></span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="keyword">int</span>[]{start,end});  <span class="comment">//再加入新的数组进到result集合中</span></span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                result.add(intervals[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[result.size()][]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><hr><p>以上题目及思路分析参考：leetcode及<a href="https://programmercarl.com/">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法刷题笔记①</title>
      <link href="/posts/2a28.html"/>
      <url>/posts/2a28.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-分发饼干"><a href="#1-分发饼干" class="headerlink" title="1.分发饼干"></a>1.分发饼干</h1><p><a href="https://leetcode-cn.com/problems/assign-cookies/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 2: 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2.</p><ul><li>代码详情</li></ul><p>思路：用小饼干先喂小胃口的孩子</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分发饼干</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/assign-cookies/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssignCookies</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *小饼干先喂饱小胃口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> g 小孩的胃口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 饼干的尺寸</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 饼干能满足小孩的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>{</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index &lt; g.length &amp;&amp; s[i] &gt;= g[index]){ <span class="comment">//如果满足了小孩的胃口</span></span><br><span class="line">                result++;</span><br><span class="line">                index++;  <span class="comment">//看下一个小孩的胃口</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-摆动序列"><a href="#2-摆动序列" class="headerlink" title="2.摆动序列"></a>2.摆动序列</h1><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1: 输入: [1,7,4,9,2,5] 输出: 6 解释: 整个序列均为摆动序列。</p><p>示例 2: 输入: [1,17,5,10,13,15,10,5,16,8] 输出: 7 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</p><ul><li>思路分析</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210911134723.png"></p><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiggleSubsequence</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> preDiff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curDiff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) {</span><br><span class="line">            curDiff = nums[i+<span class="number">1</span>] - nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前差值和上一个差值为一正一负</span></span><br><span class="line">            <span class="comment">//等于0的情况表示初始时的preDiff</span></span><br><span class="line">            <span class="keyword">if</span> ((curDiff &gt; <span class="number">0</span> &amp;&amp; preDiff &lt;= <span class="number">0</span>) || (curDiff &lt; <span class="number">0</span> &amp;&amp; preDiff &gt;= <span class="number">0</span>)){</span><br><span class="line">                count++;</span><br><span class="line">                preDiff = curDiff;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-最大子序列和"><a href="#3-最大子序列和" class="headerlink" title="3.最大子序列和"></a>3.最大子序列和</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">LeetCode题目链接</a></p><ul><li>题目</li></ul><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><ul><li>思路分析</li></ul><p><strong>贪心贪的是哪里呢？</strong></p><p>如果 -2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！</p><p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p><p>全局最优：选取最大“连续和”</p><p><strong>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优</strong>。</p><p>从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。</p><p><strong>这相当于是暴力解法中的不断调整最大子序和区间的起始位置</strong>。</p><p><strong>那有同学问了，区间终止位置不用调整么？ 如何才能得到最大“连续和”呢？</strong></p><p>区间的终止位置，其实就是如果count取到最大值了，及时记录下来了。例如如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &gt; result) result = count;</span><br></pre></td></tr></tbody></table></figure><p><strong>这样相当于是用result记录最大子序和区间和（变相的算是调整了终止位置）</strong>。</p><p>如动画所示:</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif"></p><p>红色的起始位置就是贪心每次取count为正数的时候，开始一个区间的统计。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubarray</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**方法一：</span></span><br><span class="line"><span class="comment">     * 暴力解法，时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) {</span><br><span class="line">                count += nums[j];</span><br><span class="line">                result = count &gt; result ? count : result;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**方法二：</span></span><br><span class="line"><span class="comment">     * 贪心算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            count += nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取区间累计的最大值（相当于不断确定最大子序终止位置）</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; result) result = count;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) count = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-买卖股票的最佳时机II"><a href="#4-买卖股票的最佳时机II" class="headerlink" title="4.买卖股票的最佳时机II"></a>4.买卖股票的最佳时机II</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p>示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p>示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><ul><li>思路分析</li></ul><p>计算相邻两天的价格差，若为正，则说明有利润可图，则加入到总利润中</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStock</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组求两天的价格差，只要是正(说明有利润)，就累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> temp = prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; <span class="number">0</span>){</span><br><span class="line">                result += temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-跳跃游戏"><a href="#5-跳跃游戏" class="headerlink" title="5.跳跃游戏"></a>5.跳跃游戏</h1><p><a href="https://leetcode-cn.com/problems/jump-game/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p>示例 1: 输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p><p>示例 2: 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p><ul><li>思路分析</li></ul><p>刚看到本题一开始可能想：当前位置元素如果是3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？</p><p>其实跳几步无所谓，关键在于可跳的覆盖范围！</p><p>不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。</p><p>这个范围内，别管是怎么跳的，反正一定可以跳过来。</p><p><strong>那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！</strong></p><p>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p><p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p><p>局部最优推出全局最优，找不出反例，试试贪心！</p><p>如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210911144211.png"></p><p>i每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让i继续移动下去。</p><p>而cover每次只取 max(该元素数值补充后的范围, cover本身范围)。</p><p>如果cover大于等于了终点下标，直接return true就可以了。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpGame</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cover; i++){  <span class="comment">// 注意这里是小于等于cover</span></span><br><span class="line">            cover = Math.max(i + nums[i],cover);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 说明可以覆盖到终点了</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-跳跃游戏II"><a href="#6-跳跃游戏II" class="headerlink" title="6.跳跃游戏II"></a>6.跳跃游戏II</h1><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p><p>说明: 假设你总是可以到达数组的最后一个位置。</p><ul><li>思路分析</li></ul><p>移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。</p><p>想要达到这样的效果，只要让移动下标，最大只能移动到<code>nums.size - 2</code>的地方就可以了。</p><p>因为当移动下标指向<code>nums.size - 2</code>时：</p><p>1.如果移动下标等于当前覆盖最大距离下标， 需要再走一步（即ans++），因为最后一步一定是可以到的终点。（题目假设总是可以到达数组的最后一个位置），如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210911145857.png"></p><p>2.如果移动下标不等于当前覆盖最大距离下标，说明当前覆盖最远距离就可以直接达到终点了，不需要再走一步。如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210911150006.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpGame2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> curDistance = <span class="number">0</span>;    <span class="comment">// 当前覆盖的最远距离下标</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;            <span class="comment">// 记录走的最大步数</span></span><br><span class="line">        <span class="keyword">int</span> nextDistance = <span class="number">0</span>;   <span class="comment">// 下一步覆盖的最远距离下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) { <span class="comment">// 注意这里是小于nums.size() - 1，这是关键所在</span></span><br><span class="line">            nextDistance = Math.max(nums[i] + i, nextDistance); <span class="comment">// 更新下一步覆盖的最远距离下标</span></span><br><span class="line">            <span class="keyword">if</span> (i == curDistance) {                 <span class="comment">// 遇到当前覆盖的最远距离下标</span></span><br><span class="line">                curDistance = nextDistance;         <span class="comment">// 更新当前覆盖的最远距离下标</span></span><br><span class="line">                ans++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="7-加油站"><a href="#7-加油站" class="headerlink" title="7.加油站"></a>7.加油站</h1><p><a href="https://leetcode-cn.com/progress/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明:</p><p>如果题目有解，该答案即为唯一答案。</p><p>输入数组均为非空数组，且长度相同。</p><p>输入数组中的元素均为非负数。</p><p>示例 1: 输入: gas = [1,2,3,4,5] cost = [3,4,5,1,2]</p><p>输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。</p><ul><li>思路分析</li></ul><p>首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。</p><p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p><p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</p><p>如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210911153807.png"></p><p>那么为什么一旦[i，j] 区间和为负数，起始位置就可以是j+1呢，j+1后面就不会出现更大的负数？</p><p>如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了。</p><p>而且j之前出现了多少负数，j后面就会出现多少正数，因为耗油总和是大于零的（前提我们已经确定了一定可以跑完全程）。</p><p><strong>那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GasStation</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> totalRest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; i++) {</span><br><span class="line"></span><br><span class="line">            curSum += (gas[i] - cost[i]);</span><br><span class="line">            totalRest += (gas[i] - cost[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) {   <span class="comment">// 当前累加gas[i] - cost[i]的和 curSum一旦小于0</span></span><br><span class="line">                start = i + <span class="number">1</span>;  <span class="comment">// 起始位置更新为i+1</span></span><br><span class="line">                curSum = <span class="number">0</span>;     <span class="comment">// curSum从0开始</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (totalRest &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 说明怎么走都不可能跑一圈了</span></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="8-单调递增的数字"><a href="#8-单调递增的数字" class="headerlink" title="8.单调递增的数字"></a>8.单调递增的数字</h1><p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p><p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。）</p><p>示例 1: 输入: N = 10 输出: 9</p><p>示例 2: 输入: N = 1234 输出: 1234</p><p>示例 3: 输入: N = 332 输出: 299</p><ul><li>思路分析</li></ul><p>题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。</p><p>例如：98，一旦出现<code>strNum[i - 1] &gt; strNum[i]</code>的情况（非单调递增），首先想让<code>strNum[i - 1]--</code>，然后<code>strNum[i]给为9</code>，这样这个整数就是89，即小于98的最大的单调递增整数。</p><p>这一点如果想清楚了，这道题就好办了。</p><p><strong>局部最优：遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]–，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数</strong>。</p><p><strong>全局最优：得到小于等于N的最大单调递增的整数</strong>。</p><p><strong>但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9</strong>。</p><p>此时是从前向后遍历还是从后向前遍历呢？</p><p>从前向后遍历的话，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。</p><p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p><p><strong>所以从前后向遍历会改变已经遍历过的结果！</strong></p><p>那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p><p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonotoneIncreasingDigits</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String str = String.valueOf(n); <span class="comment">//将n转为String串</span></span><br><span class="line">        <span class="keyword">char</span>[] s = str.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flag用来标记赋值9从哪里开始</span></span><br><span class="line">        <span class="comment">// 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行</span></span><br><span class="line">        <span class="keyword">int</span> flag = str.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] &gt; s[i]) {</span><br><span class="line">                flag = i;</span><br><span class="line">                s[i - <span class="number">1</span>] = (<span class="keyword">char</span>) (s[i - <span class="number">1</span>] - <span class="number">1</span>); <span class="comment">//s[i - 1]  -&gt; int (转为int类型)</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; flag &lt; s.length; flag++) {  <span class="comment">//将下标flag及其后面的数，全部置为'9'</span></span><br><span class="line">            s[flag] = <span class="string">'9'</span>;</span><br><span class="line">        }</span><br><span class="line">        String result = String.valueOf(s);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(result);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//----------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MonotoneIncreasingDigits num = <span class="keyword">new</span> MonotoneIncreasingDigits();</span><br><span class="line">        <span class="keyword">int</span> i = num.monotoneIncreasingDigits(<span class="number">318</span>); <span class="comment">//322</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>本篇博文参考：<a href="https://programmercarl.com/">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法刷题笔记②</title>
      <link href="/posts/e46.html"/>
      <url>/posts/e46.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-分割回文串"><a href="#1-分割回文串" class="headerlink" title="1.分割回文串"></a>1.分割回文串</h1><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">力扣题目链接</a></p><ul><li>题目</li></ul><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例: 输入:<code> "aab" 输出: [ ["aa","b"], ["a","a","b"] ]</code></p><ul><li>思路分析</li></ul><p>先分析一下切割，<strong>其实切割问题类似组合问题</strong>。</p><p>例如对于字符串abcdef：</p><p>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。</p><p>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</p><p>所以切割问题，也可以抽象为一颗树形结构，如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210906171247.jpeg"></p><p>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目链接：https://leetcode-cn.com/problems/palindrome-partitioning/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</span></span><br><span class="line"><span class="comment"> * 返回 s 所有可能的分割方案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例: 输入: "aab" 输出: [ ["aa","b"], ["a","a","b"] ]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivisionPalindrome</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        backtracking(s,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String s, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.length()) {</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; s.length(); i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s,startIndex,i)){ <span class="comment">//如果s的[startIndex,i]之间是回文串，则加入到path中</span></span><br><span class="line">                String str = s.substring(startIndex,i+<span class="number">1</span>);</span><br><span class="line">                path.add(str);</span><br><span class="line"></span><br><span class="line">                backtracking(s,i+<span class="number">1</span>);  <span class="comment">//递归</span></span><br><span class="line"></span><br><span class="line">                path.removeLast(); <span class="comment">//回溯</span></span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span> {       <span class="comment">//如果不是回文串，进行下一次判断</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex,j = endIndex; i &lt; j; i++,j--) {</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String str = <span class="string">"aab"</span>.substring(<span class="number">0</span>,<span class="number">1</span>);  <span class="comment">//substring(begin,end),[begin,end),左闭右开</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(<span class="string">"aab"</span>.substring(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        DivisionPalindrome palindrome = <span class="keyword">new</span> DivisionPalindrome();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; s = palindrome.partition(<span class="string">"aab"</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; strings : s) {</span><br><span class="line">            System.out.println(strings);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-复原IP地址"><a href="#2-复原IP地址" class="headerlink" title="2.复原IP地址"></a>2.复原IP地址</h1><p><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">力扣题目链接</a></p><ul><li>题目</li></ul><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:192.168@1.1">192.168@1.1</a>“ 是 无效的 IP 地址。</p><p>示例 1： 输入：s = “25525511135” 输出：[“255.255.11.135”,”255.255.111.35”]</p><p>示例 2： 输入：s = “0000” 输出：[“0.0.0.0”]</p><p>示例 3： 输入：s = “1111” 输出：[“1.1.1.1”]</p><p>示例 4： 输入：s = “010010” 输出：[“0.10.0.10”,”0.100.1.0”]</p><p>示例 5： 输入：s = “101023” 输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</p><p>提示： 0 &lt;= s.length &lt;= 3000 s 仅由数字组成</p><ul><li>思路分析</li></ul><p>只要意识到这是切割问题，<strong>切割问题就可以使用回溯搜索法把所有可能性搜出来</strong>，和刚做过的<strong>1.分割回文串</strong>就十分类似了。</p><p>切割问题可以抽象为树型结构，如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210906190030.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目地址：https://leetcode-cn.com/problems/restore-ip-addresses/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</span></span><br><span class="line"><span class="comment"> * 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，</span></span><br><span class="line"><span class="comment"> * 但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 5： 输入：s = "101023" 输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestoreIP</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.length() &gt; <span class="number">12</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        backtracking(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String s, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> pointNum)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pointNum == <span class="number">3</span>){  <span class="comment">// 逗点数量为3时，分隔结束</span></span><br><span class="line">            <span class="comment">// 判断第四段⼦字符串是否合法，如果合法就放进result中</span></span><br><span class="line">            <span class="keyword">if</span> (isValid(s,startIndex,s.length()-<span class="number">1</span>)){</span><br><span class="line">                result.add(s);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; s.length(); i++) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果s的[startIndex,i]是合法的整数子串</span></span><br><span class="line">            <span class="keyword">if</span> (isValid(s,startIndex,i)){</span><br><span class="line">                s = s.substring(<span class="number">0</span>,i+<span class="number">1</span>) + <span class="string">"."</span> + s.substring(i+<span class="number">1</span>);</span><br><span class="line">                pointNum++;</span><br><span class="line"></span><br><span class="line">                backtracking(s,i+<span class="number">2</span>,pointNum);  <span class="comment">//递归</span></span><br><span class="line"></span><br><span class="line">                s = s.substring(<span class="number">0</span>,i+<span class="number">1</span>) + s.substring(i+<span class="number">2</span>);</span><br><span class="line">                pointNum--;</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果以0开头，不合法</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) == <span class="string">'0'</span> &amp;&amp; start != end) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= end;i++){</span><br><span class="line">            <span class="comment">//判断每一个数字是否合法</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt; <span class="string">'9'</span> || s.charAt(i) &lt; <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果[start,end]范围内的整数大于255，不合法</span></span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        RestoreIP ip = <span class="keyword">new</span> RestoreIP();</span><br><span class="line">        List&lt;String&gt; strings = ip.restoreIpAddresses(<span class="string">"101023"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : strings){</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-子集问题"><a href="#3-子集问题" class="headerlink" title="3.子集问题"></a>3.子集问题</h1><p><a href="https://leetcode-cn.com/problems/subsets/">力扣题目链接</a></p><ul><li>题目</li></ul><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]</p><ul><li>思路分析</li></ul><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p><p>以示例中nums = [1,2,3]为例把求子集抽象为树型结构，如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210906190638.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目地址：https://leetcode-cn.com/problems/subsets/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span></span><br><span class="line"><span class="comment"> * 说明：解集不能包含重复的子集。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例: 输入: nums = [1,2,3] 输出: [ [3], [1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subsets</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path  = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line"></span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));  <span class="comment">// 收集子集，要放在终止添加的上面，否则会漏掉自己</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) {</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-子集II"><a href="#4-子集II" class="headerlink" title="4.子集II"></a>4.子集II</h1><p><a href="https://leetcode-cn.com/problems/subsets-ii/">力扣题目链接</a></p><ul><li>题目</li></ul><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</p><ul><li>思路分析</li></ul><p>此题和<strong>3.子集问题</strong>很类似，唯一的区别就是，本题需要进行去重操作，因为题目中要求了<strong>解集不能包含重复的子集。</strong></p><p>而<strong>nums数组中可能包含重复元素</strong></p><p>去重关键代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]){ <span class="comment">//去重操作(结果节不能有重复元素，要去重)</span></span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目链接：https://leetcode-cn.com/problems/subsets-ii/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span></span><br><span class="line"><span class="comment"> * 说明：解集不能包含重复的子集。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubsetsNoRepeat</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) {</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">//先给nums数组排序</span></span><br><span class="line"></span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line"></span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path)); <span class="comment">// 收集子集，要放在终止条件的上面，否则会漏掉自己</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.length) <span class="keyword">return</span>;  <span class="comment">//终止条件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]){ <span class="comment">//去重操作(结果节不能有重复元素，要去重)</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            backtracking(nums,i+<span class="number">1</span>); <span class="comment">//递归</span></span><br><span class="line"></span><br><span class="line">            path.removeLast();  <span class="comment">//回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-递增子序列"><a href="#5-递增子序列" class="headerlink" title="5.递增子序列"></a>5.递增子序列</h1><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。</span></span><br><span class="line"><span class="comment"> * 你可以按 任意顺序 返回答案。</span></span><br><span class="line"><span class="comment"> * 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: [4, 6, 7, 7] 输出:</span></span><br><span class="line"><span class="comment"> * [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/increasing-subsequences</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncreasingSubsequences</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备注：</span></span><br><span class="line"><span class="comment">     * 这种写法，输入[4,6,7,7],可以得到想要的输出，</span></span><br><span class="line"><span class="comment">     * 但是不能被LeetCode AC,原因不明</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) {</span><br><span class="line"></span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (path.size() &gt;= <span class="number">2</span>) result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;  <span class="comment">//去重</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] &gt;= nums[i-<span class="number">1</span>]){</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line"></span><br><span class="line">                backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                path.removeLast();</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//break;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        IncreasingSubsequences subsequences = <span class="keyword">new</span> IncreasingSubsequences();</span><br><span class="line">        <span class="keyword">int</span>[] nums = {<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>};</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; subsequences1 = subsequences.findSubsequences(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : subsequences1) {</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-全排列"><a href="#6-全排列" class="headerlink" title="6.全排列"></a>6.全排列</h1><p><a href="https://leetcode-cn.com/problems/permutations/">力扣题目链接</a></p><ul><li>题目</li></ul><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例: 输入: nums = [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</p><ul><li>思路分析</li></ul><p>每一次递归都遍历nums数组，然后将nums[i]加入到<code>List&lt;Integer&gt; path</code>中，继续递归，回溯。</p><p>如果path已经包含了nums[i],就跳过本次循环，进行下一次循环。</p><p>如果path.size() == nums.length，就return.</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个 没有重复 数字的序列，返回其所有可能的全排列。</span></span><br><span class="line"><span class="comment"> * 示例: 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/permutations/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutations</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) {</span><br><span class="line">        backtracking(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == path.size()){</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过判断path中是否存在数字，排除已经选择的数字</span></span><br><span class="line">            <span class="keyword">if</span> (path.contains(nums[i])){</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            backtracking(nums);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="7-全排列-II"><a href="#7-全排列-II" class="headerlink" title="7.全排列 II"></a>7.全排列 II</h1><p><a href="https://leetcode-cn.com/problems/permutations-ii/">力扣题目链接</a></p><ul><li>题目</li></ul><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>示例 1： 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]]</p><p>示例 2： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><ul><li>思路分析</li></ul><p><strong>要强调的是去重一定要对元素经行排序，这样我们才方便通过相邻的节点来判断是否重复使用了</strong>。</p><p>以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210906194935.png"></p><p>图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。</p><p><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1： 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]]</span></span><br><span class="line"><span class="comment"> * 示例 2： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/permutations-ii/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermutationNoRepeat</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) {</span><br><span class="line"></span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        backtracking(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) {</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; used[i-<span class="number">1</span>] == <span class="keyword">false</span>){</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="keyword">false</span>){</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                backtracking(nums);</span><br><span class="line"></span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯刷题笔记①</title>
      <link href="/posts/cac8.html"/>
      <url>/posts/cac8.html</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法简介"><a href="#回溯算法简介" class="headerlink" title="回溯算法简介"></a>回溯算法简介</h1><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><h2 id="回溯算法模板"><a href="#回溯算法模板" class="headerlink" title="回溯算法模板"></a>回溯算法模板</h2><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) {</span><br><span class="line">    if (终止条件) {</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1-组合问题"><a href="#1-组合问题" class="headerlink" title="1.组合问题"></a>1.组合问题</h1><p><a href="https://leetcode-cn.com/problems/combinations/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:<br>输入: n = 4, k = 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><ul><li>思路分析</li></ul><p>把组合问题抽象为如下树形结构：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210903133703.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合问题，返回[1,n]，中所有的k个数的组合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Combine</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) {</span><br><span class="line">        combineHelper(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineHelper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> startIndex)</span></span>{</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k){</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++){  <span class="comment">//剪枝优化</span></span><br><span class="line">            path.add(i);</span><br><span class="line">            combineHelper(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();   <span class="comment">//回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-组合总和III"><a href="#2-组合总和III" class="headerlink" title="2.组合总和III"></a>2.组合总和III</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-iii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]</p><p>示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</p><ul><li>思路分析</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210903134858.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，</span></span><br><span class="line"><span class="comment"> * 并且每种组合中不存在重复的数字。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]</span></span><br><span class="line"><span class="comment"> * 示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) {</span><br><span class="line"></span><br><span class="line">        combination(k,n,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combination</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> targetSum, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k){</span><br><span class="line">            <span class="keyword">if</span> (targetSum == sum){</span><br><span class="line">                result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">//如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; targetSum) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= <span class="number">9</span>-(k-path.size())+<span class="number">1</span>; i++) {</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line"></span><br><span class="line">            combination(k,targetSum,i+<span class="number">1</span>);  <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line"></span><br><span class="line">            path.removeLast(); <span class="comment">//回溯</span></span><br><span class="line">            sum -= i;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-电话号码的字母组合"><a href="#3-电话号码的字母组合" class="headerlink" title="3.电话号码的字母组合"></a>3.电话号码的字母组合</h1><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210903135147.png"></p><p>示例: 输入：”23” 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><p>说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序</p><ul><li>思路分析</li></ul><p>首先定义一个String[]数组，用来做数字和字母的映射</p><p><code>String[] numString = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};</code></p><p>然后从这个数组中取字符串进行组合即可</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210903141836.png"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationOfPhoneNumber</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//用来储存最终的结果</span></span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();  <span class="comment">//用来储存最终结果的每一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造一个String[],下标对应字符串</span></span><br><span class="line">        String[] numString = {<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>};</span><br><span class="line"></span><br><span class="line">        backtracking(digits,numString,<span class="number">0</span>);<span class="comment">//回溯的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String digits, String[] numString, <span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (num == digits.length()){</span><br><span class="line">            result.add(str.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取digits数字串的第num个数字</span></span><br><span class="line">        <span class="keyword">int</span> index = digits.charAt(num) - <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数字index对应的字符串</span></span><br><span class="line">        String string = numString[index];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string.length(); i++) {</span><br><span class="line">            str.append(string.charAt(i));<span class="comment">//处理</span></span><br><span class="line"></span><br><span class="line">            backtracking(digits,numString,num + <span class="number">1</span>); <span class="comment">//递归，注意num + 1</span></span><br><span class="line"></span><br><span class="line">            str.deleteCharAt(num); <span class="comment">//回溯</span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-组合总和"><a href="#4-组合总和" class="headerlink" title="4.组合总和"></a>4.组合总和</h1><p><a href="https://leetcode-cn.com/problems/combination-sum/">leetcode题目链接</a></p><ul><li>题目</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">所有数字（包括 target）都是正整数。</span><br><span class="line">解集不能包含重复的组合。</span><br><span class="line">示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]</span><br><span class="line"></span><br><span class="line">示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [   [2,2,2,2],   [2,3,3],   [3,5] ]</span><br></pre></td></tr></tbody></table></figure><ul><li>思路分析</li></ul><p>本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。</p><p>本题搜索的过程抽象成树形结构如下：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210903142615.png"></p><p>注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span></span><br><span class="line"><span class="comment"> * candidates 中的数字可以无限制重复被选取。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [[2,2,2,2],[2,3,3],[3,5]]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/combination-sum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationRepeatedSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="keyword">if</span> (candidates.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (sum == target){</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">continue</span>; <span class="comment">//剪枝优化</span></span><br><span class="line"></span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line"></span><br><span class="line">            backtracking(candidates,target,i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=================</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        CombinationRepeatedSum combination = <span class="keyword">new</span> CombinationRepeatedSum();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] cadidates = {<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>};</span><br><span class="line">        combination.combinationSum(cadidates,<span class="number">8</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-组合总和II"><a href="#5-组合总和II" class="headerlink" title="5.组合总和II"></a>5.组合总和II</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。</p><p>示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</p><p>示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [  [1,2,2],  [5] ]</p><ul><li>思路分析</li></ul><p><strong>本题的难点在于：集合（数组candidates）有重复元素，但还不能有重复的组合</strong>。</p><p>所以就要就行去重操作(首先对数组candidates进行排序，才能有效去重)</p><p>去重代码:</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 要对同一树层使用过的元素进行跳过,是一个去重操作</span><br><span class="line">if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-1]){</span><br><span class="line">    continue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span></span><br><span class="line"><span class="comment"> * candidates 中的每个数字在每个组合中只能使用一次。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为:</span></span><br><span class="line"><span class="comment"> * [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/combination-sum-ii</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationNoRepeatSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) {</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line"></span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum == target){</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) {<span class="comment">//sum + candidates[i] &lt;= target为剪枝操作</span></span><br><span class="line">            <span class="comment">// 要对同一树层使用过的元素进行跳过,是一个去重操作</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>]){</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line"></span><br><span class="line">            backtracking(candidates,target,i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        CombinationNoRepeatSum combination = <span class="keyword">new</span> CombinationNoRepeatSum();</span><br><span class="line">        <span class="keyword">int</span>[] cadidates = {<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>};</span><br><span class="line">        combination.combinationSum2(cadidates,<span class="number">5</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树刷题笔记</title>
      <link href="/posts/9a06.html"/>
      <url>/posts/9a06.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、求二叉搜索树的属性"><a href="#一、求二叉搜索树的属性" class="headerlink" title="一、求二叉搜索树的属性"></a>一、求二叉搜索树的属性</h1><h2 id="1-二叉搜索树的搜索"><a href="#1-二叉搜索树的搜索" class="headerlink" title="1.二叉搜索树的搜索"></a>1.二叉搜索树的搜索</h2><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826191632.png"></p><ul><li>思路分析</li></ul><p>利用二叉搜索树的性质，如果<code>val &lt; root.val </code>就向左遍历，<code>root = root.left</code>,</p><p>如果<code>val &gt;  root.val</code> 就向右遍历，<code>root = root.right,如果val == root.val</code>就返回root节点</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法一：迭代，利用二叉搜索树的特性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST3</span><span class="params">(TreeNode root,<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.val) root = root.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) root = root.right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法二：递归</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST2</span><span class="params">(TreeNode root,<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.val == val) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) <span class="keyword">return</span> searchBST2(root.left,val);</span><br><span class="line">    <span class="keyword">if</span> (val &gt; root.val) <span class="keyword">return</span> searchBST2(root.right,val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h2 id="2-验证二叉搜索树"><a href="#2-验证二叉搜索树" class="headerlink" title="2.验证二叉搜索树"></a>2.验证二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><p>节点的左子树只包含小于当前节点的数。</p><p>节点的右子树只包含大于当前节点的数。</p><p>所有左子树和右子树自身必须也是二叉搜索树。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826192437.png"></p><ul><li>思路分析</li></ul><p>利用中序遍历，遍历二叉搜索树，可以得到一个序列，如果这个序列是严格递增的，</p><p>则该二叉树是二叉搜索树。</p><ul><li><p>代码详情</p><p>提供两个方法：</p><p>方法一：利用中序遍历将二叉搜索树变为一个序列，判断这个序列 是否是升序的 &lt;=&gt; 是否是二叉搜索树</p><p>方法二：利用双指针判断中序遍历时二叉搜索树 是否是严格递增的</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法一：利用中序遍历将二叉搜索树变为一个序列，判断这个序列 是否是升序的 &lt;=&gt; 是否是二叉搜索树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历得到一个序列</span></span><br><span class="line">        infixOrder(root,result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常的BST按照中序遍历可以得到一个升序序列，所以可以以此来判断是不是一个BST</span></span><br><span class="line">        <span class="keyword">int</span> size = result.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="keyword">if</span> (result.get(i) &lt;= result.get(i-<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        infixOrder(root.left,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        infixOrder(root.right,result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**方法二：</span></span><br><span class="line"><span class="comment">     *利用双指针判断中序遍历时二叉搜索树 是否是严格递增的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST2</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        infixOrder2(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">infixOrder2</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        infixOrder2(root.left);  <span class="comment">//左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) {       <span class="comment">//中</span></span><br><span class="line">            <span class="keyword">if</span> (root.val &lt;= pre.val){</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pre = root;</span><br><span class="line">        infixOrder2(root.right);   <span class="comment">//右</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h2 id="3-二叉搜索树的最小绝对差"><a href="#3-二叉搜索树的最小绝对差" class="headerlink" title="3.二叉搜索树的最小绝对差"></a>3.二叉搜索树的最小绝对差</h2><p><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826193252.png"></p><p>提示：树中至少有两个节点</p><ul><li><p>思路分析</p><p>方法一：转为有序数组</p></li></ul><p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p><p><strong>注意是二叉搜索树</strong>，二叉搜索树可是有序的。</p><p>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了</p><p>方法二：双指针法</p><p>需要用一个pre节点记录一下cur节点的前一个节点。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826200513.png"></p><ul><li>代码详情</li></ul><p>方法一：把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p><p>方法二：在中序遍历的过程中，利用双指针，即pre指向cur的前一个，然后做差比较，取最小</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinusTwo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**方法一：</span></span><br><span class="line"><span class="comment">     * 把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        infixOrder(root,result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> size = result.size();</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) {</span><br><span class="line">            temp = result.get(i) - result.get(i-<span class="number">1</span>);</span><br><span class="line">            min = min &lt; temp ? min : temp;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        infixOrder(root.left,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        infixOrder(root.right,result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二：在中序遍历的过程中，利用双指针，即pre指向cur的前一个，然后做差比较，取最小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference2</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode cur)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        traversal(cur.left);<span class="comment">//左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>){ <span class="comment">//中</span></span><br><span class="line">            result = Math.min(result,cur.val - pre.val);</span><br><span class="line">        }</span><br><span class="line">        pre = cur;  <span class="comment">// 记录前一个</span></span><br><span class="line"></span><br><span class="line">        traversal(cur.right);  <span class="comment">//右</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h2 id="4-二叉搜索树中的众数"><a href="#4-二叉搜索树中的众数" class="headerlink" title="4.二叉搜索树中的众数"></a>4.二叉搜索树中的众数</h2><p><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><p>结点左子树中所含结点的值小于等于当前结点的值</p><p>结点右子树中所含结点的值大于等于当前结点的值</p><p>左子树和右子树都是二叉搜索树</p><p>示例：给定 BST [1,null,2,2],</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826200218.png"></p><p>返回[2].</p><p>提示：如果众数超过1个，不需考虑输出顺序</p><ul><li>思路分析</li></ul><p>在<a href="https://mp.weixin.qq.com/s/Hwzml6698uP3qQCC1ctUQQ">二叉树：搜索树的最小绝对差 </a>中我们就使用了pre指针和cur指针的技巧，这次又用上了。</p><p>弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。</p><p>而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。</p><p>代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>) { <span class="comment">// 第一个节点</span></span><br><span class="line">    count = <span class="number">1</span>; <span class="comment">// 频率为1</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) { <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">    count++;</span><br><span class="line">} <span class="keyword">else</span> { <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">pre = cur; <span class="comment">// 更新上一个节点</span></span><br></pre></td></tr></tbody></table></figure><p>那么如何只遍历一遍就取出所有的众数呢？</p><p>如果 <code>频率count 等于 maxCount（最大频率）</code>，当然要把这个元素加入到结果集中（以下代码为result数组），代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count == maxCount) { <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>是不是感觉这里有问题，result怎么能轻易就把元素放进去了呢，万一，这个maxCount此时还不是真正最大频率呢。</p><p>所以下面要做如下操作：</p><p>频率count 大于 maxCount的时候，不仅要更新maxCount，而且要清空结果集（以下代码为result数组），因为结果集之前的元素都失效了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &gt; maxCount) { <span class="comment">// 如果计数大于最大值</span></span><br><span class="line">    maxCount = count;   <span class="comment">// 更新最大频率</span></span><br><span class="line">    result.<span class="built_in">clear</span>();     <span class="comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindModeInBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; resCount;</span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">//用来计数</span></span><br><span class="line">    <span class="keyword">int</span> maxCount;  <span class="comment">//出现的最大次数</span></span><br><span class="line">    TreeNode pre;  <span class="comment">//cur的前一个指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root){</span><br><span class="line">        resCount = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        infix(root);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[resCount.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resCount.size(); i++) {</span><br><span class="line">            res[i] = resCount.get(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">infix</span><span class="params">(TreeNode cur)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        infix(cur.left);  <span class="comment">//左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span>){  <span class="comment">//第一个节点</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (pre.val != cur.val){  <span class="comment">//与前一个节点数值不同</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{   <span class="comment">//与前一个节点数值相同</span></span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == maxCount){ <span class="comment">//如果和出现最多的频率相同</span></span><br><span class="line">            resCount.add(cur.val);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount){</span><br><span class="line">            resCount.clear();  <span class="comment">//将resCount清空</span></span><br><span class="line">            maxCount = count;  <span class="comment">//更新maxCount</span></span><br><span class="line">            resCount.add(cur.val);  <span class="comment">//将节点的值加进去</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pre = cur;  <span class="comment">//更新上一个指针</span></span><br><span class="line"></span><br><span class="line">        infix(cur.right);  <span class="comment">// 右</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h2 id="5-把二叉搜索树转换为累加树"><a href="#5-把二叉搜索树转换为累加树" class="headerlink" title="5.把二叉搜索树转换为累加树"></a>5.把二叉搜索树转换为累加树</h2><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826201645.png"></p><ul><li>思路分析</li></ul><p><strong>其实这就是一棵树，大家可能看起来有点别扭，换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]，是不是感觉这就简单了。</strong></p><p>为什么变成数组就是感觉简单了呢？</p><p>因为数组大家都知道怎么遍历啊，从后向前，挨个累加就完事了，这换成了二叉搜索树，看起来就别扭了一些是不是。</p><p>那么知道如何遍历这个二叉树，也就迎刃而解了，<strong>从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历（按照右 中 左）</strong></p><p><strong>这个二叉树，然后顺序累加就可以了</strong>。</p><ul><li><p>代码详情</p><p>依然使用双指针， 利用<code>cur.val += pre.val</code>,来更新当前节点的值</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），</span></span><br><span class="line"><span class="comment"> * 使每个节点 node的新值等于原树中大于或等于node.val的值之和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTToGreaterSumTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Uninfix(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照右 中 左 的顺序 遍历 累加 ，然后得到一个累加树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Uninfix</span><span class="params">(TreeNode cur)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        Uninfix(cur.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) cur.val += pre.val;</span><br><span class="line">        pre = cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        Uninfix(cur.left);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><hr><h1 id="二、树的公共祖先问题"><a href="#二、树的公共祖先问题" class="headerlink" title="二、树的公共祖先问题"></a>二、树的公共祖先问题</h1><h2 id="1-二叉树的最近公共祖先"><a href="#1-二叉树的最近公共祖先" class="headerlink" title="1.二叉树的最近公共祖先"></a>1.二叉树的最近公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826204338.png"></p><ul><li>思路分析</li></ul><p><a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">二叉树的最近公共祖先</a></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**找二叉树的公共祖先，这题不太好理解，最好是背一下</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosestAncestor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q || root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h2 id="2-二叉搜索树的最近公共祖先"><a href="#2-二叉搜索树的最近公共祖先" class="headerlink" title="2.二叉搜索树的最近公共祖先"></a>2.二叉搜索树的最近公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826205759.png"></p><ul><li>思路分析</li></ul><p>本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。</p><p>在有序树里，如果判断一个节点的左子树里有p，右子树里有q呢？</p><p>其实只要从上到下遍历的时候，cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了。</p><p>理解这一点，本题就很好解了。</p><p>和<a href="https://mp.weixin.qq.com/s/n6Rk3nc_X3TSkhXHrVmBTQ">二叉树：公共祖先问题</a>不同，普通二叉树求最近公共祖先需要使用回溯，从底向上来查找，二叉搜索树就不用了，因为搜索树有序（相当于自带方向），那么只要从上向下遍历就可以了。</p><p>那么我们可以采用前序遍历（其实这里没有中节点的处理逻辑，遍历顺序无所谓了）。</p><p>如图所示：p为节点3，q为节点5</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826210049.png"></p><p>可以看出直接按照指定的方向，就可以找到节点4，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉搜索树的公共祖先</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosestAncestorBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一，递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//root.val的值不在[p,q](假设p.val &lt; q.val),则递归查找</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) {</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) {</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            <span class="comment">//root.val的值在区间内，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法二：迭代法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor2</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) root = root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) root = root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><hr><h1 id="三、二叉搜索树的修改与构造"><a href="#三、二叉搜索树的修改与构造" class="headerlink" title="三、二叉搜索树的修改与构造"></a>三、二叉搜索树的修改与构造</h1><h2 id="1-二叉搜索树中的插入操作"><a href="#1-二叉搜索树中的插入操作" class="headerlink" title="1.二叉搜索树中的插入操作"></a>1.二叉搜索树中的插入操作</h2><p><a href="">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826211128.png"></p><p>提示：</p><p>给定的树上的节点数介于 0 和 10^4 之间</p><p>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</p><p>-10^8 &lt;= val &lt;= 10^8</p><p>新值和原始二叉搜索树中的任意节点值都不同</p><ul><li>思路分析</li></ul><p>利用二叉搜索树的性质，遍历，然后找到空节点插入即可，插入时注意插入的位置(左边还是右边)</p><ul><li><p>代码详情</p><p>提供两种方法，详情看代码以及注释</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。</span></span><br><span class="line"><span class="comment"> * 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/insert-into-a-binary-search-tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertIntoBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**方法一：迭代</span></span><br><span class="line"><span class="comment">     * 利用两个指针，当cur指针为空时，说明找到合适的位置，</span></span><br><span class="line"><span class="comment">     * 如果是val &lt; cur.val 的条件使得cur 指向 cur.left，后为空，则让pre.left = new TreeNode(val);</span></span><br><span class="line"><span class="comment">     * 如果是val &gt; cur.val 的条件使得cur 指向 cur.right，后为空，则让pre.right = new TreeNode(val);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST2</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line"></span><br><span class="line">            pre = cur;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (val &lt; cur.val) {</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">if</span> (cur == <span class="keyword">null</span>) {</span><br><span class="line">                    pre.left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; cur.val) {</span><br><span class="line">                cur = cur.right;</span><br><span class="line">                <span class="keyword">if</span> (cur == <span class="keyword">null</span>) {</span><br><span class="line">                    pre.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二：递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root,<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val) root.right = insertIntoBST(root.right,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val) root.left = insertIntoBST(root.left,val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h2 id="2-删除二叉搜索树中的节点"><a href="#2-删除二叉搜索树中的节点" class="headerlink" title="2.删除二叉搜索树中的节点"></a>2.删除二叉搜索树中的节点</h2><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p><p>示例:</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826220440.png"></p><ul><li>思路分析</li></ul><p><a href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">删除二叉搜索树中的节点</a></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteNodeInBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//没找到要删除的节点，直接返回null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val == val){</span><br><span class="line">            <span class="comment">//第一种情况，root节点的左右孩子都为空，说明要删除的是叶子节点，直接返回null</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第二种情况，左孩子为空，返回右孩子</span></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第三种情况，右孩子为空，返回左孩子</span></span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第四种情况，左右孩子都不为空，把，左孩子添加到以右孩子为头节点的树的最左边</span></span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                TreeNode cur = root.right;</span><br><span class="line">                <span class="keyword">while</span> (cur.left != <span class="keyword">null</span>){ <span class="comment">//一直往左遍历，找到root节点的右孩子的最左边</span></span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                }</span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里相当于把新的节点返回给上一层，上一层就要用 root-&gt;left 或者 root-&gt;right接住</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.val) root.left = deleteNode(root.left,val);</span><br><span class="line">        <span class="keyword">if</span> (val &gt; root.val) root.right = deleteNode(root.right,val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h2 id="3-修剪二叉搜索树"><a href="#3-修剪二叉搜索树" class="headerlink" title="3.修剪二叉搜索树"></a>3.修剪二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826221920.png"></p><ul><li>思路分析</li></ul><p><a href="https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">修剪二叉搜索树</a></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**这题不太好理解，最好是背住代码！！！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目：</span></span><br><span class="line"><span class="comment"> * 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，</span></span><br><span class="line"><span class="comment"> * 使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构</span></span><br><span class="line"><span class="comment"> * （即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。</span></span><br><span class="line"><span class="comment"> * 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/trim-a-binary-search-tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrimBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low){ <span class="comment">// 寻找符合区间[low, high]的节点</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high){  <span class="comment">// 寻找符合区间[low, high]的节点</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码走到这里，说明root.val的值，在[low,high]区间内</span></span><br><span class="line">        root.left = trimBST(root.left,low,high);  <span class="comment">// root-&gt;left接入符合条件的左孩子</span></span><br><span class="line">        root.right = trimBST(root.right,low,high);  <span class="comment">// root-&gt;right接入符合条件的右孩子</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl给大家大体分分类</strong>。</p><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序， <a href="https://mp.weixin.qq.com/s/Osw4LQD2xVUnCJ-9jrYxJA">二叉树：找所有路径</a>也用了前序，这是为了方便让父节点指向子节点。</p><p>所以求普通二叉树的属性还是要具体问题具体分析。</p><br><p>参考：以上题目解答来自：<a href="https://programmercarl.com/">代码随想录</a>，感谢carl哥！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树刷题笔记②</title>
      <link href="/posts/abcb.html"/>
      <url>/posts/abcb.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-左叶子之和"><a href="#1-左叶子之和" class="headerlink" title="1.左叶子之和"></a>1.左叶子之和</h1><p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>计算给定二叉树的所有左叶子之和。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210824134426.png"></p><ul><li>思路分析</li></ul><p><strong>首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。</strong></p><p>因为题目中其实没有说清楚左叶子究竟是什么节点，那么我来给出左叶子的明确定义：<strong>如果左节点不为空，且左节点没有左右孩子，那么这个节点就是左叶子</strong></p><p>如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>){</span><br><span class="line">          <span class="comment">//处理逻辑</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码实现</li></ul><p>分别使用递归法和迭代法实现</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算给定二叉树的所有左叶子之和。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumOfLeftLeaves</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法求二叉树的所有左叶子节点之和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//递归终止条件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左叶子节点的条件</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>){</span><br><span class="line">            mid = root.left.val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归root节点的左子树和右子树</span></span><br><span class="line">        <span class="keyword">int</span> left = sumOfLeftLeaves(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = sumOfLeftLeaves(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把所有找到的左叶子节点求和</span></span><br><span class="line">        <span class="keyword">int</span> sum = mid + left + right;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代法，使用栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves2</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="comment">//左叶子节点的条件</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>){</span><br><span class="line">                sum += root.left.val;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-找树左下角的值"><a href="#2-找树左下角的值" class="headerlink" title="2.找树左下角的值"></a>2.找树左下角的值</h1><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/v">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉树，在树的最后一行找到最左边的值。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210824135011.png"></p><ul><li>思路分析</li></ul><p>直接利用层序遍历，找到每一层最左边的节点即可</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BottomLeftValue</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) result = cur.val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-最大二叉树"><a href="#3-最大二叉树" class="headerlink" title="3.最大二叉树"></a>3.最大二叉树</h1><p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><p>  二叉树的根是数组中的最大元素。</p><p>  左子树是通过数组中最大值左边部分构造出的最大二叉树。</p><p>  右子树是通过数组中最大值右边部分构造出的最大二叉树。</p><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p>示例 ：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210824142814.png"></p><ul><li><p>思路分析</p><p>最大二叉树的构建过程如下：</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjuvioezg30dw0921ck.gif"></p><p>构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructMaximumBinaryTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> traversal(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">traversal</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{ <span class="comment">//递归的参数和返回值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分割点下标,因为下面比较要用到，所以要赋初始值</span></span><br><span class="line">        <span class="keyword">int</span> maxValueIndex = left;</span><br><span class="line">        <span class="comment">//寻找分割点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[maxValueIndex]) maxValueIndex = i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[maxValueIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左闭右开：[left, maxValueIndex)</span></span><br><span class="line">        root.left = traversal(nums,left,maxValueIndex);</span><br><span class="line">        <span class="comment">// 左闭右开：[maxValueIndex + 1, right)</span></span><br><span class="line">        root.right = traversal(nums,maxValueIndex+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-将有序数组转为二叉搜索树"><a href="#4-将有序数组转为二叉搜索树" class="headerlink" title="4.将有序数组转为二叉搜索树"></a>4.将有序数组转为二叉搜索树</h1><p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826170344.png"></p><ul><li>思路分析</li></ul><p>如果根据数组构造一颗二叉树。</p><p><strong>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong>。</p><p>本题其实要比<strong>第三题 ：最大二叉树</strong>简单一些，因为有序数组构造二叉搜索树，寻找分割点就比较容易了。</p><p>分割点就是数组中间位置的节点。</p><p>那么为问题来了，如果数组长度为偶数，中间节点有两个，取哪一个？</p><p>取哪一个都可以，只不过构成了不同的平衡二叉搜索树。</p><p>例如：输入：[-10,-3,0,5,9]</p><p>如下两棵树，都是这个数组的平衡二叉搜索树：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826173343.png"></p><p>如果要分割的数组长度为偶数的时候，中间元素为两个，是取左边元素 就是树1，取右边元素就是树2。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**题目：</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</span></span><br><span class="line"><span class="comment"> * 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题可以不用考虑是不是高度平衡的</span></span><br><span class="line"><span class="comment"> * 另外，此题和 最大二叉树 有点类似</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最大二叉树题目：</span></span><br><span class="line"><span class="comment"> * 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</span></span><br><span class="line"><span class="comment"> * 二叉树的根是数组中的最大元素。</span></span><br><span class="line"><span class="comment"> * 左子树是通过数组中最大值左边部分构造出的最大二叉树。</span></span><br><span class="line"><span class="comment"> * 右子树是通过数组中最大值右边部分构造出的最大二叉树。</span></span><br><span class="line"><span class="comment"> * 通过给定的数组构建最大二叉树，并且输出这个树的根节点。</span></span><br><span class="line"><span class="comment"> * 题目地址：https://leetcode-cn.com/problems/maximum-binary-tree/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertSortedArrayToBST</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = traversal(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">traversal</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左闭右闭</span></span><br><span class="line">        root.left = traversal(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = traversal(nums,mid+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-合并二叉树"><a href="#5-合并二叉树" class="headerlink" title="5.合并二叉树"></a>5.合并二叉树</h1><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210826165331.png"></p></li></ul><ul><li>思路分析</li></ul><p>以Tree1为要返回的树，如果对应的节点中，有其中一个为空，就返回另一个，如果两个都不为空，则把节点的值相加</p><p>然后递归两棵树对应的左孩子和右孩子，最后返回Tree1的头节点</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeTrees</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>{</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">       <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">       root1.val += root2.val;</span><br><span class="line"></span><br><span class="line">       root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">       root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> root1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>1.前序、中序和后序遍历考虑使用栈</li><li>2.层序遍历考虑使用队列</li><li>3.其它情况先考虑队列，再考虑使用栈</li></ul><br><p>参考：<a href="https://programmercarl.com/">代码随想录</a>，感谢carl哥！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树刷题笔记①</title>
      <link href="/posts/6b0a.html"/>
      <url>/posts/6b0a.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-反转二叉树"><a href="#1-反转二叉树" class="headerlink" title="1.反转二叉树"></a>1.反转二叉树</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>反转一颗二叉树</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823095807.png"></p><ul><li><p>代码详情</p><p>1.DFS递归，可以使用前序和后序遍历，交换当前节点的左右孩子</p><p>2.BFS，利用层序遍历，交换当前节点的左右孩子</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvertBinaryTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**DFS递归</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不行，</span></span><br><span class="line"><span class="comment">     * 因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        invert(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invert</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        TreeNode temp = <span class="keyword">null</span>;</span><br><span class="line">        temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        invert(root.left);</span><br><span class="line">        invert(root.right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**BFS层序遍历</span></span><br><span class="line"><span class="comment">     *利用层序遍历，交换当前节点的左右孩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTreeBFS</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换当前层的节点的左右孩子</span></span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                temp = cur.left;</span><br><span class="line">                cur.left = cur.right;</span><br><span class="line">                cur.right = temp;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="2-对称二叉树"><a href="#2-对称二叉树" class="headerlink" title="2.对称二叉树"></a>2.对称二叉树</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/">leetcode题目链接</a></p><ul><li>题目:给定一个二叉树，检查它是否是镜像对称的。</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823100057.png"></p><h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><ul><li>思路分析</li></ul><p><strong>首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！</strong></p><p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>其实我们要比较的是两个树（这两个树是根节点的左右子树）</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。</p><p>那么如果比较呢？</p><p>比较的是两个子树的里侧和外侧的元素是否相等。如图所示：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823100721.png"></p><p>那么遍历的顺序应该是什么样的呢？</p><p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p><p><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p><p>但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方法一：递归法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">   }</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(TreeNode left, TreeNode right)</span> </span>{</span><br><span class="line"></span><br><span class="line">       <span class="comment">//首先判断节点为空的情况</span></span><br><span class="line">       <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">       <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">       <span class="keyword">boolean</span> outside = compare(left.left,right.right); <span class="comment">// 比较左节点的左孩子 和 右节点的右孩子</span></span><br><span class="line">       <span class="keyword">boolean</span> inside = compare(left.right,right.left); <span class="comment">// 比较左节点的右孩子 和 右节点的左孩子</span></span><br><span class="line">       <span class="keyword">boolean</span> isSame = outside &amp;&amp; inside;   <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">       <span class="keyword">return</span> isSame;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h2 id="方法二：迭代法"><a href="#方法二：迭代法" class="headerlink" title="方法二：迭代法"></a>方法二：迭代法</h2><ul><li><p>思路分析</p><p>通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif"></p></li><li><p>代码详情</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二：迭代法(使用一个队列实现)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric2</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root.left); <span class="comment">// 将左子树头结点加入队列</span></span><br><span class="line">        queue.offer(root.right); <span class="comment">// 将右子树头结点加入队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){ <span class="comment">// 接下来就要判断这这两个树是否相互翻转</span></span><br><span class="line">            TreeNode leftNode = queue.poll();</span><br><span class="line">            TreeNode rightNode = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> &amp;&amp; rightNode == <span class="keyword">null</span>){ <span class="comment">// 左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> || rightNode == <span class="keyword">null</span> || leftNode.val != rightNode.val){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            queue.offer(leftNode.left);   <span class="comment">// 加入左节点左孩子</span></span><br><span class="line">            queue.offer(rightNode.right); <span class="comment">// 加入右节点右孩子</span></span><br><span class="line">            queue.offer(leftNode.right);  <span class="comment">// 加入左节点右孩子</span></span><br><span class="line">            queue.offer(rightNode.left);  <span class="comment">// 加入右节点左孩子</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-完全二叉树的节点个数"><a href="#3-完全二叉树的节点个数" class="headerlink" title="3.完全二叉树的节点个数"></a>3.完全二叉树的节点个数</h1><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给出一个完全二叉树，求出该树的节点个数。</p></li></ul><h2 id="方法一：层序遍历"><a href="#方法一：层序遍历" class="headerlink" title="方法一：层序遍历"></a>方法一：层序遍历</h2><ul><li><p>思路分析</p><p>遍历模板稍稍修改一下，记录遍历的节点数量就可以了。</p></li><li><p>代码详情</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**方法一</span></span><br><span class="line"><span class="comment">    * 利用层序遍历的模板，统计二叉树的节点个数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">//LinkedList可以作为Queue的实现类</span></span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.offer(root);   <span class="comment">//将根节点加入队列</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">           <span class="keyword">int</span> size = queue.size(); <span class="comment">//取出当前队列的大小</span></span><br><span class="line"></span><br><span class="line">           TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//将队列中的元素依次取出，然后让其左右子树(如果不为空的话)入队列</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">               count++;   <span class="comment">//记录当前二叉树的节点个数</span></span><br><span class="line">               cur = queue.poll();</span><br><span class="line">               <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">               <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h2 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h2><ul><li>思路分析</li></ul><p>1.确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getNodesNum(TreeNode root) { }</span><br></pre></td></tr></tbody></table></figure><p>2.确定终止条件：如果为空节点的话，就返回0，表示节点数为0。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (root == null) return 0;   </span><br></pre></td></tr></tbody></table></figure><p>3.确定单层递归的逻辑：先求它的左子树的节点数量，再求的右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int leftNum = getNodesNum(root.left);  //左</span><br><span class="line">int rightNum = getNodesNum(root.right);  //右</span><br><span class="line">int treeNum = leftNum + rightNum + 1;  //中</span><br><span class="line">return treeNum;</span><br></pre></td></tr></tbody></table></figure><p>java整体代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**方法二</span></span><br><span class="line"><span class="comment">     * 利用递归统计二叉树的节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNode</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> getNodesNum(root);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNodesNum</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftNum = getNodesNum(root.left);  <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">int</span> rightNum = getNodesNum(root.right);  <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">int</span> treeNum = leftNum + rightNum + <span class="number">1</span>;  <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">return</span> treeNum;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h1 id="4-平衡二叉树"><a href="#4-平衡二叉树" class="headerlink" title="4.平衡二叉树"></a>4.平衡二叉树</h1><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823103347.png" alt="image-20210823103345548"></p><ul><li>二叉树的高度与深度</li></ul><p>​      二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</p><p>​      二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823103756.png"></p><ul><li>代码详情</li></ul><p>下面的方法通过层序遍历获得当前节点距离叶子节点的高度</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法可以获取当前root节点距离叶子节点的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">levelOrder</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> high = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            TreeNode cur;</span><br><span class="line">            high++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>然后再用栈来模拟前序遍历，遍历每一个节点的时候，再去判断左右孩子的高度是否符合，代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**:迭代法，使用层序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 用栈来模拟前序遍历，遍历每一个节点的时候，</span></span><br><span class="line"><span class="comment">     * 再去判断左右孩子的高度是否符合，代码如下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line">            cur = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(levelOrder(cur.left) - levelOrder(cur.right)) &gt; <span class="number">1</span>){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) stack.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) stack.push(cur.right);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h1 id="5-二叉树的所有路径"><a href="#5-二叉树的所有路径" class="headerlink" title="5. 二叉树的所有路径"></a>5. 二叉树的所有路径</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-paths/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823110448.png"></p><ul><li>思路分析</li></ul><p>这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。</p><p>在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。</p><p>前序遍历以及回溯的过程如图：</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210823111217.png"></p><p>我们先使用递归的方式，来做前序遍历。<strong>要知道递归和回溯就是一家的，本题也需要回溯。</strong></p><ul><li>递归三部曲</li></ul><p>1.递归函数函数参数以及返回值</p><p>要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, LinkedList&lt;Integer&gt; path, List&lt;String&gt; result)</span></span></span><br></pre></td></tr></tbody></table></figure><p>2.递归终止条件</p><p>当 root不为空，其左右孩子都为空的时候，就找到叶子节点。</p><p>所以本题的终止条件是：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历到了叶子节点</span></span><br><span class="line"><span class="comment">//将path保存的节点值，全部转为字符串sPath,这样就得到了路径，最后放入result集合中</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">int</span> size = path.size();</span><br><span class="line">            String sPath = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) {</span><br><span class="line">                sPath += path.get(i);</span><br><span class="line">                sPath += <span class="string">"-&gt;"</span>;</span><br><span class="line">            }</span><br><span class="line">            sPath += path.get(size - <span class="number">1</span>);   <span class="comment">//这里记录最后一个节点(叶子节点)，因为输出格式需要</span></span><br><span class="line">            result.add(sPath);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><p>if花括号里面的是，终止的处理逻辑</p><p>3.单层递归逻辑</p><p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.add(root.val);  <span class="comment">//将当前节点值加入到path集合中</span></span><br></pre></td></tr></tbody></table></figure><p>然后是递归和回溯的过程，上面说过没有判断root是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了(所以说能进递归函数的root节点一定是不为空的)。</p><p>所以递归前要加上判断语句，下面要递归的节点是否为空，如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="keyword">null</span>){</span><br><span class="line">    traversal(root.left,path,result); <span class="comment">//递归</span></span><br><span class="line">    path.removeLast();  <span class="comment">//回溯</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root.right != <span class="keyword">null</span>){</span><br><span class="line">    traversal(root.right,path,result); <span class="comment">//递归</span></span><br><span class="line">    path.removeLast();  <span class="comment">//回溯</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>整体代码</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.colorfor.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathsOfTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">treePaths</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//result集合作为最后的结果</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//path集合保存递归过程中的节点的值</span></span><br><span class="line">        traversal(root,path,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, LinkedList&lt;Integer&gt; path, List&lt;String&gt; result)</span> </span>{</span><br><span class="line">        path.add(root.val);  <span class="comment">//将当前节点值加入到path集合中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历到了叶子节点</span></span><br><span class="line">        <span class="comment">//将path保存的节点值，全部转为字符串sPath,这样就得到了路径，最后放入result集合中</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">int</span> size = path.size();</span><br><span class="line">            String sPath = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) {</span><br><span class="line">                sPath += path.get(i);</span><br><span class="line">                sPath += <span class="string">"-&gt;"</span>;</span><br><span class="line">            }</span><br><span class="line">            sPath += path.get(size - <span class="number">1</span>);</span><br><span class="line">            result.add(sPath);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>){</span><br><span class="line">            traversal(root.left,path,result); <span class="comment">//递归</span></span><br><span class="line">            path.removeLast();  <span class="comment">//回溯</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>){</span><br><span class="line">            traversal(root.right,path,result); <span class="comment">//递归</span></span><br><span class="line">            path.removeLast();  <span class="comment">//回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-----------main----------------</span></span><br><span class="line">   <span class="comment">/* public static void main(String[] args) {</span></span><br><span class="line"><span class="comment">        PathsOfTree tree = new PathsOfTree();</span></span><br><span class="line"><span class="comment">        TreeNode root = new TreeNode(1);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        TreeNode node2 = new TreeNode(2);</span></span><br><span class="line"><span class="comment">        TreeNode node3 = new TreeNode(3);</span></span><br><span class="line"><span class="comment">        root.left = node2;</span></span><br><span class="line"><span class="comment">        root.right = node3;</span></span><br><span class="line"><span class="comment">        node2.left = new TreeNode(4);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        List&lt;String&gt; strings = tree.treePaths(root);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for (String string : strings) {</span></span><br><span class="line"><span class="comment">            System.out.println(string);</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-路径总和"><a href="#6-路径总和" class="headerlink" title="6.路径总和"></a>6.路径总和</h1><p><a href="https://leetcode-cn.com/problems/path-sum/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例: 给定如下二叉树，以及目标和 sum = 22，</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210824140342.png"></p><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><ul><li>代码详情</li></ul><p>此题可在第5题代码的基础上稍加修改得到</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root,<span class="keyword">int</span> targetSum)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        traversal(root,path,result,targetSum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.contains(targetSum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, LinkedList&lt;Integer&gt; path, List&lt;Integer&gt; result,<span class="keyword">int</span> targetSum)</span> </span>{</span><br><span class="line">        path.add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">int</span> size = path.size();</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                sum += path.get(i);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            result.add(sum);</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) {</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>){</span><br><span class="line">            traversal(root.left,path,result,targetSum);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>){</span><br><span class="line">            traversal(root.right,path,result,targetSum);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-----------main----------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        PathSum tree = <span class="keyword">new</span> PathSum();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode node2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        TreeNode node3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.left = node2;</span><br><span class="line">        root.right = node3;</span><br><span class="line">        node2.left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b = tree.hasPathSum(root, <span class="number">4</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的层序遍历</title>
      <link href="/posts/bd66.html"/>
      <url>/posts/bd66.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-二叉树的层序遍历"><a href="#1-二叉树的层序遍历" class="headerlink" title="1.二叉树的层序遍历"></a>1.二叉树的层序遍历</h1><ul><li><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">leetcode题目链接</a></p></li><li><p>题目</p><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）</p></li></ul><p> <img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821202052.png"></p><ul><li><p>思路分析</p><p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif"></p></li><li><p>代码详情</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode {</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode left;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) {</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的层序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LevelOrder</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回层序遍历的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root){</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LinkedList可以作为Queue的实现类</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);   <span class="comment">//将根节点加入队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size(); <span class="comment">//取出当前队列的大小</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将队列中的元素依次取出，然后让其左右子树(如果不为空的话)入队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将每层遍历的结果放入result集合中</span></span><br><span class="line">            result.add(list);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>这份代码也可以作为二叉树层序遍历的模板</strong>,十分重要，一定要会</p><br><h1 id="2-二叉树的层次遍历-II"><a href="#2-二叉树的层次遍历-II" class="headerlink" title="2.二叉树的层次遍历 II"></a>2.二叉树的层次遍历 II</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p></li><li><p>代码详情</p><p>此题跟第一题差不多，可以使用<code>Collections.reverse()方法</code>，或者使用栈把第一题的结果反转一下即可，</p><p>直接给出代码</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，自底向上输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LevelOrder2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回层序遍历的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root){</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;List&lt;Integer&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LinkedList可以作为Queue的实现类</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);   <span class="comment">//将根节点加入队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size(); <span class="comment">//取出当前队列的大小</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将队列中的元素依次取出，然后让其左右子树(如果不为空的话)入队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将每层遍历的结果先放入stack</span></span><br><span class="line">            stack.push(list);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将栈中保存的每层的遍历结果，依次弹出，然后加入到result集合中</span></span><br><span class="line">        <span class="comment">//这样就实现了二叉树自底向上的层序遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line">            result.add(stack.pop());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="3-二叉树的右视图"><a href="#3-二叉树的右视图" class="headerlink" title="3.二叉树的右视图"></a>3.二叉树的右视图</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821203044.png"></p></li><li><p>思路分析</p></li></ul><p>层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树的 根节点 root，想象自己站在它的右侧，</span></span><br><span class="line"><span class="comment"> * 按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightSideView</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回层序遍历的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">levelOrder</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LinkedList可以作为Queue的实现类</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);   <span class="comment">//将根节点加入队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size(); <span class="comment">//取出当前队列的大小</span></span><br><span class="line">            LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将队列中的头元素取出，然后让其左右子树(如果不为空的话)入队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果是最后一个，就加入result集合</span></span><br><span class="line">                <span class="keyword">if</span> (i == size-<span class="number">1</span>) result.add(cur.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="4-二叉树的层平均值"><a href="#4-二叉树的层平均值" class="headerlink" title="4.二叉树的层平均值"></a>4.二叉树的层平均值</h1><p><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821203549.png"></p></li></ul><ul><li><p>代码详情</p><p>本题就是层序遍历的时候把一层求个总和在取一个均值。</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AverageOfLevels</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        List&lt;Double&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);  <span class="comment">//根节点入队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> size = queue.size(); <span class="comment">// 获取队列的大小</span></span><br><span class="line">            <span class="keyword">double</span> average = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                sum = sum + cur.val; <span class="comment">// sum累加，把每层的节点值相加</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == size-<span class="number">1</span>){ <span class="comment">// 遇到每层的最后一个节点，求该层的平均值</span></span><br><span class="line">                    average = sum / size;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">//让左右子树(如果不为空的话)入队列</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line">            result.add(average);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="5-N叉树的层序遍历"><a href="#5-N叉树的层序遍历" class="headerlink" title="5.N叉树的层序遍历"></a>5.N叉树的层序遍历</h1><p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。</p><p>例如，给定一个 3叉树 :</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821203829.png"></p></li></ul><p>返回其层序遍历:</p><p>[ [1], [3,2,4], [5,6] ]</p><ul><li>代码详情</li></ul><p>这道题依旧是模板题，只不过一个节点有多个孩子了</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*public class Node {</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">}*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NTreeLevelOrder</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root){</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);  <span class="comment">//将根节点加入队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            Node cur = <span class="keyword">null</span>;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">//队列的头节点出队列，并将节点的值加入该层list集合</span></span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果该节点的子节点不为空，则全部加入队列中</span></span><br><span class="line">                <span class="keyword">if</span> (cur.children != <span class="keyword">null</span>){</span><br><span class="line">                    List&lt;Node&gt; children = cur.children;</span><br><span class="line">                    <span class="keyword">int</span> len = children.size();</span><br><span class="line">                    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (index &lt; len){</span><br><span class="line">                        queue.offer(children.get(index++));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将当前层的节点值集合list加入到result集合中</span></span><br><span class="line">            result.add(list);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><h1 id="6-在每个树行中找最大值"><a href="#6-在每个树行中找最大值" class="headerlink" title="6.在每个树行中找最大值"></a>6.在每个树行中找最大值</h1><p><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">leetcode题目链接</a></p><ul><li><p>题目</p><p>您需要在二叉树的每一行中找到最大的值。</p></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821204715.png"></p><ul><li>代码详情</li></ul><p>层序遍历，取每一层的最大值</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindLargestInTreeRow</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestValues</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);  <span class="comment">//将根节点加入到队列中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> maxRow = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将遍历当前层的节点，找出最大值，保存在maxRow中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                temp = cur.val;</span><br><span class="line">                maxRow = temp &gt; maxRow  ? temp : maxRow;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前节点的左右子树不为空，则加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            result.add(maxRow);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="7-填充每个节点的下一个右侧节点指针"><a href="#7-填充每个节点的下一个右侧节点指针" class="headerlink" title="7.填充每个节点的下一个右侧节点指针"></a>7.填充每个节点的下一个右侧节点指针</h1><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() {}</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p><img src="https://img-blog.csdnimg.cn/20210203152044855.jpg"></p></li></ul><ul><li>思路分析</li></ul><p>本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，</p><p>然后在遍历的时候让当前节点的next域指向下一个节点（next）就可以了</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。</span></span><br><span class="line"><span class="comment"> * 如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextConnectRight</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);  <span class="comment">//将根节点加入队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = queue.size(); <span class="comment">//获取队列的大小</span></span><br><span class="line"></span><br><span class="line">            Node cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!queue.isEmpty()){</span><br><span class="line">                cur = queue.poll();   <span class="comment">//使用cur指针，指向本层的第一个节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前节点的左右子节点不为空，将左右子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Node next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) { <span class="comment">//由于本层的第一个节点已经出队列，所以i从1开始</span></span><br><span class="line">                next = queue.poll();     <span class="comment">//让cur右边的节点出队列</span></span><br><span class="line">                cur.next = next;      <span class="comment">//cur的next域指向cur右边的节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前节点的左右子节点不为空，将左右子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (next.left != <span class="keyword">null</span>) queue.offer(next.left);</span><br><span class="line">                <span class="keyword">if</span> (next.right != <span class="keyword">null</span>) queue.offer(next.right);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//让cur往右边移动一位，为下一次循环做准备</span></span><br><span class="line">                cur = next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关联题目:<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">填充每个节点的下一个右侧节点指针II</a></p><br><h1 id="8-二叉树的最大深度"><a href="#8-二叉树的最大深度" class="headerlink" title="8.二叉树的最大深度"></a>8.二叉树的最大深度</h1><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">leetcode题目链接</a></p><ul><li>题目</li></ul><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821210453.png"></p><p>返回它的最大深度 3 。</p><ul><li>代码详情</li></ul><p>本题依旧使用层序遍历，每遍历一层，二叉树的深度就加1</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxDepthOfTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line"></span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            depth++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><h1 id="9-二叉树的最小深度"><a href="#9-二叉树的最小深度" class="headerlink" title="9.二叉树的最小深度"></a>9.二叉树的最小深度</h1><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210821211016.png" alt="image-20210821211015337"></p></li><li><p>代码详情</p></li></ul><p>相对于 104.二叉树的最大深度 ，本题还也可以使用层序遍历的方式来解决，思路是一样的。</p><p><strong>需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDepthOfTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            depth++;</span><br><span class="line"></span><br><span class="line">            TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                cur = queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前节点的左右孩子都为空，直接返回最小深度</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>){</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>以上题目参考:<a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">代码随想录</a></p><p>感谢哈工大师兄Carl！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 层序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用递归和非递归的方式实现二叉树的遍历</title>
      <link href="/posts/a2eb.html"/>
      <url>/posts/a2eb.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-用递归的方式实现二叉树的前序、中序和后序遍历"><a href="#1-用递归的方式实现二叉树的前序、中序和后序遍历" class="headerlink" title="1.用递归的方式实现二叉树的前序、中序和后序遍历"></a>1.用递归的方式实现二叉树的前序、中序和后序遍历</h1><ul><li>递归三要素</li></ul><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TreeNode节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"前序遍历二叉树(递归)"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中 左 右</span></span><br><span class="line">        System.out.println(root.val);</span><br><span class="line"></span><br><span class="line">        preOrderRecur(root.left);</span><br><span class="line"></span><br><span class="line">        preOrderRecur(root.right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历二叉树，递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderRecur</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前 中 右</span></span><br><span class="line">        inOrderRecur(root.left);</span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">        inOrderRecur(root.right);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历二叉树，递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderRecur</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左 右 中</span></span><br><span class="line">        postOrderRecur(root.left);</span><br><span class="line">        postOrderRecur(root.right);</span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br><h1 id="2-用非递归的方式实现二叉树的前序、中序和后序遍历"><a href="#2-用非递归的方式实现二叉树的前序、中序和后序遍历" class="headerlink" title="2.用非递归的方式实现二叉树的前序、中序和后序遍历"></a>2.用非递归的方式实现二叉树的前序、中序和后序遍历</h1><h2 id="2-1前序遍历"><a href="#2-1前序遍历" class="headerlink" title="2.1前序遍历"></a>2.1前序遍历</h2><ul><li><p>思路分析</p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif"></p></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**前序遍历，非递归</span></span><br><span class="line"><span class="comment">     *  * 思路分析:</span></span><br><span class="line"><span class="comment">     *  * 1.申请一个新的栈，即为stack,然后将root节点压入栈中</span></span><br><span class="line"><span class="comment">     *  *</span></span><br><span class="line"><span class="comment">     *  * 2.从stack中弹出栈顶节点，记为root,然后将root节点的值放入result集合，</span></span><br><span class="line"><span class="comment">     *  *     再将root节点的右子节点(不为空的话)先压入栈中，</span></span><br><span class="line"><span class="comment">     *  *      最后将root节点的左子节点(不为空的话)压入栈中</span></span><br><span class="line"><span class="comment">     *  *</span></span><br><span class="line"><span class="comment">     *  * 3.不断重复步骤2,直到stack为空，全部过程结束</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrderUnRecur</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//如果根节点不为空，将其压入栈中</span></span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            stack.push(root);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line">                <span class="comment">//从栈中弹出栈顶元素，并打印其节点的值</span></span><br><span class="line">                root = stack.pop();</span><br><span class="line">                result.add(root.val);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前节点的右子节点不为空，将右子节点压入栈中</span></span><br><span class="line">                <span class="keyword">if</span> (root.right != <span class="keyword">null</span>){</span><br><span class="line">                    stack.push(root.right);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前节点的左子节点不为空，将左子节点压入栈中</span></span><br><span class="line">                <span class="keyword">if</span> (root.left != <span class="keyword">null</span>){</span><br><span class="line">                    stack.push(root.left);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2中序遍历"><a href="#2-2中序遍历" class="headerlink" title="2.2中序遍历"></a>2.2中序遍历</h2><ul><li>思路分析</li></ul><p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif"></p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**中序遍历二叉树(非递归)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 思路分析：</span></span><br><span class="line"><span class="comment">     * 1.中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，</span></span><br><span class="line"><span class="comment">     * 直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result集合中），</span></span><br><span class="line"><span class="comment">     * 这就造成了处理顺序和访问顺序是不一致的。</span></span><br><span class="line"><span class="comment">     * 2.在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个list集合，保存中序遍历的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inOrderUnRecur</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()){</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>){ <span class="comment">//指针来访问节点，访问到最底层</span></span><br><span class="line">                stack.push(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur.left;  <span class="comment">//左</span></span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                cur = stack.pop();  <span class="comment">//从栈里面弹出的数据就是要处理的数据</span></span><br><span class="line">                result.add(cur.val);  <span class="comment">//放进result集合中</span></span><br><span class="line">                cur = cur.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-后序遍历"><a href="#2-3-后序遍历" class="headerlink" title="2.3 后序遍历"></a>2.3 后序遍历</h2><ul><li>思路分析</li></ul><p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200808200338924.png"></p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**后序遍历二叉树(非递归)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 思路分析:</span></span><br><span class="line"><span class="comment">    * 先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，</span></span><br><span class="line"><span class="comment">    * 就变成中右左的遍历顺序，然后在反转result集合，输出的结果顺序就是左右中了</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回一个list集合，保存中序遍历的结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postOrderUnRecur</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line"></span><br><span class="line">       List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       stack.push(root);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line">           root = stack.pop();</span><br><span class="line">           result.add(root.val);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (root.left != <span class="keyword">null</span>){</span><br><span class="line">               stack.push(root.left);</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (root.right != <span class="keyword">null</span>){</span><br><span class="line">               stack.push(root.right);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       Collections.reverse(result);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>参考：<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树的遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法匹配字符串</title>
      <link href="/posts/c86b.html"/>
      <url>/posts/c86b.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、KMP算法匹配字符串"><a href="#一、KMP算法匹配字符串" class="headerlink" title="一、KMP算法匹配字符串"></a>一、KMP算法匹配字符串</h2><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p><a href="https://leetcode-cn.com/problems/implement-strstr/">leetcode-链接</a></p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = <span class="string">"aabaabaaf"</span>, needle = <span class="string">"aabaaf"</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h2><h3 id="方法一：朴素解法"><a href="#方法一：朴素解法" class="headerlink" title="方法一：朴素解法"></a>方法一：朴素解法</h3><ul><li><p>思路分析</p><p>直观的解法的是：枚举原串 ss 中的每个字符作为「发起点」，每次从原串的「发起点」和匹配串的「首位」开始尝试匹配：</p><p>匹配成功：返回本次匹配的原串「发起点」。<br>匹配失败：枚举原串的下一个「发起点」，重新尝试匹配。</p><p>参考：<a href="https://leetcode-cn.com/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/">宫水三叶</a></p></li></ul><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String ss, String pp)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = ss.length(), m = pp.length();</span><br><span class="line">        <span class="keyword">char</span>[] s = ss.toCharArray(), p = pp.toCharArray();</span><br><span class="line">        <span class="comment">// 枚举原串的「发起点」</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++) {</span><br><span class="line">            <span class="comment">// 从原串的「发起点」和匹配串的「首位」开始，尝试匹配</span></span><br><span class="line">            <span class="keyword">int</span> a = i, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (b &lt; m &amp;&amp; s[a] == p[b]) {</span><br><span class="line">                a++;</span><br><span class="line">                b++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果能够完全匹配，返回原串的「发起点」下标</span></span><br><span class="line">            <span class="keyword">if</span> (b == m) <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><br><h3 id="方法二-KMP算法"><a href="#方法二-KMP算法" class="headerlink" title="方法二:KMP算法"></a>方法二:KMP算法</h3><p>参考：<a href="http://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">代码随想录</a></p><h4 id="一、构造next数组"><a href="#一、构造next数组" class="headerlink" title="一、构造next数组"></a>一、构造next数组</h4><p><strong>构造next数组其实就是计算模式串s，前缀表的过程。</strong> 主要有如下三步：</p><ol><li><p>初始化</p></li><li><p>处理前后缀不相同的情况</p></li><li><p>处理前后缀相同的情况</p><br><p>1.初始化：</p></li></ol><p>定义两个指针i和j，j指向前缀起始位置，i指向后缀起始位置。</p><p>然后还要对next数组进行初始化赋值，如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int j = -1;</span><br><span class="line">next[0] = j;</span><br></pre></td></tr></tbody></table></figure><p>j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。</p><p>next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）</p><p>所以初始化next[0] = j 。</p><p>2.处理前后缀不相同的情况</p><p>因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。</p><p>所以遍历模式串s的循环下标i 要从 1开始，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 1; i &lt; s.size(); i++) {</span><br></pre></td></tr></tbody></table></figure><p>如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。</p><p>怎么回退呢？</p><p>next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。</p><p>那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。</p><p>所以，处理前后缀不相同的情况代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了</span><br><span class="line">    j = next[j]; // 向前回退</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>3.处理前后缀相同的情况</p><p>如果s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (s[i] == s[j + 1]) { // 找到相同的前后缀</span><br><span class="line">    j++;</span><br><span class="line">}</span><br><span class="line">next[i] = j;</span><br></pre></td></tr></tbody></table></figure><p>最后整体构建next数组的函数代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>* next, <span class="keyword">const</span> string&amp; s)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) { <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) { <span class="comment">// 前后缀不相同了</span></span><br><span class="line">            j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) { <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码构造next数组的逻辑流程动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif"></p><br><h4 id="二、使用next数组来做匹配"><a href="#二、使用next数组来做匹配" class="headerlink" title="二、使用next数组来做匹配"></a>二、使用next数组来做匹配</h4><p>在文本串s里 找是否出现过模式串t。</p><p>定义两个下标j 指向模式串起始位置，i指向文本串起始位置。</p><p>那么j初始值依然为-1，为什么呢？ <strong>依然因为next数组里记录的起始位置为-1。</strong></p><p>i就从0开始，遍历文本串，代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; s.size(); i++) </span><br></pre></td></tr></tbody></table></figure><p>接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。</p><p>如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) {</span><br><span class="line">    j = next[j];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (s[i] == t[j + 1]) {</span><br><span class="line">    j++; // i的增加在for循环里</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。</p><p>本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (j == (t.size() - 1) ) {</span><br><span class="line">    return (i - t.size() + 1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么使用next数组，用模式串匹配文本串的整体代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">-1</span>; <span class="comment">// 因为next数组里记录的起始位置为-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) { <span class="comment">// 注意i就从0开始</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>]) { <span class="comment">// 不匹配</span></span><br><span class="line">        j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s[i] == t[j + <span class="number">1</span>]) { <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">        j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j == (t.<span class="built_in">size</span>() - <span class="number">1</span>) ) { <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">        <span class="keyword">return</span> (i - t.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><p>此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPStr</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String pattern){</span><br><span class="line">        <span class="keyword">char</span>[] s = pattern.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[s.length];  <span class="comment">//初始化一个next数组</span></span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;   <span class="comment">//j+1指向前缀起始位置</span></span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length; i++) {  <span class="comment">//i指向后缀起始位置,从1 开始</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]){<span class="comment">// 前后缀不相同了</span></span><br><span class="line">                j = next[j];  <span class="comment">//让j+1向前回退</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>]){<span class="comment">// 找到相同的前后缀</span></span><br><span class="line">                j++;   <span class="comment">//j+1后移一位</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            next[i] = j; <span class="comment">//将j（前缀的长度）赋给next[i]</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack,String needle)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] s = haystack.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] t = needle.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;  <span class="comment">// 因为next数组里记录的起始位置为-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(needle); <span class="comment">//获取next数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) {  <span class="comment">// 注意i就从0开始</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j+<span class="number">1</span>]){  <span class="comment">// 不匹配</span></span><br><span class="line">                j = next[j];  <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j+<span class="number">1</span>]){  <span class="comment">// 匹配，j和i同时向后移动,i的增加在for循环里</span></span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j == t.length-<span class="number">1</span>){  <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">                <span class="keyword">return</span> i - t.length + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------main------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        KMPStr kmp = <span class="keyword">new</span> KMPStr();</span><br><span class="line">        <span class="keyword">int</span>[] next = kmp.getNext(<span class="string">"aabaaf"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = kmp.strStr(<span class="string">"aabaabaaf"</span>, <span class="string">"aabaaf"</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="二、重复的子字符串"><a href="#二、重复的子字符串" class="headerlink" title="二、重复的子字符串"></a>二、重复的子字符串</h1><p><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">leetcode题目链接</a></p><ul><li><p>题目</p><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: "abab"</span><br><span class="line">输出: True</span><br><span class="line">解释: 可由子字符串 "ab" 重复两次构成。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: "aba"</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: "abcabcabcabc"</span><br><span class="line">输出: True</span><br><span class="line">解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>思路分析</p><p>参考：<a href="http://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a></p></li></ul><p>此题依旧需要用到KMP算法的next数组。</p><p>next 数组记录的就是最长相同前后缀( <a href="https://mp.weixin.qq.com/s/MoRBHbS4hQXn7LcPdmHmIg">字符串：KMP算法精讲 </a>这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。</p><p>最长相等前后缀的长度为：next[len - 1] + 1。</p><p>数组长度为：len</p><p>如果len % (len - (next[len - 1] + 1)) == 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被 数组的长度整除，说明有该字符串有重复的子字符串。</p><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><p><strong>强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法</strong></p><p>如图：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2_1.png"></p><p>next[len - 1] = 7，next[len - 1] + 1 = 8，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。</p><p>(len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatedSubstringKMP</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String pattern){</span><br><span class="line">        <span class="keyword">char</span>[] s = pattern.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[s.length];</span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length; i++) {</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>]){</span><br><span class="line">                j = next[j];  <span class="comment">//当前缀和后缀不相等时，j+1前移</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j+<span class="number">1</span>]){  <span class="comment">//当前缀和后缀相等时，i,j+1分别后移</span></span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRepeated</span><span class="params">(String pattern)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (pattern.length() == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(pattern);</span><br><span class="line">        <span class="keyword">int</span> len = next.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用next数组判断，一个字符串是否可以由它的一个子串重复多次构成</span></span><br><span class="line">        <span class="keyword">if</span> (next[len-<span class="number">1</span>] != -<span class="number">1</span> &amp;&amp; len%(len-(next[len-<span class="number">1</span>]+<span class="number">1</span>)) == <span class="number">0</span>){<span class="comment">//核心代码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------main---------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        RepeatedSubstringKMP kmp = <span class="keyword">new</span> RepeatedSubstringKMP();</span><br><span class="line">        <span class="keyword">int</span>[] next = kmp.getNext(<span class="string">"aabaaf"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">        System.out.println(kmp.isRepeated(<span class="string">"aabaab"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> KMP算法 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组刷题笔记</title>
      <link href="/posts/7dec.html"/>
      <url>/posts/7dec.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-数组的二分查找"><a href="#1-数组的二分查找" class="headerlink" title="1.数组的二分查找"></a>1.数组的二分查找</h1><ul><li><p>题目</p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span>     </span><br><span class="line">输出: <span class="number">4</span>       </span><br><span class="line">解释: <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span>   </span><br></pre></td></tr></tbody></table></figure></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>{</span><br><span class="line">       <span class="comment">//先判断要查找的值是否在数组的范围内</span></span><br><span class="line">       <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length-<span class="number">1</span>]){</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right){</span><br><span class="line">           <span class="keyword">int</span> middle = (left+right)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[middle] == target){</span><br><span class="line">               <span class="keyword">return</span> middle;</span><br><span class="line">           }<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[middle]){ <span class="comment">//如果要查找的值在左边</span></span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">           }<span class="keyword">else</span> { <span class="comment">//如果要查找的值在右边</span></span><br><span class="line">               left = middle+<span class="number">1</span>;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------main-------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        BinarySearch binarySearch = <span class="keyword">new</span> BinarySearch();</span><br><span class="line">        <span class="keyword">int</span>[] arr = {-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>};</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> res = binarySearch.binarySearch(arr,target);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>参考：<a href="http://programmercarl.com/">代码随想录</a></p><hr><h1 id="2-移除数组中的元素"><a href="#2-移除数组中的元素" class="headerlink" title="2.移除数组中的元素"></a>2.移除数组中的元素</h1><p><a href="http://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#_27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">题目链接</a></p><ul><li>题目</li></ul><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变，你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 </p><p>​            你不需要考虑数组中超出新长度后面的元素。</p><h2 id="方法一：暴力求解"><a href="#方法一：暴力求解" class="headerlink" title="方法一：暴力求解"></a>方法一：暴力求解</h2><ul><li><p>思路分析</p><p>这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrc7x9tjg30du09m1ky.gif"></p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveElement</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**暴力移除数组的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 输入的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要移除的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回新的数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="comment">//如果找到要删除的值,就利用一个for循环,将下标i后面的值统统后移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] == val){</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) {</span><br><span class="line">                    arr[j-<span class="number">1</span>] = arr[j];</span><br><span class="line">                }</span><br><span class="line">                i--;  <span class="comment">// 因为此时i后面的值后移了，i位置上是新的值，所以i要减去1</span></span><br><span class="line">                      <span class="comment">//这样下一次循环时(i++)，i上的值相当于原先i位置上的下一个</span></span><br><span class="line">                size--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------main------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        RemoveElement remove = <span class="keyword">new</span> RemoveElement();</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>};</span><br><span class="line">        <span class="keyword">int</span> length = remove.removeElement(arr, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="方法二：双指针法"><a href="#方法二：双指针法" class="headerlink" title="方法二：双指针法"></a>方法二：双指针法</h2><ul><li><strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif"></p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveElement2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.length; fastIndex++) {</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fastIndex]) {</span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        RemoveElement2 remove = <span class="keyword">new</span> RemoveElement2();</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>};</span><br><span class="line">        <span class="keyword">int</span> length = remove.removeElement(arr, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="3-有序数组的平方"><a href="#3-有序数组的平方" class="headerlink" title="3.有序数组的平方"></a>3.有序数组的平方</h1><ul><li>题目</li></ul><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><ul><li><p>思路：双指针法</p><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> </p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> </p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif"></p></li><li><p>代码详情</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SquareOfSortArray</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquare(<span class="keyword">int</span>[] arr){</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">int</span> k = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right){</span><br><span class="line">            <span class="keyword">if</span> (arr[right]*arr[right] &gt; arr[left]*arr[left]){</span><br><span class="line">                res[k--] = arr[right]*arr[right];</span><br><span class="line">                right--;</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                res[k--] = arr[left]*arr[left];</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------main------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SquareOfSortArray sortArray = <span class="keyword">new</span> SquareOfSortArray();</span><br><span class="line">        <span class="keyword">int</span>[] arr = {-<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>};</span><br><span class="line">        <span class="keyword">int</span>[] square = sortArray.sortedSquare(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : square) {</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参考：<a href="http://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95">代码随想录</a></p><hr><h1 id="4-长度最小的子数组"><a href="#4-长度最小的子数组" class="headerlink" title="4.长度最小的子数组"></a>4.长度最小的子数组</h1><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">题目链接</a></p><ul><li>题目</li></ul><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><h2 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h2><ul><li><p>代码详情</p><p>这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2)</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 长度最小的子数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinSubArrayLen</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 暴力求解，利用两个for循环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 输入的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 要求子数组的和 &gt;= s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回子数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE; <span class="comment">// 要返回的子数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> subLen = <span class="number">0</span>; <span class="comment">// 子数组的长度，中间变量，用于比较各个子数组</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;   <span class="comment">//用于计算子数组的和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {  <span class="comment">//遍历数组</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length ; j++) {  <span class="comment">//j从i的位置往后累加</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= s){</span><br><span class="line">                    subLen = j-i+<span class="number">1</span>;  <span class="comment">//当累加结果sum大于等于s时，保留此时的子数组长度</span></span><br><span class="line">                    result = subLen &lt; result ? subLen : result;  <span class="comment">//更新result的值</span></span><br><span class="line">                    <span class="keyword">break</span>;           <span class="comment">//跳出循环，进行下一轮</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result; <span class="comment">//如果result的值不变，</span></span><br><span class="line">                                                         <span class="comment">// 说明为找到符合条件的子数组，则返回0</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------main---------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MinSubArrayLen subArrayLen = <span class="keyword">new</span> MinSubArrayLen();</span><br><span class="line">        <span class="keyword">int</span>[] nums = {<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>};</span><br><span class="line">        <span class="keyword">int</span> len = subArrayLen.minSubArrayLen(nums, <span class="number">7</span>);</span><br><span class="line">        System.out.println(len);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a>方法二：滑动窗口</h2><ul><li>思路分析</li></ul><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif"></p><p>最后找到 4，3 是最短距离。</p><p>其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p><p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210312160441942.png"></p><p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p><p><strong>为什么时间复杂度是O(n)</strong>:</p><p>不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是$O(n)$。</p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 滑动窗口，也可以理解为双指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 输入的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 要求子数组的和 &gt;= s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回子数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLengthWindow</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> s)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE; <span class="comment">// 要返回的子数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> subLen = <span class="number">0</span>; <span class="comment">// 子数组的长度，中间变量，用于比较各个子数组</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;   <span class="comment">//用于计算子数组的和</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;     <span class="comment">//滑动窗口的起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) {  <span class="comment">//j表示滑动窗口的终止位置</span></span><br><span class="line">            sum += nums[j];   <span class="comment">//sum滑动窗口内保存的值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//滑动窗口的精髓</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s){  <span class="comment">//当滑动窗口内的值大于等于s时，滑动窗口的起始位置移动</span></span><br><span class="line">                subLen = j-i+<span class="number">1</span>;</span><br><span class="line">                result = result &lt; subLen ? result : subLen;  <span class="comment">//更新result的值</span></span><br><span class="line"></span><br><span class="line">                sum = sum - nums[i++];  <span class="comment">//滑动窗口内的值减去nums[i],同时，滑动窗口的起始位置右移</span></span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result; <span class="comment">//如果result的值不变，</span></span><br><span class="line">                                                         <span class="comment">// 说明为找到符合条件的子数组，则返回0</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>转载自：<a href="http://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">代码随想录</a>，向大佬表示感谢。</p><hr><h1 id="5-螺旋矩阵"><a href="#5-螺旋矩阵" class="headerlink" title="5.螺旋矩阵"></a>5.螺旋矩阵</h1><ul><li>题目</li></ul><p>题目地址：<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">https://leetcode-cn.com/problems/spiral-matrix-ii/</a> 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><ul><li>思路分析</li></ul><p>求解本题依然是要坚持循环不变量原则。</p><p>模拟顺时针画矩阵的过程:</p><p>  填充上行从左到右</p><p>  填充右列从上到下</p><p>  填充下行从右到左</p><p>  填充左列从下到上</p><p>由外向内一圈一圈这么画下去。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开又闭的原则，这样这一圈才能按照统一的规则画下来。</p><p>那么我按照左闭右开的原则，来画一圈，大家看一下：</p><p><img src="https://img-blog.csdnimg.cn/2020121623550681.png"></p><p>这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。</p><p>这也是坚持了每条边左闭右开的原则。</p><p>一些同学做这道题目之所以一直写不好，代码越写越乱。</p><p>就是因为在画每一条边的时候，一会左开又闭，一会左闭右闭，一会又来左闭右开，岂能不乱。</p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiralMatrix</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) {</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n]; <span class="comment">// 定义一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="keyword">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="keyword">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">1</span>; <span class="comment">// 每一圈循环，需要控制每一条边遍历的长度</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> ( loop &gt; <span class="number">0</span> ) {</span><br><span class="line"></span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; starty + n - offset; j++) {</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; startx + n - offset; i++) {</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) {</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) {</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            loop--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) {</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------main-------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[][] ints = generateMatrix(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] anInt : ints) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : anInt) {</span><br><span class="line">                System.out.print(i+<span class="string">"\t"</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>转载自：<a href="http://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">代码随想录</a>，向大佬表示感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer题解之链表</title>
      <link href="/posts/ae99.html"/>
      <url>/posts/ae99.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-返回链表中倒数最后k个结点"><a href="#1-返回链表中倒数最后k个结点" class="headerlink" title="1.返回链表中倒数最后k个结点"></a>1.返回链表中倒数最后k个结点</h1><p><a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&amp;&amp;tqId=11167&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网-JZ14</a></p><ul><li>题目：输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。</li></ul><p>如果该链表长度小于k，请返回一个长度为 0 的链表。</p><ul><li>思路分析</li></ul><p>设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K +1个节点处，该位置就是倒数第 K 个节点。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210810124830.png"></p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回链表中倒数最后k个结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：此题中链表的头节点即为第一个有效的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindKthToTail</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node head,Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(Node head)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.printf(<span class="string">"节点编号：%d \n"</span>, cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。</span></span><br><span class="line"><span class="comment">     * 如果该链表长度小于k，请返回一个长度为 0 的链表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 输入链表的头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 倒数第k个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 倒数第k个结点至尾节点的全部节点 的 头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">findKthToTail</span><span class="params">(Node head,<span class="keyword">int</span> k)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node p1 = head;</span><br><span class="line">        Node p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; k &gt; <span class="number">0</span>){</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            k--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>){</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------main-----------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        FindKthToTail list = <span class="keyword">new</span> FindKthToTail();</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        list.add(head,<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        list.add(head,<span class="keyword">new</span> Node(<span class="number">3</span>));</span><br><span class="line">        list.add(head,<span class="keyword">new</span> Node(<span class="number">4</span>));</span><br><span class="line">        list.add(head,<span class="keyword">new</span> Node(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        list.list(head);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------findKthToTail---------"</span>);</span><br><span class="line">        Node newHead = list.findKthToTail(head, <span class="number">3</span>);</span><br><span class="line">        list.list(newHead);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-两个链表的第一个公共结点"><a href="#2-两个链表的第一个公共结点" class="headerlink" title="2.两个链表的第一个公共结点"></a>2.两个链表的第一个公共结点</h1><p><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;&amp;tqId=11189&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网-JZ36</a></p><ul><li>题目：输入两个无环的单链表，找出它们的第一个公共结点。</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210810150024.png"></p><ul><li><p>解题思路</p><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p><p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p></li></ul><ul><li>核心代码</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>{</span><br><span class="line">    ListNode l1 = pHead1, l2 = pHead2;</span><br><span class="line">    <span class="keyword">while</span> (l1 != l2) {</span><br><span class="line">        l1 = (l1 == <span class="keyword">null</span>) ? pHead2 : l1.next;</span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span>) ? pHead1 : l2.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>本题转载自：<a href="http://www.cyc2018.xyz/">CyC2018</a></li></ul><hr><h1 id="3-环形链表II"><a href="#3-环形链表II" class="headerlink" title="3.环形链表II"></a>3.环形链表II</h1><ul><li>题目</li></ul><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明</strong>：不允许修改给定的链表。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210813130108.png"></p><ul><li>思路分析</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo58gauidg30fw0bi4qr.gif"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) {</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) {<span class="comment">// 有环</span></span><br><span class="line">                ListNode index1 = fast;</span><br><span class="line">                ListNode index2 = head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) {</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>转载自：<a href="http://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表刷题日记</title>
      <link href="/posts/3568.html"/>
      <url>/posts/3568.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-在单链表中删除倒数第K个节点"><a href="#1-在单链表中删除倒数第K个节点" class="headerlink" title="1.在单链表中删除倒数第K个节点"></a>1.在单链表中删除倒数第K个节点</h1><ul><li><p>题目</p><p>给定一个单链表，要求删除倒数第K个节点，并返回该节点</p></li></ul><br><ul><li>解答</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210808163210.jpg"></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210808163227.jpg"></p><br><br><ul><li><p>代码详情</p><p> Node节点类</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br><p>单链表类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.printf(<span class="string">"节点编号：%d \n"</span>, cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**在单链表中删除倒数第k个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastKth 倒数第k个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的倒数第k个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeLastKthNode</span><span class="params">(<span class="keyword">int</span> lastKth)</span></span>{</span><br><span class="line">        Node cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || lastKth &lt; <span class="number">1</span>){</span><br><span class="line">            System.out.println(<span class="string">"链表为空或者参数输入有误！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历链表，每移动一次，lathKth的值就减去1</span></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            lastKth--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node res = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastKth &gt; <span class="number">0</span>){ <span class="comment">//lastKth的值大于链表的长度，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(lastKth == <span class="number">0</span>){ <span class="comment">// 此时，lastKth就是第一个节点</span></span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.head;</span><br><span class="line">        }<span class="keyword">else</span> {   <span class="comment">//如果lastKth &lt; 0</span></span><br><span class="line">            cur = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">while</span> (lastKth != <span class="number">0</span>){</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                lastKth++;</span><br><span class="line">            }</span><br><span class="line">            res = cur.next; <span class="comment">//将要删除的节点赋值给res,用来返回</span></span><br><span class="line"></span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------main-----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SingleLinkedList linkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        linkedList.add(<span class="keyword">new</span> Node(<span class="number">1</span>));</span><br><span class="line">        linkedList.add(<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        linkedList.add(<span class="keyword">new</span> Node(<span class="number">3</span>));</span><br><span class="line">        linkedList.add(<span class="keyword">new</span> Node(<span class="number">4</span>));</span><br><span class="line">        linkedList.add(<span class="keyword">new</span> Node(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        Node node = linkedList.removeLastKthNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        linkedList.list();</span><br><span class="line">        System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        System.out.println(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br><h1 id="2-单链表的反转"><a href="#2-单链表的反转" class="headerlink" title="2.单链表的反转"></a>2.单链表的反转</h1><ul><li><p>题目</p><p>给定一个单链表，实现单链表的反转</p></li></ul><ul><li>思路分析</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210808221329.png" alt="反转单链表"></p><ul><li>代码实现</li></ul><p>Node节点类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><p>反转链表类ReverseList</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.printf(<span class="string">"节点编号：%d \n"</span>, cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转单链表的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseList</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span> ){</span><br><span class="line">            System.out.println(<span class="string">"不用反转该链表"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        Node newHead = <span class="keyword">new</span> Node(-<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>){  <span class="comment">//遍历链表，cur为遍历到的当前节点</span></span><br><span class="line">            next = cur.next;  <span class="comment">//next 指向当前节点[cur]的下一个节点</span></span><br><span class="line">            cur.next = newHead.next;  <span class="comment">//当前节点[cur]的next域指向新的头节点的下一个节点</span></span><br><span class="line">            newHead.next = cur;   <span class="comment">//newHead的next域指向当前节点[cur]</span></span><br><span class="line">            cur = next;   <span class="comment">//cur后移一位</span></span><br><span class="line">        }</span><br><span class="line">        head.next = newHead.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------main--------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ReverseList reverseList = <span class="keyword">new</span> ReverseList();</span><br><span class="line">        reverseList.add(<span class="keyword">new</span> Node(<span class="number">1</span>));</span><br><span class="line">        reverseList.add(<span class="keyword">new</span> Node(<span class="number">3</span>));</span><br><span class="line">        reverseList.add(<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        reverseList.add(<span class="keyword">new</span> Node(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        reverseList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---反转后的链表---"</span>);</span><br><span class="line">        reverseList.reverseList();</span><br><span class="line">        reverseList.list();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-判断一个链表是否为回文结构"><a href="#3-判断一个链表是否为回文结构" class="headerlink" title="3.判断一个链表是否为回文结构"></a>3.判断一个链表是否为回文结构</h1><ul><li>题目</li></ul><p>给定一个链表，请判断该链表是否为回文结构</p><p>例如：</p><p>1-&gt;2-&gt;1,返回true</p><p>1-&gt;2-&gt;2-&gt;1,返回true</p><p>1-&gt;2-&gt;3,返回false</p><ul><li><p>思路分析</p><p>1.遍历链表，将链表的节点依次压入一个栈中</p><p>2.依次弹出栈中的节点，与链表中的节点作比较，如果每次比较的节点的值都相等，则为回文结构</p></li></ul><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断链表是否是回文结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsPalindrome</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>){</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur = head.next;</span><br><span class="line">        Node popNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; cur != <span class="keyword">null</span>){</span><br><span class="line">            popNode = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (popNode.val != cur.val){</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------main----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        IsPalindrome palindrome = <span class="keyword">new</span> IsPalindrome();</span><br><span class="line">        palindrome.add(<span class="keyword">new</span> Node(<span class="number">1</span>));</span><br><span class="line">        palindrome.add(<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        palindrome.add(<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        palindrome.add(<span class="keyword">new</span> Node(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> palindrome1 = palindrome.isPalindrome();</span><br><span class="line">        System.out.println(palindrome1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-删除无序链表中值重复出现的节点"><a href="#4-删除无序链表中值重复出现的节点" class="headerlink" title="4.删除无序链表中值重复出现的节点"></a>4.删除无序链表中值重复出现的节点</h1><ul><li><p>题目(难度<strong>一星</strong>)</p><p>给定一个无序单链表，删除其中值重复出现的节点</p><p>例如:1-&gt;2-&gt;2-&gt;4-&gt;5-&gt;4-&gt;null,删除值重复之后的链表为：1-&gt;2-&gt;4-&gt;5-&gt;null</p></li></ul><ul><li>思路分析</li></ul><p>1.遍历当前链表，创建Node节点cur指向当前节点，pre指向cur的前一个节点</p><p>2.生成一个哈希表，如果cur的值已经存在于哈希表中，就将当前节点删除<code>(pre.next = cur.next)</code></p><p>​                                  如果cur的值不存在哈希表中，将其加入到哈希表中，同时令pre = cur(为下一次遍历做准备)</p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中的重复节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveRepeat</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.printf(<span class="string">"节点编号：%d \n"</span>, cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeRepeat</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Node cur = head.next;  <span class="comment">//cur指向当前节点</span></span><br><span class="line">        Node pre = head;   <span class="comment">//cur指向当前节点的前一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">if</span> (set.contains(cur.val)){  <span class="comment">//如果哈希表中包含当前节点cur的值，就删除cur节点</span></span><br><span class="line">                pre.next = cur.next;</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span> {     <span class="comment">//如果不包含，则将cur节点的值加入到哈希表中</span></span><br><span class="line">                set.add(cur.val);</span><br><span class="line">                pre = cur;  <span class="comment">//pre后移一位</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------main---------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        RemoveRepeat remove = <span class="keyword">new</span> RemoveRepeat();</span><br><span class="line"></span><br><span class="line">        remove.add(<span class="keyword">new</span> Node(<span class="number">1</span>));</span><br><span class="line">        remove.add(<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        remove.add(<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        remove.add(<span class="keyword">new</span> Node(<span class="number">4</span>));</span><br><span class="line">        remove.add(<span class="keyword">new</span> Node(<span class="number">5</span>));</span><br><span class="line">        remove.add(<span class="keyword">new</span> Node(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        remove.removeRepeat();</span><br><span class="line"></span><br><span class="line">        remove.list();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="5-合并两个有序的单链表"><a href="#5-合并两个有序的单链表" class="headerlink" title="5.合并两个有序的单链表"></a>5.合并两个有序的单链表</h1><ul><li>题目(难度<strong>一星</strong>)</li></ul><p>给定两个有序单链表的头节点head1,head2,请合并两个有序链表，合并后的链表依然有序，并返回合并后链表的头节点</p><p>例如：</p><p>0-&gt;2-&gt;3-&gt;7-&gt;null</p><p>1-&gt;3-&gt;5-&gt;7-&gt;9-&gt;null</p><p>合并后的链表：0-&gt;1-&gt;2-&gt;3-&gt;3-&gt;5-&gt;7-&gt;7-&gt;9-&gt;null</p><ul><li>思路分析</li></ul><p>1.当两个链表都不为空时，遍历两个链表，并比较链表中节点值的大小，将较小的节点加入到</p><p>新的以newHead为头节点的链表中，如果相等，则依次加入两个相等的节点。</p><p>2.若两个链表中其中一个遍历到了末尾，则把另一个链表中的节点加入到新的链表中</p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序的单链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeLinkedList</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node head,Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cur.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(Node head)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.printf(<span class="string">"节点编号：%d \n"</span>, cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个单链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 第一个链表的头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 第二个链表的头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回新的链表的头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">merge</span><span class="params">(Node head1,Node head2)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (head1.next == <span class="keyword">null</span> &amp;&amp; head2.next == <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"两个链表为空！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node newHead = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">        Node cur = newHead;</span><br><span class="line">        head1 = head1.next;</span><br><span class="line">        head2 = head2.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">if</span> (head1.val &lt; head2.val){</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (head2.val &lt; head1.val){</span><br><span class="line">                cur.next = head2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line"></span><br><span class="line">                cur.next = head2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="keyword">null</span>){</span><br><span class="line">            cur.next = head1;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head2 != <span class="keyword">null</span>){</span><br><span class="line">            cur.next = head2;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------main--------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MergeLinkedList merge = <span class="keyword">new</span> MergeLinkedList();</span><br><span class="line"></span><br><span class="line">        Node head1 = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">        Node head2 = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        merge.add(head1,<span class="keyword">new</span> Node(<span class="number">0</span>));</span><br><span class="line">        merge.add(head1,<span class="keyword">new</span> Node(<span class="number">2</span>));</span><br><span class="line">        merge.add(head1,<span class="keyword">new</span> Node(<span class="number">3</span>));</span><br><span class="line">        merge.add(head1,<span class="keyword">new</span> Node(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">        merge.add(head2,<span class="keyword">new</span> Node(<span class="number">1</span>));</span><br><span class="line">        merge.add(head2,<span class="keyword">new</span> Node(<span class="number">3</span>));</span><br><span class="line">        merge.add(head2,<span class="keyword">new</span> Node(<span class="number">5</span>));</span><br><span class="line">        merge.add(head2,<span class="keyword">new</span> Node(<span class="number">7</span>));</span><br><span class="line">        merge.add(head2,<span class="keyword">new</span> Node(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">        Node merge1 = merge.merge(head1, head2);</span><br><span class="line"></span><br><span class="line">        merge.list(merge1);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单向环形链表之约瑟夫环</title>
      <link href="/posts/d2de.html"/>
      <url>/posts/d2de.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>Josephus问题:</p><p>约瑟夫问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p><p>例如：</p><p>n = 5 , 即有5个人 </p><p>k = 1, 从第一个人开始报数</p><p>m = 2, 数2下</p><p>出圈的顺序</p><p>2-&gt;4-&gt;1-&gt;5-&gt;3</p></li></ul><br><ul><li>思路图解<ul><li>构建单向环形链表</li></ul></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210807164227.png"></p><br><ul><li><ul><li>节点出圈的思路图解</li></ul></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210807164339.png"></p><br><ul><li>代码详情</li></ul><p>Node节点类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小孩节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> no;</span><br><span class="line"></span><br><span class="line">    Boy next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><p>下面是单向环形链表类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向环形链表-约瑟夫环</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleCircle</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boy first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将小孩加入约瑟夫环的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 表示环中结点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Boy curBoy = <span class="keyword">null</span>;  <span class="comment">//辅助变量，用来帮助小孩进圈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) {</span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当加入第一个小孩时，让其自己成环</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>){</span><br><span class="line">                first = boy;  <span class="comment">//first始终指向第一个小孩</span></span><br><span class="line">                first.next = first;</span><br><span class="line">                curBoy = first;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//新的小孩结点的进圈操作</span></span><br><span class="line">            curBoy.next = boy;</span><br><span class="line">            curBoy = curBoy.next;</span><br><span class="line">            curBoy.next = first;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历圈中的小孩结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"圈中没有小孩结点"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Boy cur = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">            System.out.printf(<span class="string">"当前的小孩编号:%d \n"</span>,cur.no);</span><br><span class="line">            <span class="keyword">if</span> (cur.next == first){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 小孩出圈的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo 从第几个小孩开始数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 数几次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 圈中小孩的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> startNo,<span class="keyword">int</span> count,<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; num){</span><br><span class="line">            System.out.println(<span class="string">"参数输入有误！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Boy helper = first;<span class="comment">//创建一个辅助指针，让其始终位于first指针的前一个</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//先让first移动到startNo处，即开始报数的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= startNo-<span class="number">1</span>; i++) {</span><br><span class="line">            first = first.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再让helper 移动到first的前一位</span></span><br><span class="line">        <span class="keyword">while</span> (helper.next != first){</span><br><span class="line">            helper = helper.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (helper != first){</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开始报数，让helper和first移动到指定位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count-<span class="number">1</span>; i++) {</span><br><span class="line">                helper = helper.next;</span><br><span class="line">                first = first.next;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//此时first指向要移除的小孩结点</span></span><br><span class="line">            System.out.printf(<span class="string">"出圈小孩的编号：%d \n"</span>,first.no);</span><br><span class="line">            first = first.next;</span><br><span class="line">            helper.next = first;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"最后出圈小孩的编号：%d \n"</span>,first.no);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//***************写个main方法测试一下*******************</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SingleCircle singleCircle = <span class="keyword">new</span> SingleCircle();</span><br><span class="line"></span><br><span class="line">        singleCircle.add(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        singleCircle.remove(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 约瑟夫环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的增删改查和插入</title>
      <link href="/posts/64b9.html"/>
      <url>/posts/64b9.html</url>
      
        <content type="html"><![CDATA[<ul><li>本篇博文属于单链表的入门案例，包含单链表的一些基础操作:增删改查、插入</li></ul><ul><li><p>1.首先创建一个Node结点类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    Integer id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer id, String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><br><ul><li>2.然后创建一个单链表类(包含了单链表的增删改查等方法)</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleList</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为当前单向链表添加一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个临时结点指向头结点</span></span><br><span class="line">        Node temp = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一直遍历链表，直到temp.next == null</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>){</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//temp.next == null,说明找到了链表的尾部，将node加入链表中</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照id修改链表的name</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.id == node.id){</span><br><span class="line">                temp.name = node.name;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.next.id == id){</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照id编号的大小顺序插入，从小到大</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertById</span><span class="params">(Node node)</span></span>{</span><br><span class="line"></span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果temp结点的下一个为空，直接跳出循环,从这里跳出循环flag=false;</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//程序走到这里，说明，temp.next != null</span></span><br><span class="line">            <span class="keyword">if</span> (node.id == temp.next.id){</span><br><span class="line"></span><br><span class="line">                flag = <span class="keyword">true</span>;  <span class="comment">//从这里跳出循环flag = true</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(node.id &lt; temp.next.id){</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//从这里跳出循环flag = false;</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里不用写出node.id &gt; temp.next.id的情况，</span></span><br><span class="line">            <span class="comment">//因为这种情况会一直遍历到链表的末尾，满足temp.next == null条件后，跳出循环，最后在链表末尾加上node</span></span><br><span class="line"></span><br><span class="line">            temp = temp.next;  <span class="comment">//temp 向后移动一位，用来遍历单链表</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag){</span><br><span class="line">            System.out.println(<span class="string">"编号已经存在"</span>);</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//在此处执行结点的插入操作(适用于在head结点后加结点(即temp.next == null)，以及node.id 小于 temp.next.id的情况)</span></span><br><span class="line">            node.next = temp.next;</span><br><span class="line">            temp.next = node;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SingleList list = <span class="keyword">new</span> SingleList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*list.add(new Node(1,"张三"));</span></span><br><span class="line"><span class="comment">        list.add(new Node(2,"lisi"));</span></span><br><span class="line"><span class="comment">        list.update(new Node(2,"李四"));</span></span><br><span class="line"><span class="comment">        list.add(new Node(3,"王五"));</span></span><br><span class="line"><span class="comment">        list.add(new Node(4,"赵六"));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        list.delete(1);</span></span><br><span class="line"><span class="comment">        list.delete(4);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        list.list();*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//*****************上面是增删改查的测试************</span></span><br><span class="line">        <span class="comment">//*****************下面是按顺序插入的测试************</span></span><br><span class="line"></span><br><span class="line">        list.insertById(<span class="keyword">new</span> Node(<span class="number">3</span>,<span class="string">"王3"</span>));</span><br><span class="line">        list.insertById(<span class="keyword">new</span> Node(<span class="number">2</span>,<span class="string">"王2"</span>));</span><br><span class="line">        list.insertById(<span class="keyword">new</span> Node(<span class="number">1</span>,<span class="string">"王1"</span>));</span><br><span class="line">        list.insertById(<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="string">"王5"</span>));</span><br><span class="line">        list.insertById(<span class="keyword">new</span> Node(<span class="number">4</span>,<span class="string">"王4"</span>));</span><br><span class="line">        list.insertById(<span class="keyword">new</span> Node(<span class="number">6</span>,<span class="string">"王6"</span>));</span><br><span class="line"></span><br><span class="line">        list.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列刷题笔记</title>
      <link href="/posts/f354.html"/>
      <url>/posts/f354.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-用一个栈实现另一个栈的排序"><a href="#1-用一个栈实现另一个栈的排序" class="headerlink" title="1.用一个栈实现另一个栈的排序"></a>1.用一个栈实现另一个栈的排序</h1><ul><li><p>题目：</p><p>​         一个栈中的类型为整型，现在想将该栈从顶到底按照从大到小的顺序排序，只允许申请一个栈，除此之外，可以申请新的变量，如何排序？</p></li><li><p>思路分析：</p><p>​        将要排序的栈记为stack,申请的辅助栈记为help，在stack上执行pop操作，弹出的元素记为cur</p><ul><li><p>如果cur小于或等于help的栈顶元素，直接将cur压入help</p></li><li><p>如果cur大于help的栈顶元素，则将help中的元素逐次弹出，然后压入stack中，直到cur小于或等于help的栈顶元素，再将cur压入help栈中；</p><p>如果在help栈的弹栈过程中，help已经空了，则说明cur是当前的最大元素，则直接将cur压入help中</p></li><li><p>最后，help中的数，从栈顶到栈底为从小到大的顺序，将help中的数依次弹出压入stack中，则stack从栈顶到栈底为从大到小的顺序</p></li></ul></li><li><p>难度：一星</p></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用一个栈实现另一个栈的排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortStackByStack</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stack <span class="title">sortStack</span><span class="params">(Stack&lt;Integer&gt; stack)</span></span>{</span><br><span class="line"></span><br><span class="line">       Stack&lt;Integer&gt; help = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> cur = stack.pop();</span><br><span class="line">           <span class="keyword">while</span>(!help.isEmpty() &amp;&amp; cur &gt; help.peek()){</span><br><span class="line">               stack.push(help.pop());</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           help.push(cur);</span><br><span class="line"></span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (!help.isEmpty()){</span><br><span class="line">           stack.push(help.pop());</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> stack;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">8</span>);</span><br><span class="line">        stack.push(<span class="number">7</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        stack = sortStack(stack);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br><h1 id="2-数组中元素与下一个比它大的元素之间的距离"><a href="#2-数组中元素与下一个比它大的元素之间的距离" class="headerlink" title="2.数组中元素与下一个比它大的元素之间的距离"></a>2.数组中元素与下一个比它大的元素之间的距离</h1><p><a href="https://leetcode-cn.com/problems/daily-temperatures/description/">力扣</a>（Medium）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">71</span>, <span class="number">69</span>, <span class="number">72</span>, <span class="number">76</span>, <span class="number">73</span>]</span><br><span class="line">Output: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li>说明：对于此题，提供两种解法，详情见下面代码</li><li>方法一：暴力求解,<strong>时间复杂度O(N^2)</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度为O(N^2),每个位置向右遍历一下即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyTemperature2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] rightWay(<span class="keyword">int</span> arr[]){</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="keyword">int</span> cur = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightMoreIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; arr.length){</span><br><span class="line">                <span class="keyword">if</span> (arr[cur] &gt; arr[i]){</span><br><span class="line">                    res[i] = cur - i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                cur++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写个main方法测试一下</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">73</span>,<span class="number">74</span>,<span class="number">75</span>,<span class="number">71</span>,<span class="number">69</span>,<span class="number">72</span>,<span class="number">76</span>,<span class="number">73</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = rightWay(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> re : res) {</span><br><span class="line">            System.out.println(re);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><ul><li><p>方法二：遍历数组时，使用<strong>栈</strong>把数组的下标存起来,<strong>时间复杂度O(N)</strong></p></li><li><p>思路分析：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *     1.用dist数组存放距离当前位置的距离，用stack存放原始数组temperature的下标</span></span><br><span class="line"><span class="comment"> *     2.用cur指向temperature数组的下标，pre指向stack栈的栈顶元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     3.如果stack不为空，并且当前遍历的数temperature[cur] 大于 栈顶对应的数temperature[stack.peek()]，</span></span><br><span class="line"><span class="comment"> *     就将stack的栈顶元素弹出，存到pre变量中，cur - pre即为与pre的距离dist[pre].之后再将cur压入stack中。</span></span><br><span class="line"><span class="comment"> *     4.如果stack为空，直接将cur压入stack中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyTemperatures</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] temperature = {<span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">71</span>, <span class="number">69</span>, <span class="number">72</span>, <span class="number">76</span>, <span class="number">73</span>};</span><br><span class="line">        <span class="keyword">int</span>[] dist = dailyTemperatures(temperature);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : dist) {</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[temperatures.length];</span><br><span class="line">        </span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cur = <span class="number">0</span>; cur &lt; temperatures.length; cur++) {</span><br><span class="line">            <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[cur] &gt; temperatures[stack.peek()]){</span><br><span class="line">                pre = stack.pop();</span><br><span class="line">                dist[pre] = cur - pre;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            stack.push(cur);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>  <br><br><h1 id="3-返回数组的最近邻位置（利用单调栈）"><a href="#3-返回数组的最近邻位置（利用单调栈）" class="headerlink" title="3.返回数组的最近邻位置（利用单调栈）"></a>3.返回数组的最近邻位置（利用单调栈）</h1><ul><li><p>题目：</p><p>给定一个不含重复值的数组arr,找到每一个位置i左边和右边离i位置最近且值比arr[i]小的位置，返回左右位置的相应信息</p></li><li><p>举例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">intput:</span><br><span class="line">      arr = {<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>}</span><br><span class="line">output:</span><br><span class="line">{</span><br><span class="line">        {-<span class="number">1</span>,<span class="number">2</span>},</span><br><span class="line">        {<span class="number">0</span>,<span class="number">2</span>},</span><br><span class="line">        {-<span class="number">1</span>,-<span class="number">1</span>},</span><br><span class="line">        {<span class="number">2</span>,<span class="number">5</span>},</span><br><span class="line">        {<span class="number">3</span>,<span class="number">5</span>},</span><br><span class="line">        {<span class="number">2</span>,-<span class="number">1</span>},</span><br><span class="line">        {<span class="number">5</span>,-<span class="number">1</span>},</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></li><li><p>解答：方法一</p><p>本题实现复杂度为O(N^2)的解释非常容易的，每个位置向左和向右遍历一下，总可以确定，见以下代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonotoneStack</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] rightWay(<span class="keyword">int</span>[] arr){</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> leftLessIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightLessIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = i-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cur &gt;= <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span> (arr[cur] &lt; arr[i]){</span><br><span class="line">                    leftLessIndex = cur;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                cur--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cur = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; arr.length){</span><br><span class="line">                <span class="keyword">if</span> (arr[cur] &lt; arr[i]){</span><br><span class="line">                    rightLessIndex = cur;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                cur++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            res[i][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">            res[i][<span class="number">1</span>] = rightLessIndex;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr2</span><span class="params">(<span class="keyword">int</span>[][] arr)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[<span class="number">0</span>].length; j++) {</span><br><span class="line">                System.out.print(arr[i][j]+<span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = rightWay(arr);</span><br><span class="line"></span><br><span class="line">        printArr2(res);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br><br></li><li><p>方法二：利用单调栈结构，时间复杂度为O(N)</p></li><li><p>思路分析：</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单调栈——返回最近邻的位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 准备一个栈，记为Stack&lt;integer&gt;,栈中存放的元素是数组的位置，开始stack为空，如果找到每一个位置i左边</span></span><br><span class="line"><span class="comment"> * 和右边离i位置最近且值比arr[i]小的位置，那么需要让stack从栈顶到栈底的位置所代表的值是递减的(也就是从大到小)；</span></span><br><span class="line"><span class="comment"> * 如果找到每一个位置i左边和右边离i位置最近且值比arr[i]大的位置，那么需要让stack从栈顶到栈底的位置所代表的值是递增的。</span></span><br><span class="line"><span class="comment"> * 本题需要解决是前者。</span></span><br><span class="line"><span class="comment"> *     下面举例展示单调栈的使用和求解流程，以arr = {3,4,1,5,6,2,7}为例。</span></span><br><span class="line"><span class="comment"> *     1.初始时，arr = {3,4,1,5,6,2,7},stack为空。</span></span><br><span class="line"><span class="comment"> *     2.遍历arr数组，遍历到arr[0] = 3时，stack为空，直接将0压入stack中，此时，stack中从栈顶到栈底为{0(值为3)}</span></span><br><span class="line"><span class="comment"> *     3.遍历到arr[1]=4时，`arr[1] &gt; arr[stack.peek()]`，将1压入到stack中，此时，stack从栈顶到栈底为</span></span><br><span class="line"><span class="comment"> *     {1(值为4)，0(值为3)}</span></span><br><span class="line"><span class="comment"> *     4.遍历到arr[2] = 1时，如果将下标2压入stack中，会破坏stack从栈顶到栈底所代表的的值是递减的规律，</span></span><br><span class="line"><span class="comment"> *     那么，此时将stack的栈顶元素"1"弹出，位置1左边比它代表的值小的下标即为此时stack栈的栈顶元素"0"，</span></span><br><span class="line"><span class="comment"> *     位置1右边比它代表的值小的下标，即为当前遍历的下标"2"，那么res[1] = {0,2}。此时，stack从栈顶到栈底为{0(值为3)}，</span></span><br><span class="line"><span class="comment"> *     如果将下标2压入stack中，依旧会破坏stack从栈顶到栈底的元素所代表的值是递减的规律，此时将stack的栈顶元素"0"弹出，stack栈已经空了，</span></span><br><span class="line"><span class="comment"> *     位置0左边不存在比它小的数，默认取-1，位置0右边比它代表的值小的下标，即为当前遍历的下标"2"，那么res[0] = {-1,2}。</span></span><br><span class="line"><span class="comment"> *     这时，stack为空，将"2"压入stack中，stack从栈顶到栈底的元素为{2(值为1)}</span></span><br><span class="line"><span class="comment"> *     5.按照此规律继续遍历下去......</span></span><br><span class="line"><span class="comment"> *     6.遍历阶段结束后，stack从栈顶到栈底的元素为{6(值为7),5(值为2),2(值为1)}。</span></span><br><span class="line"><span class="comment"> *     下面清算stack中剩下的元素，将stack的栈顶元素"6"弹出，栈中它的下面位置是5，而由于6位置是清算阶段弹出的，所以res[6] = {5,-1};</span></span><br><span class="line"><span class="comment"> *     弹出5位置，栈中它的下面位置是2,5位置是清算阶段弹出的，所以res[5] = {2,-1};</span></span><br><span class="line"><span class="comment"> *     弹出2位置，栈中它的下面没有位置了,2位置是清算阶段弹出的，所以res[2] = {-1,-1};</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单调栈——返回最近邻的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonotoneStack2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getNearLessNoRepeat(<span class="keyword">int</span>[] arr){</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历阶段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line"></span><br><span class="line">             <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[stack.peek()]){</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">int</span> popIndex = stack.pop();</span><br><span class="line">                 <span class="keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                 res[popIndex][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">                 res[popIndex][<span class="number">1</span>] = i;</span><br><span class="line">             }</span><br><span class="line">             stack.push(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始清算阶段</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> popIndex = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            res[popIndex][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">            res[popIndex][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr2</span><span class="params">(<span class="keyword">int</span>[][] arr)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[<span class="number">0</span>].length; j++) {</span><br><span class="line">                System.out.print(arr[i][j]+<span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = getNearLessNoRepeat(arr);</span><br><span class="line"></span><br><span class="line">        printArr2(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="4-滑动窗口最大值"><a href="#4-滑动窗口最大值" class="headerlink" title="4.滑动窗口最大值"></a>4.滑动窗口最大值</h1><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">LeetCode题目链接</a></p><ul><li>题目</li></ul><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.png"></p><br><ul><li>思路分析</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210816162527.jpg" alt="fe6757733991d64dbbd79685024dae8"></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210816162604.jpg" alt="2"></p><p>参考：程序员代码面试指南第2版（18-20），左程云著</p><br><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取滑动窗口的最大值，使用双端队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxWindow</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getMaxWindow(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> w){</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length-w+<span class="number">1</span>];  <span class="comment">// res数组用来放每个滑动窗口的最大值</span></span><br><span class="line">        LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//qmax 可以理解为一个双向的队列结构，用来放arr的下标</span></span><br><span class="line">                                                         <span class="comment">//qmax从队列头到队列尾应该是单调递减的</span></span><br><span class="line">                                                        <span class="comment">//qmax的队列头始终保存当前滑动窗口的最大值</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;  <span class="comment">//res数组的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当双向递减队列不为空，并且当前的arr[i] 大于等于 arr[队列尾部(下标)]</span></span><br><span class="line">            <span class="comment">//就将队列尾部元素弹出</span></span><br><span class="line">            <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[i] &gt;= arr[qmax.peekLast()]){</span><br><span class="line">                qmax.pollLast();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//程序走到此处，说明队列为空，或者，arr[i] &lt; arr[qmax.peekLast()]</span></span><br><span class="line">            <span class="comment">//此时将下标i加到队列尾部</span></span><br><span class="line">            qmax.addLast(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (qmax.peekFirst() == i-w){  <span class="comment">//说明qmax的队列头已经过期了，或者说滑动窗口已经滑动到下一个位置了，必须更新队列头</span></span><br><span class="line">                qmax.pollFirst();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= w-<span class="number">1</span>){  <span class="comment">//当i==2,到达第一个滑动窗口，更新res[]</span></span><br><span class="line">                res[index++] = arr[qmax.peekFirst()];</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------main-----------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MaxWindow window = <span class="keyword">new</span> MaxWindow();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>};</span><br><span class="line">        <span class="keyword">int</span>[] maxWindow = window.getMaxWindow(arr, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(maxWindow));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><hr><h1 id="5-前-K-个高频元素"><a href="#5-前-K-个高频元素" class="headerlink" title="5.前 K 个高频元素"></a>5.前 K 个高频元素</h1><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">LeetCode题目链接</a></p><ul><li>题目</li></ul><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</span><br><span class="line">你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</span><br><span class="line">题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</span><br><span class="line">你可以按任意顺序返回答案。</span><br></pre></td></tr></tbody></table></figure><br><ul><li>思路分析</li></ul><p>题目最终需要返回的是前 <em>k</em> 个频率最大的元素，可以想到借助堆这种数据结构，对于 <em>k</em> 频率之后的元素不用再去处理，</p><p>进一步优化时间复杂度。</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210816192735.jpeg"></p><p>具体操作为：</p><p>借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率<br>维护一个元素数目为 k 的最小堆<br>每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较<br>如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中<br>最终，堆中的 k个元素即为前 k 个高频元素</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210816192723.gif"></p><p>参考：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/">程序员吴师兄</a></p><br><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopKFrequent</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topK(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k){</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num)){  <span class="comment">//如果包含num</span></span><br><span class="line">                map.put(num,map.get(num)+<span class="number">1</span>); <span class="comment">//将value的值+1</span></span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//上面循环结束，统计到了每个num出现的次数，key=num,value=frequency</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map，用最小堆保存出现频率最大的前k个元素</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>{</span><br><span class="line">                <span class="keyword">return</span> map.get(o1)-map.get(o2);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Integer key : keySet) {</span><br><span class="line">            <span class="keyword">if</span> (priorityQueue.size() &lt; k){</span><br><span class="line">                priorityQueue.add(key);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (map.get(key) &gt; map.get(priorityQueue.peek())){</span><br><span class="line">                priorityQueue.remove();</span><br><span class="line">                priorityQueue.add(key);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> index = res.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty()){</span><br><span class="line">            res[index--] = priorityQueue.remove();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-----------main---------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        TopKFrequent topK = <span class="keyword">new</span> TopKFrequent();</span><br><span class="line">        <span class="keyword">int</span>[] nums = {<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line">        <span class="keyword">int</span>[] res = topK.topK(nums,<span class="number">2</span>);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode题解-栈和队列</title>
      <link href="/posts/b04a.html"/>
      <url>/posts/b04a.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-用栈实现队列"><a href="#1-用栈实现队列" class="headerlink" title="1.用栈实现队列"></a>1.用栈实现队列</h1><p>栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackForQueue</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先准备两个栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先将元素压入第一个栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer val)</span></span>{</span><br><span class="line">        in.push(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将入栈的数据弹出，压入出栈中</span></span><br><span class="line">    <span class="comment">//在这个过程中，必须保证出栈为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in2out</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (out.isEmpty()){  <span class="comment">//如果出栈为空，才操作</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!in.isEmpty()){</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于一个出队列的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//先将 入栈 中的数据 压入到出栈中，这样，经过栈的两次“先进后出”，就实现了队列的“先进先出”</span></span><br><span class="line">        in2out();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看当前的队列的头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>{</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main方法测试一下结果 ***********************************************</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        StackForQueue queue = <span class="keyword">new</span> StackForQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) {</span><br><span class="line">            queue.push(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {</span><br><span class="line">            System.out.println(queue.pop());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="2-用队列实现栈"><a href="#2-用队列实现栈" class="headerlink" title="2.用队列实现栈"></a>2.用队列实现栈</h1><p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队列这种数据结构中，最先插入的元素将是最先被删除的元素；</span></span><br><span class="line"><span class="comment"> * 反之最后插入的元素将是最后被删除的元素，因此队列又称为“先进先出”（FIFO—first in first out）的线性表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Queue用法小结：</span></span><br><span class="line"><span class="comment"> * Queue使用时要尽量避免Collection的add()和remove()方法，</span></span><br><span class="line"><span class="comment"> * 而是要使用offer()来加入元素，使用poll()来获取并移出元素。</span></span><br><span class="line"><span class="comment"> * 它们的优点是通过返回值可以判断成功与否。</span></span><br><span class="line"><span class="comment"> * 而add()和remove()方法在失败的时候会抛出异常。</span></span><br><span class="line"><span class="comment"> * 如果要使用前端而不移出该元素，使用element()或者peek()方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueForStack</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueForStack</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用</span></span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="comment">//首先将val加入到队列中，此时，val位于队列的最后一位</span></span><br><span class="line">        queue.offer(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取队列的大小</span></span><br><span class="line">        <span class="keyword">int</span> count = queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">1</span>){</span><br><span class="line">            <span class="comment">//将当前队列的除val之外的所有元素，先取出队列，再放入队列</span></span><br><span class="line">            <span class="comment">//此时，val就位于队列的首位，那么，就实现了栈的“后进先出”</span></span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//查看当前的队列头</span></span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main方法，测试一下  *****************************************</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        QueueForStack queue = <span class="keyword">new</span> QueueForStack();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) {</span><br><span class="line">            queue.push(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {</span><br><span class="line">            System.out.println(queue.pop());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><hr><h1 id="3-最小值栈：设计一个有getMin功能的栈"><a href="#3-最小值栈：设计一个有getMin功能的栈" class="headerlink" title="3.最小值栈：设计一个有getMin功能的栈"></a>3.最小值栈：设计一个有getMin功能的栈</h1><ul><li><p>题目：实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作</p></li><li><p>要求：</p><ul><li>1.pop,push,getMin操作的时间复杂度都是O(1)</li><li>设计的栈类型可以使用现成的栈结构</li></ul></li><li><p>思路分析：在设计时，使用两个栈，一个栈用来保存所有的元素，其功能和一个正常的栈没有区别，这个栈记为dataStack.</p><p>另一个用来保存每一步的最小值，这个栈的栈针始终指向当前放入栈中元素的最小值，这个栈记为minStack.</p></li><li><p>代码实现</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMinStack</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMinStack</span><span class="params">()</span></span>{</span><br><span class="line">        dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>{</span><br><span class="line">        dataStack.push(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当minStack为空时，放入data</span></span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty()){</span><br><span class="line">            minStack.push(data);</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">else</span> {  <span class="comment">//当minStack不为空时,如果minStack的栈顶元素大于data时，</span></span><br><span class="line">                 <span class="comment">// 将data放入minStack,此时就能保证,minStack的栈顶元素为dataStack的最小值</span></span><br><span class="line">            <span class="keyword">if</span>(minStack.peek() &gt; data){</span><br><span class="line">                minStack.push(data);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (dataStack.isEmpty()){</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your Stack is empty!!!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dataStack.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty()){</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your Stack is empty!"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> dataStack.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main测试一下******************************************</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MyMinStack stack = <span class="keyword">new</span> MyMinStack();</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">5</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">8</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(stack.getMin()); <span class="comment">//1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>​       对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。</p><h1 id="4-用栈实现括号的匹配（Easy）"><a href="#4-用栈实现括号的匹配（Easy）" class="headerlink" title="4. 用栈实现括号的匹配（Easy）"></a>4. 用栈实现括号的匹配（Easy）</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/description/">力扣</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case1:</span><br><span class="line">Input:<span class="string">"()[]{}"</span></span><br><span class="line"></span><br><span class="line">Output : <span class="keyword">true</span></span><br><span class="line">    </span><br><span class="line">case2:</span><br><span class="line">Input:<span class="string">"({})"</span></span><br><span class="line"></span><br><span class="line">Output : <span class="keyword">true</span>    </span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure><ul><li>代码实现</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用栈实现括号的匹配</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input:"()[]{}"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Output : true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidParentheses</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()){</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'{'</span> || c == <span class="string">'['</span>){</span><br><span class="line">                <span class="comment">//当满足"左括号"的条件时，压入栈中</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果此时栈中还为空，则不满足条件</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()){</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">//走到这一步，说明栈中不为空，此时"c"，满足为括号的右半部分</span></span><br><span class="line">                <span class="comment">//此时弹栈拿出括号的坐半部分left</span></span><br><span class="line">                <span class="keyword">char</span> left = stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//以下三个条件说明，在弹栈得到的left时,括号右半部分匹配不上，就返回false;</span></span><br><span class="line">                <span class="keyword">boolean</span> b1 = left == <span class="string">'('</span> &amp;&amp; c != <span class="string">')'</span>;</span><br><span class="line">                <span class="keyword">boolean</span> b2 = left == <span class="string">'{'</span> &amp;&amp; c != <span class="string">'}'</span>;</span><br><span class="line">                <span class="keyword">boolean</span> b3 = left == <span class="string">'['</span> &amp;&amp; c != <span class="string">']'</span>;</span><br><span class="line">                <span class="keyword">if</span> (b1 || b2 || b3){</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试 *******************************</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ValidParentheses vp = <span class="keyword">new</span> ValidParentheses();</span><br><span class="line">        System.out.println(vp.isValid(<span class="string">"()"</span>));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(vp.isValid(<span class="string">"()[]{}"</span>));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(vp.isValid(<span class="string">"{[]}"</span>));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(vp.isValid(<span class="string">"(]"</span>));   <span class="comment">//false</span></span><br><span class="line">        System.out.println(vp.isValid(<span class="string">"([)]"</span>));  <span class="comment">//false</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="5-逆波兰表达式求值"><a href="#5-逆波兰表达式求值" class="headerlink" title="5.逆波兰表达式求值"></a>5.逆波兰表达式求值</h1><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">leetcode题目链接</a></p><ul><li>题目</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">根据 逆波兰表示法，求表达式的值。</span><br><span class="line"></span><br><span class="line">有效的运算符包括 + ,  - ,  * ,  / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: ["2", "1", "+", "3", " * "]</span><br><span class="line">输出: 9</span><br><span class="line">解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: ["4", "13", "5", "/", "+"]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: ["10", "6", "9", "3", "+", "-11", " * ", "/", " * ", "17", "+", "5", "+"]</span><br><span class="line">输出: 22</span><br></pre></td></tr></tbody></table></figure><ul><li>思路分析</li></ul><p>遍历String[]  tokens ,如果tokens[i] 是数字，则直接压入栈中，</p><p>如果是“+”，“-”，“*”，“/”运算符，则从栈中弹出两个数字，然后再把计算结果压入栈中</p><p>最后返回栈中的数字，即为最后的运算结果</p><p>注意：1.如果是运算符是“-”，“/”,注意计算的顺序</p><p>2.String的比较要用equals()方法</p><p>3.char类型的比较可以使用“==”</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif"></p><ul><li>代码详情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆波兰表达式求值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvaluateReversePolishNotation</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span></span>{</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) { <span class="comment">// 遍历tokens数组</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(tokens[i].equals(<span class="string">"+"</span>)  || tokens[i].equals(<span class="string">"-"</span>) || tokens[i].equals(<span class="string">"*"</span>) || tokens[i].equals(<span class="string">"/"</span>)){<span class="comment">//如果是加减乘除字符</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果是操作符，直接弹出两个数字，准备进行运算</span></span><br><span class="line">                <span class="keyword">int</span> num1 = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tokens[i].equals(<span class="string">"+"</span>)){</span><br><span class="line">                    stack.push(num1+num2);</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">"-"</span>)){</span><br><span class="line">                    stack.push(num2-num1);</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">"*"</span>)){</span><br><span class="line">                    stack.push(num1*num2);</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    stack.push(num2 / num1);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span>{  <span class="comment">//如果是数字的话，直接压入</span></span><br><span class="line">                stack.push(stoi(tokens[i]));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Integer <span class="title">stoi</span><span class="params">(String token)</span> </span>{ <span class="comment">// 将String转为Integer</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(token);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------main-----------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        EvaluateReversePolishNotation RPN = <span class="keyword">new</span> EvaluateReversePolishNotation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该算式转化为常见的中缀算术表达式为：</span></span><br><span class="line"><span class="comment">         *   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span></span><br><span class="line"><span class="comment">         * = ((10 * (6 / (12 * -11))) + 17) + 5</span></span><br><span class="line"><span class="comment">         * = ((10 * (6 / -132)) + 17) + 5</span></span><br><span class="line"><span class="comment">         * = ((10 * 0) + 17) + 5</span></span><br><span class="line"><span class="comment">         * = (0 + 17) + 5</span></span><br><span class="line"><span class="comment">         * = 17 + 5</span></span><br><span class="line"><span class="comment">         * = 22</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i = RPN.evalRPN(<span class="keyword">new</span> String[]{<span class="string">"10"</span>, <span class="string">"6"</span>, <span class="string">"9"</span>, <span class="string">"3"</span>, <span class="string">"+"</span>, <span class="string">"-11"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>, <span class="string">"*"</span>, <span class="string">"17"</span>, <span class="string">"+"</span>, <span class="string">"5"</span>, <span class="string">"+"</span>});</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span></span><br><span class="line">        <span class="keyword">int</span> i1 = RPN.evalRPN(<span class="keyword">new</span> String[]{<span class="string">"4"</span>, <span class="string">"13"</span>, <span class="string">"5"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>});</span><br><span class="line">        System.out.println(i1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用数组实现栈</title>
      <link href="/posts/c93a.html"/>
      <url>/posts/c93a.html</url>
      
        <content type="html"><![CDATA[<p>   本例子利用数组实现”栈”这种数据结构，算一个栈的入门案例</p><ul><li>栈的特点：先进后出，后进先出</li><li>在实现栈的弹栈，压栈的操作之前，要判断栈是否为空栈或满栈</li><li>数组的长度即为栈的容量</li></ul><hr><ul><li><p>写一个ArrayForStack类，在这个类中，实现栈的弹栈、压栈等方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayForStack</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayForStack</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造方法，利用构造方法给属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayForStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> top == maxSize-<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">if</span> (isFull()){</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> Exception(<span class="string">"栈已经满了，不能继续压栈了"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        array[++top] = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()){</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"栈已经空了，不能弹栈"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = array[top--];</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>编写一个测试类，测试栈的方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//栈的容量</span></span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        ArrayForStack stack = <span class="keyword">new</span> ArrayForStack(maxSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//压栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxSize; i++) {</span><br><span class="line">            stack.push(i);  <span class="comment">//依次压入0 1 2 3 4 5</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxSize; i++) {</span><br><span class="line">            System.out.println(stack.pop());   <span class="comment">//依次弹出5 4 3 2 1 0</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>接下来利用上面编写的ArrayForStack类，再实现一个<strong>回文字符串</strong>判断的例子</p><p>所谓的回文字符串即为：从左往右 与 从右往左 读这个字符串，结果是一样的</p><p>比如：”aba”就是一个回文串，而:”hello”,从右往左为”olleh”,则”hello”不是一个回文串</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPalindrome</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(detection(<span class="string">"abcdedcba"</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">detection</span><span class="params">(String str)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = str.length();</span><br><span class="line">        </span><br><span class="line">        ArrayForStack stack = <span class="keyword">new</span> ArrayForStack(length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            stack.push(str.charAt(i));</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        String newStr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()){</span><br><span class="line">                <span class="keyword">char</span> s = (<span class="keyword">char</span>)stack.pop();</span><br><span class="line">                newStr += s;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (str.equals(newStr)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github高效搜索项目</title>
      <link href="/posts/2a1b.html"/>
      <url>/posts/2a1b.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>利用项目名(仓库名)</p><p>例如<code>in:name spring boot</code></p></li></ul><ul><li><p>利用项目名+stars</p><p><code>in:name spring boot stars:&gt;1000</code></p></li></ul><ul><li><p>利用项目名+stars+forks</p><p><code>in:name spring boot stars:&gt;1000 forks:&gt;100</code></p></li></ul><ul><li><p>利用readme</p><p><code>in:readme springboot</code></p></li></ul><ul><li><p>利用readme+stars</p><p><code>in:readme springboot stars:&gt;1000</code></p></li></ul><ul><li><p>利用description</p><p><code>in:description 微服务</code></p></li></ul><ul><li><p>利用description + language</p><p><code>in:description 微服务 language:java</code>  </p></li></ul><ul><li><p>利用description + language+日期</p><p><code>in:description 微服务 language:java pushed:&gt;2019-9-9</code>  </p></li></ul><ul><li>点进去查看项目的：描述利用了那些技术，代码结构、最新push日期、火热程度等，查看项目的readme文档</li><li>把github用起来，多去github看开源项目</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> github搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git和github的使用</title>
      <link href="/posts/ec43.html"/>
      <url>/posts/ec43.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="1-Git常用命令"><a href="#1-Git常用命令" class="headerlink" title="1.Git常用命令"></a>1.Git常用命令</h2><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210730164403.png"></p><h2 id="2-分支的操作"><a href="#2-分支的操作" class="headerlink" title="2.分支的操作"></a>2.分支的操作</h2><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210730165654.png"></p><h2 id="3-远程仓库操作"><a href="#3-远程仓库操作" class="headerlink" title="3.远程仓库操作"></a>3.远程仓库操作</h2><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210730190522.png"></p><h2 id="4-IDEA集成git、github"><a href="#4-IDEA集成git、github" class="headerlink" title="4.IDEA集成git、github"></a>4.IDEA集成git、github</h2><ul><li>1.确保idea已经集成了git和github</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731104620.png" alt="git"></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731104957.png" alt="github"></p><ul><li>2.回到idea主界面，创建一个git repository</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731105254.png" alt="创建git仓库"></p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731105926.png"></p><ul><li>3.将代码加入暂存区</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731105744.png"></p><ul><li><p>代码加入暂存区后，文件名由红色变为蓝色</p></li><li><p>4.将代码提交至本地库</p></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731111519.png" alt="代码提交本地库"></p><ul><li>代码提交至本地库后，文件名由蓝色变为正常的白色</li></ul><ul><li>5.查看git的log和master信息</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731113511.png"></p><ul><li><ul><li>切换version</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731113939.png" alt="切换version"></li><li>创建分支</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731114259.png"></li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731114502.png" alt="创建一个hot_fix分支"></li></ul></li></ul><ul><li><p>6.合并分支</p></li><li><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731114742.png"></p></li><li><p>在hot_fix分支下，加一行代码，并提交至本地库</p></li></ul><ul><li>注意：master分支想要合并hot_fix分支，必须在master分支下merge</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731120213.png"></li></ul><ul><li>已经切换至master</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731115506.png"></p><ul><li>开始合并</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731120533.png"></li></ul><ul><li>成功合并</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731120755.png" alt="image-20210731120755672"></li></ul><p>备注：以上演示的为无冲突合并，如果遇到冲突合并(简单理解为：对代码做了不同的修改)，需要进行手动选择代码，然后合并</p><hr><ul><li><p>7.将代码推送至远程github仓库</p><ul><li>7.1 使用ssh免密登陆<ul><li> 进入C:/Users/Administrator/.ssh文件夹，右键选择“Git Bash Here ”</li><li>在命令行输入<code>ssh-keygen -t rsa -C 邮箱  </code>，连续三次回车(其中有一次问你，要不要覆盖文件)</li><li>然后输入<code>cat id_rsa.pub  </code>,得到其文件内容，如下图</li></ul></li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731135430.png"></li></ul></li><li><ul><li><ul><li>复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys →New SSH key</li><li>新建一个SSH key</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731140056.png"></li></ul></li></ul></li></ul><ul><li><ul><li>7.2新建一个远程github仓库，用来储存来自本地仓库的代码，如下图</li><li><ul><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731140751.png" alt="方式一，新建github仓库"></li></ul></li></ul></li><li><ul><li><ul><li>方式二，新建github仓库</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731141204.png" alt="idea中选择share project on github"></li></ul></li></ul></li><li><ul><li><ul><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731141455.png" alt="分享仓库到github"></li></ul></li></ul></li><li><ul><li>7.3push代码到github仓库</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731142219.png" alt="复制仓库的ssh链接"></li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731142602.png" alt="准备push代码到github仓库"></li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731142837.png" alt="push代码到github仓库"></li></ul></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731143015.png" alt="push成功后的github仓库"></p><ul><li><ul><li><p>push代码的重要提示</p><p>注意： push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，<br>push 的操作是会被拒绝的。也就是说， 要想 push 成功，一定要保证本地库的版本要比远程<br>库的版本高！ 因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地<br>代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地<br>代码更新到最新以后，然后再修改，提交，推送！  </p></li></ul></li></ul><ul><li>8 pull 拉取远程库到本地库  <ul><li>首先更新一下github仓库的代码，以示本地和远程的区别</li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731145656.png" alt="本地远程比较"></li><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731143931.png" alt="pull后的本地代码"></li></ul></li></ul><ul><li>9.克隆代码到本地，并利用idea打开<ul><li><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210731144907.png" alt="克隆代码到本地"></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot集成mybatis-plus</title>
      <link href="/posts/667f.html"/>
      <url>/posts/667f.html</url>
      
        <content type="html"><![CDATA[<ul><li>本博客基于springboot-web项目，集成thymeleaf，和mybatis-plus可以实现数据的CRUD和分页显示数据功能</li></ul><h1 id="案例一：实现数据的CRUD"><a href="#案例一：实现数据的CRUD" class="headerlink" title="案例一：实现数据的CRUD"></a>案例一：实现数据的CRUD</h1><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210728140408.png" alt="代码的结构"></p><h2 id="依赖及配置"><a href="#依赖及配置" class="headerlink" title="依赖及配置"></a>依赖及配置</h2><ul><li>1.新建一个springboot-web项目，并选中thymeleaf模板引擎</li><li>2.加入依赖</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>3.配置mysql的账号密码</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=mysql密码</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="代码详情"><a href="#代码详情" class="headerlink" title="代码详情"></a>代码详情</h2><ul><li><p>1.控制层代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动注入业务层的StudentService</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/queryAll")</span>   <span class="comment">//请求路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryAll</span><span class="params">(Model model)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用业务层的方法，查询所有学生</span></span><br><span class="line">        List&lt;Student&gt; students = studentService.list();</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">"students"</span>,students);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将查询结果放入request作用域，并返回到视图层</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"mybatis-plus"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>2.业务层代码(包括一个接口和实现类)</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">Student</span>&gt; </span>{</span><br><span class="line">    <span class="comment">//IService&lt;T&gt; 中的 T 是实体</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>IService为mybatis-plus提供的接口，里面提供了CRUD的基本方法,我们的业务层接口需要实现IService这个接口</p><ul><li>3.业务接口实现类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">StudentMapper</span>, <span class="title">Student</span>&gt; <span class="keyword">implements</span> <span class="title">StudentService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; 中的泛型：M 是 mapper 对象，T 是实体</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>StudentServiceImpl 继承了ServiceImpl，而ServiceImpl是IService 实现类，它提供了IService中方法的具体实现。我们写的业务接口实现类需要继承ServiceImpl这个类，并且要实现我们自己写的StudentService这个接口</p><p>下面给出ServiceImpl类的部分代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IService 实现类（ 泛型：M 是 mapper 对象，T 是实体 ）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>{}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>4.持久层代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Student</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>StudentMapper继承了 BaseMapper<t>这一接口，当我们编写的Mapper接口 继承该接口后，无需编写 mapper.xml 文件，即可获得CRUD功能</t></p><p>说明：除了在该类的上面添加@Mapper,注明这是一个持久层之外，还可以在程序的主入口添加@MapperScan注解(两个注解选择一个使用即可)</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210728143021.png"></p></li></ul><ul><li><p>5.实体类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName("t_student")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    setter and getter</span><br><span class="line">        </span><br><span class="line">    toString</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>@TableName(“t_student”)由mybatis-plus提供，作用使该实体类与对应的数据库中的表名对应，例如类Student&lt;===&gt;表t_student</p><p>@TableField(exist = false)由mybatis-plus提供,作用是标注出，数据库中的表不存在该字段</p><ul><li>5.视图层的代码(由控制层转到视图层mybatis-plus.html)</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>查询所有学生<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"student:${students}"</span>&gt;</span>   <span class="comment">&lt;!--thymeleaf循环一个list--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[${student.id}]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span>       <span class="comment">&lt;!--thymeleaf的行内写法，取出相应的变量--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[${student.name}]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[${student.age}]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>6查询结果</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210728144549.png"></p></li></ul><p>与数据库中的数据一致</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210728144649.png"></p><h1 id="案例二：实现分页数据的展示"><a href="#案例二：实现分页数据的展示" class="headerlink" title="案例二：实现分页数据的展示"></a>案例二：实现分页数据的展示</h1><ul><li>数据的分页展示，在案例一的基础上修改而来</li></ul><h2 id="分页功能具体实现"><a href="#分页功能具体实现" class="headerlink" title="分页功能具体实现"></a>分页功能具体实现</h2><ul><li><p>1.新建一个配置类，用来加载分页插件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"加载分页插件"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li>2.修改控制层代码</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/queryAll")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryAll</span><span class="params">(<span class="meta">@RequestParam(value = "pn",defaultValue = "1")</span> Integer pn,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Model model)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分页查询，pn表示当前页，6表示每页几条数据</span></span><br><span class="line">        Page&lt;Student&gt; studentPage = <span class="keyword">new</span> Page&lt;&gt;(pn,<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//分页查询结果</span></span><br><span class="line">        Page&lt;Student&gt; page = studentService.page(studentPage, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        page.getCurrent(); <span class="comment">//获取当前页</span></span><br><span class="line">        page.getPages();   <span class="comment">//获取总的页数</span></span><br><span class="line">        page.getTotal();   <span class="comment">//获取总记录数</span></span><br><span class="line">        </span><br><span class="line">        model.addAttribute(<span class="string">"page"</span>,page);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"mybatis-plus"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><ul><li>访问路径为<code>“/queryAll”</code>,请求参数为<code>pn</code>,表示当前页，默认为1</li><li>调用<code>studentService.page()</code>,即可得到Page对象，其内部属性，就是我们想要的与分页功能相关的数据</li><li>将page放入request作用域</li></ul></li></ul><ul><li>3.修改视图显示的代码</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>查询所有学生<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"student:${page.records}"</span>&gt;</span> <span class="comment">&lt;!--thymeleaf循环一个list--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[${student.id}]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span>      <span class="comment">&lt;!--thymeleaf的行内写法，取出相应的变量--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[${student.name}]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[${student.age}]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上方展示的student详情的list集合，必须从page.records中取--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--#########################以下内容与分页功能相关###############################--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[[${page.current}]]为thymeleaf的写法，可以取出request域的变量--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--page.current、page.pages、page.total都是放在request作用域中的变量page的属性}--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>当前第 [[${page.current}]] 页 总计 [[${page.pages}]] 页 共 [[${page.total}]] 条记录<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--#numbers.sequence(1,page.pages)，该表达式是thymeleaf的写法。</span></span><br><span class="line"><span class="comment">            表示可以生成一个从"1"到"page.pages"的序列,然后用thymeleaf的foreach循环，就可以得到页码num了--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"num:${#numbers.sequence(1,page.pages)}"</span> &gt;</span></span><br><span class="line">                <span class="comment">&lt;!--下面的写法为thymeleaf的超链接写法</span></span><br><span class="line"><span class="comment">                    [[${num}]]用来显示页码数</span></span><br><span class="line"><span class="comment">                    @{/queryAll(pn=${num})}表示超链接的链接地址,(pn=${num})表示请求参数</span></span><br><span class="line"><span class="comment">                    @{/queryAll(pn=${num})}等价于@{/queryAll?pn=num}</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@{/queryAll(pn=${num})}"</span>&gt;</span>[[${num}]]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>前端分页功能代码的说明见注释</li></ul><hr><ul><li><p>结果展示</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210728190430.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatis-plus </tag>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot定制化组件的方式</title>
      <link href="/posts/4e7c.html"/>
      <url>/posts/4e7c.html</url>
      
        <content type="html"><![CDATA[<h2 id="定制化组件的常见方式"><a href="#定制化组件的常见方式" class="headerlink" title="定制化组件的常见方式"></a>定制化组件的常见方式</h2><ul><li><p>修改配置文件；</p></li><li><p><strong>xxxxxCustomizer；</strong></p></li><li><p><strong>编写自定义的配置类   xxxConfiguration；+</strong> <strong>@Bean替换、增加容器中默认组件；视图解析器</strong> </p></li><li><p><strong>Web应用 编写一个配置类实现</strong> <strong>WebMvcConfigurer 即可定制化web功能；(+ @Bean给容器中再扩展一些组件,可选的)</strong></p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminWebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>{}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>@EnableWebMvc + WebMvcConfigurer —— @Bean  可以全面接管SpringMVC，所有规则全部自己重新配置； </p><p>实现定制和扩展功能</p><ul><li><p>原理</p></li><li><p> 1、WebMvcAutoConfiguration  默认的SpringMVC的自动配置功能类。静态资源、欢迎页…..</p></li><li><p>2、一旦使用 @EnableWebMvc 会 @Import(DelegatingWebMvcConfiguration.<strong>class</strong>)</p></li><li><p>3、<strong>DelegatingWebMvcConfiguration</strong> 的 作用，只保证SpringMVC最基本的使用</p><ul><li><p>把所有系统中的 WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer  合起来一起生效</p></li><li><p>自动配置了一些非常底层的组件。<strong>RequestMappingHandlerMapping</strong>、这些组件依赖的组件都是从容器中获取</p><ul><li> <strong>public class</strong> DelegatingWebMvcConfiguration <strong>extends</strong> <strong>WebMvcConfigurationSupport</strong></li></ul></li></ul></li><li><p>4、<strong>WebMvcAutoConfiguration</strong> 里面的配置要能生效 必须  @ConditionalOnMissingBean(<strong>WebMvcConfigurationSupport</strong>.<strong>class</strong>)</p></li><li><p>5、@EnableWebMvc  导致了 <strong>WebMvcAutoConfiguration  没有生效。</strong></p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> springboot定制化组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot文件上传</title>
      <link href="/posts/c59d.html"/>
      <url>/posts/c59d.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>springboot中文件上传，可以将上传的文件保存到本地，或者保存到文件服务器，OSS</li><li>下面通过一个springboot-thymeleaf项目，演示这一过程</li></ul><h2 id="项目流程"><a href="#项目流程" class="headerlink" title="项目流程"></a>项目流程</h2><ul><li>1.浏览器地址栏访问：http:localhost:8080/,跳转到templates/file_form.html</li><li>2.在file_form.html页面，选择需要上传的文件(支持单个、多个文件上传，文件的最大值在配置文件中指定)，提交后转到控制层的upload方法</li><li>3.在upload方法中，上传的文件被保存到本地</li></ul><h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><ul><li>项目文件结构</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210727160921.png" alt="image-20210727160915269"></p><ul><li><p>控制层代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"file_form"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("/upload")</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(<span class="meta">@RequestPart("picture")</span> MultipartFile picture,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="meta">@RequestPart("photos")</span> MultipartFile[] photos)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="keyword">if</span>(!picture.isEmpty()){</span><br><span class="line">            String originalFilename = picture.getOriginalFilename();</span><br><span class="line">            <span class="comment">//保存文件到本地</span></span><br><span class="line">            picture.transferTo(<span class="keyword">new</span> File(<span class="string">"E:\\test\\"</span>+originalFilename));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (photos.length &gt; <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">for</span> (MultipartFile photo : photos) {</span><br><span class="line">                <span class="keyword">if</span> (!photo.isEmpty()){</span><br><span class="line">                    String originalFilename = photo.getOriginalFilename();</span><br><span class="line">                    <span class="comment">//保存文件到本地</span></span><br><span class="line">                    photo.transferTo(<span class="keyword">new</span> File(<span class="string">"E:\\test\\"</span>+originalFilename));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"文件上传成功"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>前端的file_form.html页面</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">th:action</span>=<span class="string">"@{/upload}"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> &gt;</span></span><br><span class="line">  单个文件:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"picture"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  多个文件:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"photos"</span> <span class="attr">multiple</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>项目的配置文件</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上传总文件的最大值</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.max-request-size</span>=<span class="string">100MB</span></span><br><span class="line"><span class="comment"># 单个文件的最大值</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.max-file-size</span>=<span class="string">10MB</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>启动程序</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootFileUploadApplication</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(SpringbootFileUploadApplication.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interceptor拦截器的使用</title>
      <link href="/posts/ce45.html"/>
      <url>/posts/ce45.html</url>
      
        <content type="html"><![CDATA[<h1 id="springboot项目中拦截器的使用"><a href="#springboot项目中拦截器的使用" class="headerlink" title="springboot项目中拦截器的使用"></a>springboot项目中拦截器的使用</h1><ul><li>1.编写一个拦截器实现HandlerInterceptor接口</li><li>2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）</li><li>3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】</li></ul><hr><h2 id="1-实现HandlerInterceptor接口"><a href="#1-实现HandlerInterceptor接口" class="headerlink" title="1.实现HandlerInterceptor接口"></a>1.实现HandlerInterceptor接口</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标方法执行之前，进行拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"preHandle方法执行了{}"</span>,request.getRequestURI());</span><br><span class="line">        String userName = (String) request.getSession().getAttribute(<span class="string">"userName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(userName != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/"</span>).forward(request,response);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标方法执行完成之后</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"postHandle方法执行了{}"</span>,modelAndView);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//页面渲染之后</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"afterCompletion方法执行了"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-拦截器注册到容器中"><a href="#2-拦截器注册到容器中" class="headerlink" title="2.拦截器注册到容器中"></a>2.拦截器注册到容器中</h2><ul><li><p>实现WebMvcConfigurer的addInterceptors</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>{</span><br><span class="line"></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>)              <span class="comment">//需要拦截的资源</span></span><br><span class="line">                .excludePathPatterns(<span class="string">"/"</span>,<span class="string">"/login"</span>);  <span class="comment">//需要放行的资源</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="3-拦截器原理"><a href="#3-拦截器原理" class="headerlink" title="3.拦截器原理"></a>3.拦截器原理</h2><p>1、根据当前请求，找到<strong>HandlerExecutionChain【</strong>可以处理请求的handler以及handler的所有 拦截器】</p><p>2、先来<strong>顺序执行</strong> 所有拦截器的 preHandle方法</p><ul><li>1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle</li><li>2、如果当前拦截器返回为false。直接    倒序执行所有已经执行了的拦截器的  afterCompletion；</li></ul><p><strong>3、如果任何一个拦截器返回false。直接跳出不执行目标方法</strong></p><p><strong>4、所有拦截器的prehandler都返回true，才执行目标方法</strong></p><p><strong>5、倒序执行所有拦截器的postHandle方法。</strong></p><p><strong>6、前面的步骤有任何异常都会直接倒序触发</strong> afterCompletion</p><p>7、页面成功渲染完成以后，也会倒序触发 afterCompletion</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210726223649.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Interceptor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot集成websocket实现聊天室的index.jsp代码</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight jsp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;script src="${pageContext.request.contextPath}/js/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;title&gt;SpringBoot+WebSocket+JSP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body style=<span class="string">"margin: 45px;"</span>&gt;</span><br><span class="line">    &lt;h4&gt;在线聊天室&lt;/h4&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">        &lt;label for="content"&gt;&lt;/label&gt;</span><br><span class="line">        &lt;textarea id="content" readonly="readonly" cols="80" rows="15"&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span> style=<span class="string">"margin-top: 8px"</span>&gt;</span><br><span class="line">        &lt;textarea id="message" cols="80" rows="5" placeholder="请输入消息"&gt;&lt;/textarea&gt;</span><br><span class="line">        &lt;div style=<span class="string">"margin-top: 10px"</span>&gt;</span><br><span class="line">            &lt;button id="toSend" class="btn btn-info"&gt;发送&lt;/button&gt;</span><br><span class="line">            &lt;button id="user_exit" class="btn btn-danger"&gt;离开&lt;/button&gt;</span><br><span class="line">            &lt;input id=<span class="string">"username"</span> value=<span class="string">"${username}"</span> style=<span class="string">"display: none"</span>&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        $(function () {</span><br><span class="line">            <span class="keyword">var</span> ws;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"WebSocket"</span> in window) {</span><br><span class="line">                <span class="keyword">var</span> baseUrl = <span class="string">'ws://localhost:8080/websocket/'</span>;</span><br><span class="line">                <span class="keyword">var</span> userName = $(<span class="string">'#username'</span>).val();</span><br><span class="line">                ws = <span class="keyword">new</span> WebSocket(baseUrl + userName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 连通之后的回调事件，建立连接</span></span><br><span class="line">                ws.onopen = function () {</span><br><span class="line">                    console.log(<span class="string">"建立 websocket 连接..."</span>);</span><br><span class="line">                };</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收后台服务端的消息</span></span><br><span class="line">                ws.onmessage = function (event) {</span><br><span class="line">                    $(<span class="string">'#content'</span>).append(event.data + <span class="string">'\n\n'</span>);</span><br><span class="line">                    console.log(<span class="string">"接收到服务端发送的消息..."</span> + event.data + <span class="string">'\n'</span>);</span><br><span class="line">                };</span><br><span class="line"></span><br><span class="line">                ws.onerror = function (event) {</span><br><span class="line">                    console.log(<span class="string">"websocket发生错误..."</span> + event + <span class="string">'\n'</span>);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 连接关闭的回调事件</span></span><br><span class="line">                ws.onclose = function () {</span><br><span class="line">                    $(<span class="string">'#content'</span>).append(<span class="string">'['</span> + userName + <span class="string">'] 已离开!'</span>);</span><br><span class="line">                    console.log(<span class="string">"关闭 websocket 连接..."</span>);</span><br><span class="line">                };</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 浏览器不支持 WebSocket</span></span><br><span class="line">                alert(<span class="string">"您的浏览器不支持WebSocket!"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 客户端发送消息到服务器</span></span><br><span class="line">            $(<span class="string">'#toSend'</span>).click(function () {</span><br><span class="line">                sendMsg();</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            $(document).keyup(function (event) {</span><br><span class="line">                <span class="comment">// 回车键事件</span></span><br><span class="line">                <span class="keyword">if</span> (event.keyCode == <span class="number">13</span>) {</span><br><span class="line">                    sendMsg();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="function">function <span class="title">sendMsg</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="comment">//websocket发送消息</span></span><br><span class="line">                ws.send($(<span class="string">'#message'</span>).val());</span><br><span class="line">                $(<span class="string">'#message'</span>).val(<span class="string">""</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 退出</span></span><br><span class="line">            $(<span class="string">'#user_exit'</span>).click(function () {</span><br><span class="line">                <span class="keyword">if</span> (ws) {</span><br><span class="line">                    ws.close();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--此页面的源代码即为index.jsp的代码--%&gt;</span><br><span class="line">&lt;%--点击右键即可查看网页源代码--%&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot集成websocket实现聊天室</title>
      <link href="/posts/3a35.html"/>
      <url>/posts/3a35.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-websocket简介"><a href="#1-websocket简介" class="headerlink" title="1.websocket简介"></a>1.websocket简介</h1><h2 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h2><p>WebSocket协议是由HTML5定义的，基于TCP协议实现的一种网络协议，通过该协议服务器可以主动向客户端发送信息；</p><p>WebSocket 协议在2008年诞生，2011年成为W3C国际标准；我们已经有了 HTTP 协议，为什么出现一个websocket协议？</p><p>http协议是短连接，因为请求之后，都会关闭连接，下次重新请求数据，需要再次打开链接；WebSocket协议是一种长连接，只需要通过一次请求来初始化连接，然后所有的请求和响应都是通过这个TCP连接进行通讯； 所以HTTP协议通信只能是客户端向服务器发出请求，服务器返回响应结果，HTTP 协议做不到服务器主动向客户端推送信息，而websocket能实现服务器和客户端全双工通信；</p><ul><li>何谓全双工</li></ul><p>信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工，信息能够同时双向传送则称为全双工；</p><ul><li>基本实现原理</li></ul><p>WebSocket协议基于TCP协议实现，客户端和服务器只需要做一个握手的动作之后，形成了一条基于客户端和服务器之间的快速通道，之后客户端与服务端之间便可以进行多次数据帧双向传输；这样实现的目的是客户端和服务器进行频繁双向通信时，可以使服务器避免频繁创建HTTP连接，节约资源，提高工作效率和资源利用率。</p><h2 id="传统Web推送实现"><a href="#传统Web推送实现" class="headerlink" title="传统Web推送实现"></a>传统Web推送实现</h2><p>​        在没有WebSocket协议之前，服务器如何向浏览器端推送消息？通常的实现方式是在页面通过Ajax定时轮询，比如每隔1秒中向服务器发送一次HTTP请求，询问服务器是否有新消息，服务器返回结果；这种形式缺点很明显，浏览器需要不断的向服务器发出HTTP请求，而HTTP请求包含较长的头部，有效信息相对较少，反复的无效请求占用了大量的带宽和 CPU 资源，造成很大的浪费，所以，WebSocket 应运而生；HTML5定义的WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯；</p><p>WebSocket协议本质上是一个基于TCP的协议，因此与HTTP协议没有什么关系；</p><h2 id="WebSocket的特点"><a href="#WebSocket的特点" class="headerlink" title="WebSocket的特点"></a>WebSocket的特点</h2><p>全双工通信，客户端和服务器可以双向平等通信；</p><p>建立在TCP协议之上，服务器端的实现比较容易；</p><p>数据格式比较轻量，性能开销小，通信高效；</p><p>可以发送文本，也可以发送二进制数据；</p><p>通信具有更强的实时性；</p><p>协议标识符是ws，服务器地址就是：ws://<a href="http://www.abc.com/some/path">www.abc.com/some/path</a></p><p>http协议： http://</p><h2 id="websocket的业务场景"><a href="#websocket的业务场景" class="headerlink" title="websocket的业务场景"></a>websocket的业务场景</h2><p>WebSocket聊天室；</p><p>股票实时价格显示等应用；</p><p>即时通讯、游戏、可视化大屏展示等领域；</p><p>企业内部管理通讯等功能，主要通讯协议websocket；</p><p>web网页聊天、客服系统实现；</p><p>系统提醒、用户上下线提醒、客户端同步，实时数据更新，多屏幕同步，用户在线状态，消息通知，扫描二维码登录/二维码支付，弹幕、各类信息提醒，在线选座，实时监控大屏等等；</p><br><h2 id="Java中的WebSocket-API"><a href="#Java中的WebSocket-API" class="headerlink" title="Java中的WebSocket API"></a>Java中的WebSocket API</h2><p>在Java EE 7中Java语言开始支持websocket协议，Java EE 7中定义了一套Websocket API规范，也就是一系列接口，没有实现，位于包javax.websocket下，包含客户端API和服务端API，WebSocket的Java API 只是规范，具体实现需要web容器（比如tomcat就实现了Java websocket api）、Java EE服务器或者框架提供；</p><ul><li><p>在java中服务端的实现</p><p>1、Tomcat：java中的websocket实现，需要tomcat 7.0.47+以上才支持，</p><p>Java EE7的支持；</p><p>2、Spring的websocket，需要Spring 4.x，所以springboot也可以用；</p></li></ul><h1 id="2-Websocket开发相关注解及API方法"><a href="#2-Websocket开发相关注解及API方法" class="headerlink" title="2.Websocket开发相关注解及API方法"></a>2.Websocket开发相关注解及API方法</h1><h2 id="websocket注解"><a href="#websocket注解" class="headerlink" title="websocket注解"></a>websocket注解</h2><ul><li><p>@ServerEndpoint(“/websocket/{uid}”)</p><p>申明这是一个websocket服务；</p><p>需要指定访问该服务的地址，在地址中可以指定参数，需要通过{}进行占位；</p></li><li><p>@OnOpen</p><p>用法：<code>public void onOpen(Session session, @PathParam("uid") String uid) throws IOException{}</code></p><p>该方法将在建立连接后执行，会传入session对象，就是客户端与服务端建立的长连接通道，通过@PathParam获取url中声明的参数；</p></li><li><p>@OnClose</p><p>用法：<code>public void onClose() {}</code></p><p>该方法是在连接关闭后执行；</p></li><li><p>@OnMessage</p><p>用法：<code>public void onMessage(String message, Session session) throws IOException {}</code></p><p>该方法用于接收客户端发送的消息；</p><p>message：发来的消息数据；</p><p>session：会话对象（也是长连接通道）；</p><p>发送消息到客户端；</p><p>用法：<code>session.getBasicRemote().sendText("hello,websocket.");</code></p><p>通过session进行消息发送；</p></li></ul><h2 id="前端技术对websocket的支持"><a href="#前端技术对websocket的支持" class="headerlink" title="前端技术对websocket的支持"></a>前端技术对websocket的支持</h2><p>Websocket是html5规范，主流浏览器都支持；（某些老浏览器不支持）</p><p>jQuery、vueJS、React JS、angularjs等都可以支持webscoket对象；</p><p>底层是javascript支持的一个webscoket的js对象，通过这个对象可以建立websocket的连接：<em>ws://localhost:8080/websocket/12345</em></p><hr><p>WebSocket有很多优点，弥补了http协议的不足，但是如果服务端维护很多长连接也是很耗费资源的，服务器集群带来了复杂性以及存在老版本浏览器兼容性问题，各大厂目前大多数还是基于轮询的方式实现的，比如：扫码登录、支付成功通知、秒杀成功通知等；</p><p>在秒杀场景中，用轮询即可，前端轮询一般不可能穿透到后端数据库查询，一般是采用高性能的缓存标记来判定秒杀是否成功，相对于websocket长连接以及其不确定因素，轮询依然是相对比较合适的方案；</p><p>Websocket各浏览器的支持情况：</p><p><a href="https://caniuse.com/#search=websocket">https://caniuse.com/#search=websocket</a></p><h1 id="3-springboot集成WebSocket实现多人聊天室"><a href="#3-springboot集成WebSocket实现多人聊天室" class="headerlink" title="3.springboot集成WebSocket实现多人聊天室"></a>3.springboot集成WebSocket实现多人聊天室</h1><ul><li><p>项目代码结构分布</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210725124045.png"></p><ul><li><p>pom文件依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--此项目的GAV坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>041-springboot-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--springboot web项目的起步依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--spring-boot-starter-websocket--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--lombok,需要在IDEA中安装lombok插件才能使用该依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--引入Spring Boot内嵌的Tomcat对JSP的解析包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--热部署插件(该依赖不是必选项)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--src/main/java下的.xml配置文件编译到target下去--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--src/main/resources下的配置文件编译到target下去--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--src/main/webapp下的jsp页面编译到META-INF/resources下才能访问--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF/resources<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><ul><li><p>项目的主配置文件application.properties</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#设置jsp文件的前缀和后缀</span><br><span class="line">spring.mvc.view.prefix=/</span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></tbody></table></figure></li><li><p>index.jsp文件详情</p><figure class="highlight jsp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo博客不能正常显示jsp格式的代码</span><br><span class="line">代码详情见本站的博文：<span class="string">"springboot集成websocket实现聊天室的index-jsp代码"</span>，</span><br><span class="line">进入该博文页面后，点击右键即可查看index.jsp的源代码</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>还需要一个jquery.min.js文件，可以去网上下载</li></ul></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210725132514.png"></p><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><ul><li><p>后端代码结构</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210725133127.png"></p></li><li><p>首先是endpoint包下的chatServerEndpoint.java 文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.PathParam;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * 1、<span class="doctag">@ServerEndpoint</span>注解中指定WebSocket协议的地址；</span></span><br><span class="line"><span class="comment"> * 2、<span class="doctag">@OnOpen</span>、<span class="doctag">@OnMessage</span>、<span class="doctag">@OnClose</span>、<span class="doctag">@OnError</span>注解与WebSocket中监听事件对应</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span> <span class="comment">//lombok jar包，帮我们自动生成一些代码：@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint("/websocket/{username}")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServerEndpoint</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立时触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openSession</span><span class="params">(<span class="meta">@PathParam("username")</span> String username, Session session)</span> </span>{</span><br><span class="line">        log.info(<span class="string">"用户{}登录"</span>, username);</span><br><span class="line">        String message = <span class="string">"用户["</span> + username + <span class="string">"] 已进入聊天室！"</span>;</span><br><span class="line">        <span class="comment">// 发送登录消息给其他人</span></span><br><span class="line">        WebSocketUtils.sendMessageAll(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前在线人数，发给自己</span></span><br><span class="line">        String onlineInfo = WebSocketUtils.getOnlineInfo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        WebSocketUtils.sendMessage(session, onlineInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加自己到map中</span></span><br><span class="line">        WebSocketUtils.CLIENTS.put(username, session);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端接收服务端数据时触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="meta">@PathParam("username")</span> String username, String message)</span> </span>{</span><br><span class="line">        log.info(<span class="string">"发送消息：{}, {}"</span>, username, message);</span><br><span class="line">        <span class="comment">//广播，把消息同步给其他客户端</span></span><br><span class="line">        WebSocketUtils.sendMessageAll(<span class="string">"["</span> + username + <span class="string">"] : "</span> + message);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭时触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(<span class="meta">@PathParam("username")</span> String username, Session session)</span> </span>{</span><br><span class="line">        <span class="comment">// 当前的Session移除某个用户</span></span><br><span class="line">        WebSocketUtils.CLIENTS.remove(username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 离开消息通知所有人</span></span><br><span class="line">        WebSocketUtils.sendMessageAll(<span class="string">"["</span> + username + <span class="string">"] 已离开！"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//关闭WebSocket Session会话</span></span><br><span class="line">            session.close();</span><br><span class="line">            log.info(<span class="string">"{} 已退出, onclose"</span>, username);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">"onClose error"</span>, e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通信发生错误时触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable throwable)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//关闭WebSocket Session会话</span></span><br><span class="line">            session.close();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">"onError Exception"</span>, e);</span><br><span class="line">        }</span><br><span class="line">        log.info(<span class="string">"Throwable msg "</span> + throwable.getMessage());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>endpoint包下的WebSocketUtils.java 文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.RemoteEndpoint;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketUtils</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WebSocketUtils.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储WebSocket session</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 用户名为key，WebSocket Session对象为value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Session&gt; CLIENTS = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用连接发送数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 用户session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 发送内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Session session, String message)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> RemoteEndpoint.Basic basic = session.getBasicRemote();</span><br><span class="line">        <span class="keyword">if</span> (basic == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//发送</span></span><br><span class="line">            basic.sendText(message);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(<span class="string">"sendMessage IOException "</span>, e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息给其他所有人</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessageAll</span><span class="params">(String message)</span> </span>{</span><br><span class="line">        CLIENTS.forEach((sessionId, session) -&gt; sendMessage(session, message));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有在线用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getOnlineInfo</span><span class="params">()</span> </span>{</span><br><span class="line">        Set&lt;String&gt; userNames = CLIENTS.keySet();</span><br><span class="line">        <span class="keyword">if</span> (userNames.size() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"当前无人在线..."</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> CLIENTS.keySet().toString() + <span class="string">"在线"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>接着是controller包下的ChatController.java文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger idProducer = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span> </span>{</span><br><span class="line">        model.addAttribute(<span class="string">"username"</span>,<span class="string">"user"</span> + idProducer.getAndIncrement());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>项目启动后，访问根路径，转发到index.jsp</p></li></ul><ul><li><p>最后是config包下的WebSocketConfig.java文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointExporter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableWebSocket</span> <span class="comment">//启用WebSocket支持</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//表示配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置ServerEndpointExporter的bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 该Bean会自动注册使用了<span class="doctag">@ServerEndpoint</span>注解声明的Websocket endpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>最后的最后，是程序的主入口Application.java，用来启动整个项目</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><hr><h2 id="项目启动运行"><a href="#项目启动运行" class="headerlink" title="项目启动运行"></a>项目启动运行</h2><ul><li>在浏览器地址栏输入<code>http://localhost:8080/</code></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210725134704.png"></p><ul><li><p>示例如下</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210725135015.png"></p></li><li><p>在另一个浏览器地址栏(或者相同浏览器新建一个窗口)输入<a href="http://localhost:8080/%EF%BC%8C%E5%8D%B3%E5%8F%AF%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9">http://localhost:8080/，即可实现多人聊天</a></p></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210725135417.png"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之-MatrixVariable注解使用</title>
      <link href="/posts/80aa.html"/>
      <url>/posts/80aa.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​        根据 URI 规范 RFC 3986 中 URL 的定义，路径片段中可以可以包含键值对。规范中没对对应的术语。一般 “URL 路径参数” 可以被应用，尽管更加独特的 “矩阵 URI” 也经常被使用并且相当有名。在 Spring MVC 它被称为矩阵变量。</p><p>    矩阵变量可以出现在任何路径片段中，每一个矩阵变量都用分号（;）隔开。比如 <code>/cars;color=red;year=2012</code>。多个值可以用逗号隔开，比如<code>color=red,green,blue</code>，或者分开写 <code>color=red;color=green;color=blue</code>。</p><p>    如果你希望一个 URL 包含矩阵变量，那么请求映射模式必须用 URI 模板来表示这些矩阵变量。这样的话，不管矩阵变量顺序如何，都能够保证请求可以正确的匹配。</p><p>Springboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。</p><hr><p>下面用一个springboot项目演示 @MatrixVariable的具体使用方法</p><hr><h1 id="1-前端代码部分"><a href="#1-前端代码部分" class="headerlink" title="1.前端代码部分"></a>1.前端代码部分</h1><ul><li><p>项目的结构分布</p><p> <img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210724221425.png" alt="Snipaste_2021-07-24_21-52-52"></p></li><li><p>前端index.html的代码如下</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>springboot注解之@MatrixVariable<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>springboot注解之@MatrixVariable<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/car/sell;num=10;brand=BYD,AuDi"</span>&gt;</span>@MatrixVariable（矩阵变量）/car/{sell}<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/boss/1;age=20/2;age=30"</span>&gt;</span>@MatrixVariable（矩阵变量）/boss/{bossId}/{empId}<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><p>​    </p><p>1.在<code>/car/sell</code>路径下访问，请求参数为num和brand</p><p>2.在<code>/boss/{bossId}/{empId}</code>路径下访问.请求参数age=20表示<code>/boss/bossId?age=20</code>.</p><p>而请求参数age=30则表示访问路径<code>/boss/bossId/empId?age=30</code></p><h1 id="2-后端代码部分"><a href="#2-后端代码部分" class="headerlink" title="2.后端代码部分"></a>2.后端代码部分</h1><h2 id="2-1-配置类MyConfig-java"><a href="#2-1-配置类MyConfig-java" class="headerlink" title="2.1 配置类MyConfig.java"></a>2.1 配置类MyConfig.java</h2><p>Springboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.springboot.conf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.PathMatchConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.util.UrlPathHelper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>{</span><br><span class="line"></span><br><span class="line">        UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">        urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);</span><br><span class="line">        configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-控制器AnnotationController-java"><a href="#2-2-控制器AnnotationController-java" class="headerlink" title="2.2 控制器AnnotationController.java"></a>2.2 控制器AnnotationController.java</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.springboot.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/car/{path}")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getCar</span><span class="params">(<span class="meta">@MatrixVariable("num")</span> Integer num,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="meta">@MatrixVariable("brand")</span> List&lt;String&gt; brand,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="meta">@PathVariable("path")</span> String path)</span></span>{</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"num"</span>,num);</span><br><span class="line">        map.put(<span class="string">"brand"</span>,brand);</span><br><span class="line">        map.put(<span class="string">"path"</span>,path);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping("/boss/{bossId}/{empId}")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getAge</span><span class="params">(<span class="meta">@PathVariable("bossId")</span> Integer bossId,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="meta">@PathVariable("empId")</span> Integer empId,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="meta">@MatrixVariable(value = "age",pathVar = "bossId")</span> Integer bossAge,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="meta">@MatrixVariable(value = "age",pathVar = "empId")</span> Integer empAge)</span></span>{</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">"bossId"</span>,bossId);</span><br><span class="line">        map.put(<span class="string">"empId"</span>,empId);</span><br><span class="line">        map.put(<span class="string">"bossAge"</span>,bossAge);</span><br><span class="line">        map.put(<span class="string">"empAge"</span>,empAge);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-主程序入口"><a href="#2-3-主程序入口" class="headerlink" title="2.3 主程序入口"></a>2.3 主程序入口</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.springboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootAnnotationApplication</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(SpringbootAnnotationApplication.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="3-结果演示"><a href="#3-结果演示" class="headerlink" title="3.结果演示"></a>3.结果演示</h1><ul><li>启动主程序<code>SpringbootAnnotationApplication</code>，在浏览器地址栏输入：<code>http://localhost:8080/</code>,可以得到如下页面</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210724223130.png" alt="image-20210724223130092"></p><ul><li><p>点击第一个链接，得到如下结果</p><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210724223208.png"></p></li><li><p>点击第二个链接，得到如下结果</p></li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/20210724223237.png" alt="image-20210724223237483"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MatrixVariable </tag>
            
            <tag> springboot注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法的使用、博文标题的使用</title>
      <link href="/posts/9892.html"/>
      <url>/posts/9892.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="关于博文的Front-matter的使用"><a href="#关于博文的Front-matter的使用" class="headerlink" title="关于博文的Front-matter的使用"></a>关于博文的Front-matter的使用</h1><ul><li>Front-matter中的内容为非必填项，但建议至少填写title和date</li></ul><p><img src="https://gitee.com/ColorQian/cloudimages/raw/master/img/Snipaste_2021-06-19_15-50-13.png"></p><ul><li>最全示例</li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">基于</span> <span class="string">Hexo</span> <span class="string">GitHub</span> <span class="string">从零开始搭建个人博客</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-12-30 09:25:00</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Sitoi</span></span><br><span class="line"><span class="attr">img:</span> <span class="string">/source/images/xxx.jpg</span></span><br><span class="line"><span class="attr">top:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">cover:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">coverImg:</span> <span class="string">/images/1.jpg</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">summary:</span> <span class="string">这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">Hexo</span> <span class="string">GitHub</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Blog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GitHub</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><ul><li>转载自:<a href="https://sitoi.cn/posts/63466.html">https://sitoi.cn/posts/63466.html</a></li></ul><hr><h1 id="markdown-的基本语法"><a href="#markdown-的基本语法" class="headerlink" title="markdown 的基本语法"></a>markdown 的基本语法</h1><h2 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1.斜体和粗体"></a>1.斜体和粗体</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. *斜体*或者_斜体_</span><br><span class="line">2. **粗体**</span><br><span class="line">3. ***加粗斜体***</span><br><span class="line">4. ~~删除线~~</span><br></pre></td></tr></tbody></table></figure><p>显示效果：</p><ol><li><em>斜体</em>或者_斜体_</li><li><strong>粗体</strong></li><li><em><strong>加粗斜体</strong></em></li><li><del>删除线</del></li></ol><h2 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2.分级标题"></a>2.分级标题</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></tbody></table></figure><h2 id="3-超链接"><a href="#3-超链接" class="headerlink" title="3.超链接"></a>3.超链接</h2><ul><li>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</li></ul><h3 id="3-1-行内式"><a href="#3-1-行内式" class="headerlink" title="3.1 行内式"></a>3.1 行内式</h3><ul><li>介绍：[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">1. 欢迎访问[我的博客](www.colorfo.top)</span><br><span class="line">2. 欢迎访问[我的博客](www.colorfo.top "colorfo")</span><br></pre></td></tr></tbody></table></figure><ol><li>欢迎访问<a href="www.colorfo.top">我的博客</a></li><li>欢迎访问<a href="www.colorfo.top" title="colorfo">我的博客</a></li></ol><h3 id="3-2-参考式"><a href="#3-2-参考式" class="headerlink" title="3.2 参考式"></a>3.2 参考式</h3><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p><p>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p><p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]</span><br><span class="line">[Leanote 笔记][2]是一个不错的[网站][]。</span><br><span class="line"></span><br><span class="line">[1]:http://www.google.com "Google"</span><br><span class="line">[2]:http://www.leanote.com "Leanote"</span><br><span class="line">[3]:http://www.colorfo.top "自己的博客"</span><br><span class="line">[网站]:http://http://blog.leanote.com/freewalk</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>显示效果：</p><p>我经常去的几个网站<a href="http://www.google.com/" title="Google">Google</a>、<a href="http://www.leanote.com/" title="Leanote">Leanote</a>以及<a href="http://www.colorfo.top/" title="自己的博客">自己的博客</a><br><a href="http://www.leanote.com/" title="Leanote">Leanote 笔记</a>是一个不错的<a href="http://http//blog.leanote.com/freewalk">网站</a>。</p><ul><li>更多内容请参考—&gt;原文链接：<a href="https://blog.csdn.net/witnessai1/article/details/52551362">https://blog.csdn.net/witnessai1/article/details/52551362</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> front-matter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客的启动和部署</title>
      <link href="/posts/be0d.html"/>
      <url>/posts/be0d.html</url>
      
        <content type="html"><![CDATA[<h1 id="本篇博客主要记录hexo博客的启动和部署"><a href="#本篇博客主要记录hexo博客的启动和部署" class="headerlink" title="本篇博客主要记录hexo博客的启动和部署"></a>本篇博客主要记录hexo博客的启动和部署</h1><h2 id="启动hexo博客"><a href="#启动hexo博客" class="headerlink" title="启动hexo博客"></a>启动hexo博客</h2><ul><li><p>在blog文件夹下，输入cmd,进入Windows的命令提示行窗口</p></li><li><p>输入”hexo server”即可启动 hexo 博客</p></li><li><p>打开浏览器，输入地址：<a href="http://localhost:4000/">http://localhost:4000</a>,即可从本地访问hexo博客</p></li></ul><hr><h2 id="添加部署信息"><a href="#添加部署信息" class="headerlink" title="添加部署信息"></a>添加部署信息</h2><ul><li><p>在_config.yml文件中操作(_config.yml文件的最下面修改)，可以将博客部署到github或者gitee</p></li><li><p>例如我的设置为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https://gitee.com/ColorQian/ColorQian.git</span><br><span class="line">branch: master</span><br></pre></td></tr></tbody></table></figure></li><li><p>修改好配置后，运行如下命令，将代码部署到gitee        </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo generate </span><br><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure></li><li><p>在gitee的Gitee Pages 页面更新部署</p></li><li><p>在浏览器地址栏输入：<a href="http://colorqian.gitee.io/">http://colorqian.gitee.io</a> 即可访问博客</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/posts/3d22.html"/>
      <url>/posts/3d22.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>姓名：钱佳乐<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>来自南京理工大学<br>你可以通过邮箱联系我：<a href="mailto:qjl@njust.edu.cn">qjl@njust.edu.cn</a></p><hr><h2 id="关于这个博客网站"><a href="#关于这个博客网站" class="headerlink" title="关于这个博客网站"></a>关于这个博客网站</h2><p>网站名：”<a href="http://colorqian.gitee.io&quot;/">http://colorqian.gitee.io"</a><br>我将会不定期的在这个网站上发布一些关于java的文章</p><hr><h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><p>程序羊</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
