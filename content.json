{"meta":{"title":"color","subtitle":null,"description":"一个记录学习经历与分享技术的地方!","author":"QianJL","url":"https://www.colorfo.top","root":"/"},"pages":[{"title":"404","date":"2021-06-02T08:41:10.000Z","updated":"2021-06-03T06:11:32.904Z","comments":true,"path":"404.html","permalink":"https://www.colorfo.top/404.html","excerpt":"","text":""},{"title":"分类","date":"2018-09-30T09:25:30.000Z","updated":"2021-08-10T12:19:21.064Z","comments":true,"path":"categories/index.html","permalink":"https://www.colorfo.top/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-06-03T04:25:30.000Z","updated":"2021-08-10T12:18:48.663Z","comments":true,"path":"about/index.html","permalink":"https://www.colorfo.top/about/index.html","excerpt":"","text":"基本信息 😘 昵称 : color 🌇 城市 : 南京 🎓 学历 : 硕士在读 💪 我努力的方向 : java后端 🏀 爱好 : 篮球 | 跑步 | 羽毛球 | 乒乓球等 联系我 QQ : 1255574204 ✉ : qjl@njust.edu.cn"},{"title":"留言板","date":"2021-06-03T05:14:00.000Z","updated":"2021-08-10T12:19:39.398Z","comments":true,"path":"comments/index.html","permalink":"https://www.colorfo.top/comments/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"友链","date":"2021-08-11T04:08:26.000Z","updated":"2021-08-11T04:54:56.517Z","comments":true,"path":"link/index.html","permalink":"https://www.colorfo.top/link/index.html","excerpt":"","text":""},{"title":"友链","date":"2018-12-12T13:25:30.000Z","updated":"2021-08-10T12:20:10.959Z","comments":true,"path":"friends/index.html","permalink":"https://www.colorfo.top/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-09-30T10:23:38.000Z","updated":"2021-08-10T12:20:39.463Z","comments":true,"path":"tags/index.html","permalink":"https://www.colorfo.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"贪心算法刷题笔记②-贪心解决区间问题","slug":"贪心算法刷题笔记②-贪心解决区间问题","date":"2021-09-12T07:44:54.000Z","updated":"2021-09-12T08:12:34.222Z","comments":true,"path":"posts/c9cc.html","link":"","permalink":"https://www.colorfo.top/posts/c9cc.html","excerpt":"","text":"1.用最少数量的箭引爆气球leetcode题目链接 题目 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。 示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 思路分析 局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。 算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？ 如果真实的模拟射气球的过程，应该射一个，气球数组就remove一个元素，这样最直观，毕竟气球被射了。 但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remove气球，只要记录一下箭的数量就可以了。 以上为思考过程，已经确定下来使用贪心了，那么开始解题。 为了让气球尽可能的重叠，需要对数组进行排序。 如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭。 以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序） 可以看出首先第一组重叠气球，一定是需要一个箭，气球3，的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了. 代码详情 12345678910111213141516171819202122232425262728public class BurstBalloons { public int findMinArrowShots(int[][] points) { if (points.length == 0) return 0; int result = 1; Arrays.sort(points, new Comparator&lt;int[]&gt;() { //按照左边界排序,从小到大排序 @Override public int compare(int[] o1, int[] o2) { if (o1[0] &lt; o2[0]) return -1; else if (o1[0] &gt; o2[0]) return 1; else return 0; } }); for (int i = 1; i &lt; points.length; i++) { if (points[i][0] &gt; points[i - 1][1]) { //两个气球如果不挨着 result++; //需要一支箭 } else { //气球i和i-1挨着 points[i][1] = Math.min(points[i-1][1],points[i][1]); // 更新重叠气球最小右边界 // 即：取两者之中较小的右边界作为气球i的右边界 } } return result; }} 2.无重叠区间leetcode题目链接 题目 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了 思路分析 如果遇到重叠的区间，则将result+1，并且缩减当前区间的右边界(相当于把这个区间移除了) 代码详情 123456789101112131415161718192021222324252627public class NonOverlapping { public int eraseOverlapIntervals(int[][] intervals) { if (intervals.length &lt;= 1) return 0; int result = 0; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { //按照区间左边界排序 @Override public int compare(int[] o1, int[] o2) { if (o1[0] &gt; o2[0]) return 1; else if (o1[0] &lt; o2[0]) return -1; else return 0; } }); for (int i = 1; i &lt; intervals.length; i++) { if (intervals[i][0] &lt; intervals[i - 1][1]) { //如果有重叠部分 result++; //相当于删除一个 intervals[i][1] = Math.min(intervals[i - 1][1],intervals[i][1]); } } return result; }} 3.划分字母区间leetcode题目链接 题目 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。 示例： 输入：S = “ababcbacadefegdehijhklij” 输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。 提示： S的长度在[1, 500]之间。 S只包含小写字母 ‘a’ 到 ‘z’ 。 思路分析 在遍历的过程中相当于是要找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。此时前面出现过所有字母，最远也就到这个边界了。 可以分为如下两步： 统计每一个字符最后出现的位置 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点 如图： 代码详情 12345678910111213141516171819202122232425public class PartitionLabels { public List&lt;Integer&gt; partitionLabels(String s) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); int[] edge = new int[26]; int right = 0; int left = 0; for (int i = 0; i &lt; s.length(); i++) { edge[s.charAt(i) - 'a'] = i; //找到字符出现的最远下标 } for (int i = 0; i &lt; s.length(); i++) { right = Math.max(edge[s.charAt(i) - 'a'],right); if (i == right) { //找到字符出现的最远边界,说明到了划分点 int partition = right - left + 1; left = i + 1; result.add(partition); } } return result; }} 4.合并区间leetcode题目链接 题目 给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: intervals = [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: intervals = [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。 提示： intervals[i][0] &lt;= intervals[i][1] 思路分析 按照左边界从小到大排序之后，先将intervals[0]，加入到result集合中。 如果 intervals[i][0] &lt;= result.getLast()[1] 即intervals[i]左边界 &lt; result.getLast()右边界，则一定有重复 知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？ 其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result集合里就可以了。 如果没有重复区间就把原区间加入到result集合。 代码详情 123456789101112131415161718192021222324public class MergeIntervals { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, (o1, o2) -&gt; Integer.compare(o1[0],o2[0]));//按照左边界排序 LinkedList&lt;int[]&gt; result = new LinkedList&lt;&gt;(); result.add(intervals[0]); for (int i = 1; i &lt; intervals.length; i++) { if (intervals[i][0] &lt;= result.getLast()[1]) { //如果有重叠的部分 int start = result.getLast()[0]; int end = Math.max(result.getLast()[1],intervals[i][1]); result.removeLast(); //先把result集合中的取出来 result.add(new int[]{start,end}); //再加入新的数组进到result集合中 } else { result.add(intervals[i]); } } return result.toArray(new int[result.size()][]); }}","categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.colorfo.top/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"贪心算法刷题笔记①","slug":"贪心算法刷题笔记①","date":"2021-09-11T05:16:43.000Z","updated":"2021-09-12T07:48:15.894Z","comments":true,"path":"posts/2a28.html","link":"","permalink":"https://www.colorfo.top/posts/2a28.html","excerpt":"","text":"1.分发饼干leetcode题目链接 题目 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 2: 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. 代码详情 思路：用小饼干先喂小胃口的孩子 12345678910111213141516171819202122232425262728293031import java.util.Arrays;/** * 分发饼干 * https://leetcode-cn.com/problems/assign-cookies/ */public class AssignCookies { /** *小饼干先喂饱小胃口 * @param g 小孩的胃口 * @param s 饼干的尺寸 * @return 饼干能满足小孩的个数 */ public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int index = 0; int result = 0; for (int i = 0; i &lt; s.length; i++) { if (index &lt; g.length &amp;&amp; s[i] &gt;= g[index]){ //如果满足了小孩的胃口 result++; index++; //看下一个小孩的胃口 } } return result; }} 2.摆动序列leetcode题目链接 题目 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例 1: 输入: [1,7,4,9,2,5] 输出: 6 解释: 整个序列均为摆动序列。 示例 2: 输入: [1,17,5,10,13,15,10,5,16,8] 输出: 7 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 思路分析 局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。 整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。 代码详情 12345678910111213141516171819202122public class WiggleSubsequence { public int wiggleMaxLength(int[] nums) { if (nums.length &lt;= 0) return nums.length; int preDiff = 0; int curDiff = 0; int count = 1; for (int i = 0; i &lt; nums.length - 1; i++) { curDiff = nums[i+1] - nums[i]; //如果当前差值和上一个差值为一正一负 //等于0的情况表示初始时的preDiff if ((curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0) || (curDiff &lt; 0 &amp;&amp; preDiff &gt;= 0)){ count++; preDiff = curDiff; } } return count; }} 3.最大子序列和LeetCode题目链接 题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 思路分析 贪心贪的是哪里呢？ 如果 -2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！ 局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。 全局最优：选取最大“连续和” 局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。 从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。 这相当于是暴力解法中的不断调整最大子序和区间的起始位置。 那有同学问了，区间终止位置不用调整么？ 如何才能得到最大“连续和”呢？ 区间的终止位置，其实就是如果count取到最大值了，及时记录下来了。例如如下代码： 1if (count &gt; result) result = count; 这样相当于是用result记录最大子序和区间和（变相的算是调整了终止位置）。 如动画所示: 红色的起始位置就是贪心每次取count为正数的时候，开始一个区间的统计。 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MaxSubarray { /**方法一： * 暴力解法，时间复杂度O(n^2) * @param nums * @return */ public int maxSubArray1(int[] nums) { int result = Integer.MIN_VALUE; int count = 0; for (int i = 0; i &lt; nums.length; i++) { count = 0; for (int j = i; j &lt; nums.length; j++) { count += nums[j]; result = count &gt; result ? count : result; } } return result; } /**方法二： * 贪心算法 * @param nums * @return */ public int maxSubArray(int[] nums){ int result = Integer.MIN_VALUE; int count = 0; for (int i = 0; i &lt; nums.length; i++) { count += nums[i]; // 取区间累计的最大值（相当于不断确定最大子序终止位置） if (count &gt; result) result = count; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和 if (count &lt;= 0) count = 0; } return result; }} 4.买卖股票的最佳时机IIleetcode题目链接 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路分析 计算相邻两天的价格差，若为正，则说明有利润可图，则加入到总利润中 代码详情 1234567891011121314public class SellStock { public int maxProfit(int[] prices) { int result = 0; //遍历数组求两天的价格差，只要是正(说明有利润)，就累加 for (int i = 0; i &lt; prices.length - 1; i++) { int temp = prices[i+1] - prices[i]; if (temp &gt; 0){ result += temp; } } return result; }} 5.跳跃游戏leetcode题目链接 题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 思路分析 刚看到本题一开始可能想：当前位置元素如果是3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？ 其实跳几步无所谓，关键在于可跳的覆盖范围！ 不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。 这个范围内，别管是怎么跳的，反正一定可以跳过来。 那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！ 每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。 贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。 局部最优推出全局最优，找不出反例，试试贪心！ 如图： i每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让i继续移动下去。 而cover每次只取 max(该元素数值补充后的范围, cover本身范围)。 如果cover大于等于了终点下标，直接return true就可以了。 代码详情 1234567891011121314public class JumpGame { public boolean canJump(int[] nums) { int cover = 0; if (nums.length == 1) return true; for (int i = 0; i &lt;= cover; i++){ // 注意这里是小于等于cover cover = Math.max(i + nums[i],cover); if (cover &gt;= nums.length - 1) return true; // 说明可以覆盖到终点了 } return false; }} 6.跳跃游戏IIleetcode题目链接 题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。 思路分析 移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。 想要达到这样的效果，只要让移动下标，最大只能移动到nums.size - 2的地方就可以了。 因为当移动下标指向nums.size - 2时： 1.如果移动下标等于当前覆盖最大距离下标， 需要再走一步（即ans++），因为最后一步一定是可以到的终点。（题目假设总是可以到达数组的最后一个位置），如图： 2.如果移动下标不等于当前覆盖最大距离下标，说明当前覆盖最远距离就可以直接达到终点了，不需要再走一步。如图： 代码详情 123456789101112131415161718192021public class JumpGame2 { public int jump(int[] nums) { if (nums.length == 1) { return 0; } int curDistance = 0; // 当前覆盖的最远距离下标 int ans = 0; // 记录走的最大步数 int nextDistance = 0; // 下一步覆盖的最远距离下标 for (int i = 0; i &lt; nums.length - 1; i++) { // 注意这里是小于nums.size() - 1，这是关键所在 nextDistance = Math.max(nums[i] + i, nextDistance); // 更新下一步覆盖的最远距离下标 if (i == curDistance) { // 遇到当前覆盖的最远距离下标 curDistance = nextDistance; // 更新当前覆盖的最远距离下标 ans++; } } return ans; } } 7.加油站leetcode题目链接 题目 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1: 输入: gas = [1,2,3,4,5] cost = [3,4,5,1,2] 输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 思路分析 首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。 每个加油站的剩余量rest[i]为gas[i] - cost[i]。 i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。 如图： 那么为什么一旦[i，j] 区间和为负数，起始位置就可以是j+1呢，j+1后面就不会出现更大的负数？ 如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了。 而且j之前出现了多少负数，j后面就会出现多少正数，因为耗油总和是大于零的（前提我们已经确定了一定可以跑完全程）。 那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置。 代码详情 12345678910111213141516171819public class GasStation { public int canCompleteCircuit(int[] gas, int[] cost) { int curSum = 0; int totalRest = 0; int start = 0; for (int i = 0; i &lt; gas.length; i++) { curSum += (gas[i] - cost[i]); totalRest += (gas[i] - cost[i]); if (curSum &lt; 0) { // 当前累加gas[i] - cost[i]的和 curSum一旦小于0 start = i + 1; // 起始位置更新为i+1 curSum = 0; // curSum从0开始 } } if (totalRest &lt; 0) return -1; // 说明怎么走都不可能跑一圈了 return start; }} 8.单调递增的数字leetcode题目链接 题目 给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。 （当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。） 示例 1: 输入: N = 10 输出: 9 示例 2: 输入: N = 1234 输出: 1234 示例 3: 输入: N = 332 输出: 299 思路分析 题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。 例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]--，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。 这一点如果想清楚了，这道题就好办了。 局部最优：遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]–，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数。 全局最优：得到小于等于N的最大单调递增的整数。 但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9。 此时是从前向后遍历还是从后向前遍历呢？ 从前向后遍历的话，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。 这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。 所以从前后向遍历会改变已经遍历过的结果！ 那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299 确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。 代码详情 1234567891011121314151617181920212223242526272829303132public class MonotoneIncreasingDigits { public int monotoneIncreasingDigits(int n) { String str = String.valueOf(n); //将n转为String串 char[] s = str.toCharArray(); // flag用来标记赋值9从哪里开始 // 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行 int flag = str.length(); for (int i = s.length - 1; i &gt; 0; i--) { if (s[i - 1] &gt; s[i]) { flag = i; s[i - 1] = (char) (s[i - 1] - 1); //s[i - 1] -&gt; int (转为int类型) } } for (; flag &lt; s.length; flag++) { //将下标flag及其后面的数，全部置为'9' s[flag] = '9'; } String result = String.valueOf(s); return Integer.parseInt(result); } //---------------- public static void main(String[] args) { MonotoneIncreasingDigits num = new MonotoneIncreasingDigits(); int i = num.monotoneIncreasingDigits(318); //322 System.out.println(i); }} 本篇博文参考：代码随想录","categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.colorfo.top/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"回溯算法刷题笔记②","slug":"回溯算法刷题笔记②","date":"2021-09-06T09:04:44.000Z","updated":"2021-09-06T11:52:09.036Z","comments":true,"path":"posts/e46.html","link":"","permalink":"https://www.colorfo.top/posts/e46.html","excerpt":"","text":"1.分割回文串力扣题目链接 题目 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例: 输入: \"aab\" 输出: [ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ] 思路分析 先分析一下切割，其实切割问题类似组合问题。 例如对于字符串abcdef： 组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。 切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。 所以切割问题，也可以抽象为一颗树形结构，如图： 递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.LinkedList;import java.util.List;/** * 题目链接：https://leetcode-cn.com/problems/palindrome-partitioning/ * * 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 * 返回 s 所有可能的分割方案。 * * 示例: 输入: \"aab\" 输出: [ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ] */public class DivisionPalindrome { List&lt;List&lt;String&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;String&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) { if (s == null || s.length() == 0) { return result; } backtracking(s,0); return result; } private void backtracking(String s, int startIndex) { if (startIndex &gt;= s.length()) { result.add(new LinkedList&lt;&gt;(path)); return; } for (int i = startIndex; i &lt; s.length(); i++) { if (isPalindrome(s,startIndex,i)){ //如果s的[startIndex,i]之间是回文串，则加入到path中 String str = s.substring(startIndex,i+1); path.add(str); backtracking(s,i+1); //递归 path.removeLast(); //回溯 }else { //如果不是回文串，进行下一次判断 continue; } } } private boolean isPalindrome(String s, int startIndex, int endIndex) { for (int i = startIndex,j = endIndex; i &lt; j; i++,j--) { if (s.charAt(i) != s.charAt(j)) return false; } return true; } //-------------- public static void main(String[] args) { String str = \"aab\".substring(0,1); //substring(begin,end),[begin,end),左闭右开 System.out.println(str); System.out.println(\"aab\".substring(1)); DivisionPalindrome palindrome = new DivisionPalindrome(); List&lt;List&lt;String&gt;&gt; s = palindrome.partition(\"aab\"); for (List&lt;String&gt; strings : s) { System.out.println(strings); } }} 2.复原IP地址力扣题目链接 题目 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。 例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1“ 是 无效的 IP 地址。 示例 1： 输入：s = “25525511135” 输出：[“255.255.11.135”,”255.255.111.35”] 示例 2： 输入：s = “0000” 输出：[“0.0.0.0”] 示例 3： 输入：s = “1111” 输出：[“1.1.1.1”] 示例 4： 输入：s = “010010” 输出：[“0.10.0.10”,”0.100.1.0”] 示例 5： 输入：s = “101023” 输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”] 提示： 0 &lt;= s.length &lt;= 3000 s 仅由数字组成 思路分析 只要意识到这是切割问题，切割问题就可以使用回溯搜索法把所有可能性搜出来，和刚做过的1.分割回文串就十分类似了。 切割问题可以抽象为树型结构，如图： 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.LinkedList;import java.util.List;/** * 题目地址：https://leetcode-cn.com/problems/restore-ip-addresses/ * * 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 * 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。 * * 例如：\"0.1.2.201\" 和 \"192.168.1.1\" 是 有效的 IP 地址， * 但是 \"0.011.255.245\"、\"192.168.1.312\" 和 \"192.168@1.1\" 是 无效的 IP 地址。 * * 示例 5： 输入：s = \"101023\" 输出：[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"] */public class RestoreIP { List&lt;String&gt; result = new LinkedList&lt;&gt;(); public List&lt;String&gt; restoreIpAddresses(String s) { if (s == null || s.length() == 0 || s.length() &gt; 12) return result; backtracking(s,0,0); return result; } private void backtracking(String s, int startIndex, int pointNum) { if (pointNum == 3){ // 逗点数量为3时，分隔结束 // 判断第四段⼦字符串是否合法，如果合法就放进result中 if (isValid(s,startIndex,s.length()-1)){ result.add(s); } return; } for (int i = startIndex; i &lt; s.length(); i++) { //如果s的[startIndex,i]是合法的整数子串 if (isValid(s,startIndex,i)){ s = s.substring(0,i+1) + \".\" + s.substring(i+1); pointNum++; backtracking(s,i+2,pointNum); //递归 s = s.substring(0,i+1) + s.substring(i+2); pointNum--; }else { break; } } } private boolean isValid(String s, int start, int end) { if (start &gt; end) return false; //如果以0开头，不合法 if (s.charAt(start) == '0' &amp;&amp; start != end) return false; int num = 0; for (int i = start;i &lt;= end;i++){ //判断每一个数字是否合法 if (s.charAt(i) &gt; '9' || s.charAt(i) &lt; '0') return false; //如果[start,end]范围内的整数大于255，不合法 num = num * 10 + (s.charAt(i) - '0'); if (num &gt; 255) return false; } return true; } //------------------ public static void main(String[] args) { RestoreIP ip = new RestoreIP(); List&lt;String&gt; strings = ip.restoreIpAddresses(\"101023\"); for (String s : strings){ System.out.println(s); } }} 3.子集问题力扣题目链接 题目 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 思路分析 如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！ 以示例中nums = [1,2,3]为例把求子集抽象为树型结构，如下： 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.LinkedList;import java.util.List;/** * 题目地址：https://leetcode-cn.com/problems/subsets/ * * 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 * 说明：解集不能包含重复的子集。 * * 示例: 输入: nums = [1,2,3] 输出: [ [3], [1],[2],[1,2,3],[1,3],[2,3],[1,2],[]] * */public class Subsets { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { if (nums.length == 0) return result; backtracking(nums,0); return result; } private void backtracking(int[] nums, int startIndex) { result.add(new LinkedList&lt;&gt;(path)); // 收集子集，要放在终止添加的上面，否则会漏掉自己 if (startIndex &gt;= nums.length) return; for (int i = startIndex; i &lt; nums.length; i++) { path.add(nums[i]); backtracking(nums,i+1); path.removeLast(); } }} 4.子集II力扣题目链接 题目 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 思路分析 此题和3.子集问题很类似，唯一的区别就是，本题需要进行去重操作，因为题目中要求了解集不能包含重复的子集。 而nums数组中可能包含重复元素 去重关键代码： 123if (i &gt; startIndex &amp;&amp; nums[i] == nums[i-1]){ //去重操作(结果节不能有重复元素，要去重) continue;} 代码详情 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Arrays;import java.util.LinkedList;import java.util.List;/** * 题目链接：https://leetcode-cn.com/problems/subsets-ii/ * * 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 * 说明：解集不能包含重复的子集。 * * 示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] * */public class SubsetsNoRepeat { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { Arrays.sort(nums); //先给nums数组排序 backtracking(nums,0); return result; } private void backtracking(int[] nums, int startIndex) { result.add(new LinkedList&lt;&gt;(path)); // 收集子集，要放在终止条件的上面，否则会漏掉自己 if (startIndex &gt;= nums.length) return; //终止条件 for (int i = startIndex; i &lt; nums.length; i++) { if (i &gt; startIndex &amp;&amp; nums[i] == nums[i-1]){ //去重操作(结果节不能有重复元素，要去重) continue; } path.add(nums[i]); backtracking(nums,i+1); //递归 path.removeLast(); //回溯 } }} 5.递增子序列 代码详情 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.LinkedList;import java.util.List;/** * 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。 * 你可以按 任意顺序 返回答案。 * 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。 * * 输入: [4, 6, 7, 7] 输出: * [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] * * 链接：https://leetcode-cn.com/problems/increasing-subsequences */public class IncreasingSubsequences { /** * 备注： * 这种写法，输入[4,6,7,7],可以得到想要的输出， * 但是不能被LeetCode AC,原因不明 */ List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) { backtracking(nums,0); return result; } private void backtracking(int[] nums, int startIndex) { if (path.size() &gt;= 2) result.add(new LinkedList&lt;&gt;(path)); if (startIndex &gt;= nums.length) return; for (int i = startIndex; i &lt; nums.length; i++) { if (i &gt; startIndex &amp;&amp; nums[i] == nums[i-1]) continue; //去重 if (i == 0 || nums[i] &gt;= nums[i-1]){ path.add(nums[i]); backtracking(nums,i+1); path.removeLast(); }else { //break; continue; } } } //---------------- public static void main(String[] args) { IncreasingSubsequences subsequences = new IncreasingSubsequences(); int[] nums = {4,6,7,7}; List&lt;List&lt;Integer&gt;&gt; subsequences1 = subsequences.findSubsequences(nums); for (List&lt;Integer&gt; list : subsequences1) { System.out.println(list); } }} 6.全排列力扣题目链接 题目 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: nums = [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 思路分析 每一次递归都遍历nums数组，然后将nums[i]加入到List&lt;Integer&gt; path中，继续递归，回溯。 如果path已经包含了nums[i],就跳过本次循环，进行下一次循环。 如果path.size() == nums.length，就return. 代码详情 1234567891011121314151617181920212223242526272829303132333435363738/** * 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 * 示例: 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] * * https://leetcode-cn.com/problems/permutations/ */public class Permutations { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { backtracking(nums); return result; } private void backtracking(int[] nums) { if (nums.length == path.size()){ result.add(new LinkedList&lt;&gt;(path)); return; } for (int i = 0; i &lt; nums.length; i++) { //通过判断path中是否存在数字，排除已经选择的数字 if (path.contains(nums[i])){ continue; } path.add(nums[i]); backtracking(nums); path.removeLast(); } }} 7.全排列 II力扣题目链接 题目 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例 1： 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] 示例 2： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 思路分析 要强调的是去重一定要对元素经行排序，这样我们才方便通过相邻的节点来判断是否重复使用了。 以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图： 图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。 一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果。 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Arrays;import java.util.LinkedList;import java.util.List;/** * * 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 * * 示例 1： 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] * 示例 2： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] * * https://leetcode-cn.com/problems/permutations-ii/ */public class PermutationNoRepeat { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); List&lt;Integer&gt; path = new LinkedList&lt;&gt;(); boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { used = new boolean[nums.length]; Arrays.sort(nums); backtracking(nums); return result; } private void backtracking(int[] nums) { if (path.size() == nums.length) { result.add(new LinkedList(path)); return; } for (int i = 0; i &lt; nums.length; i++) { // used[i - 1] == false，说明同一树层nums[i - 1]使用过 // 如果同一树层nums[i - 1]使用过则直接跳过 if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1] == false){ continue; } if (used[i] == false){ path.add(nums[i]); used[i] = true; backtracking(nums); path.remove(path.size() - 1); used[i] = false; } } }}","categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"回溯刷题笔记①","slug":"回溯刷题笔记①","date":"2021-09-03T05:18:35.000Z","updated":"2021-09-03T06:59:17.747Z","comments":true,"path":"posts/cac8.html","link":"","permalink":"https://www.colorfo.top/posts/cac8.html","excerpt":"","text":"回溯算法简介回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯算法模板123456789101112void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 }} 1.组合问题leetcode题目链接 题目 给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例:输入: n = 4, k = 2输出:[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],] 思路分析 把组合问题抽象为如下树形结构： 代码详情 1234567891011121314151617181920212223242526272829import java.util.LinkedList;import java.util.List;/** * 组合问题，返回[1,n]，中所有的k个数的组合 */public class Combine { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { combineHelper(n, k, 1); return result; } private void combineHelper(int n, int k, int startIndex){ //终止条件 if (path.size() == k){ result.add(new LinkedList(path)); return; } for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++){ //剪枝优化 path.add(i); combineHelper(n, k, i + 1); path.removeLast(); //回溯 } }} 2.组合总和IIIleetcode题目链接 题目 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]] 示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 思路分析 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.LinkedList;import java.util.List;/** * 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数， * 并且每种组合中不存在重复的数字。 * * 示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]] * 示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] */public class CombinationSum { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); int sum; public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) { combination(k,n,1); return result; } private void combination(int k, int targetSum, int startIndex) { if (path.size() == k){ if (targetSum == sum){ result.add(new LinkedList&lt;&gt;(path)); } return; //如果path.size() == k 但sum != targetSum 直接返回 } if (sum &gt; targetSum) return; for (int i = startIndex; i &lt;= 9-(k-path.size())+1; i++) { path.add(i); sum += i; combination(k,targetSum,i+1); // 注意i+1调整startIndex path.removeLast(); //回溯 sum -= i; } }} 3.电话号码的字母组合leetcode题目链接 题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：”23” 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序 思路分析 首先定义一个String[]数组，用来做数字和字母的映射 String[] numString = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}; 然后从这个数组中取字符串进行组合即可 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.LinkedList;import java.util.List;/**给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 * * https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/ */public class CombinationOfPhoneNumber { List&lt;String&gt; result = new LinkedList&lt;&gt;(); //用来储存最终的结果 StringBuilder str = new StringBuilder(); //用来储存最终结果的每一个字符串 public List&lt;String&gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0){ return result; } //构造一个String[],下标对应字符串 String[] numString = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}; backtracking(digits,numString,0);//回溯的方法 return result; } private void backtracking(String digits, String[] numString, int num) { if (num == digits.length()){ result.add(str.toString()); return; } //获取digits数字串的第num个数字 int index = digits.charAt(num) - '0'; //数字index对应的字符串 String string = numString[index]; for (int i = 0; i &lt; string.length(); i++) { str.append(string.charAt(i));//处理 backtracking(digits,numString,num + 1); //递归，注意num + 1 str.deleteCharAt(num); //回溯 } }} 4.组合总和leetcode题目链接 题目 1234567891011给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ] 思路分析 本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。 本题搜索的过程抽象成树形结构如下： 注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！ 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.LinkedList;import java.util.List;/** *给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 * candidates 中的数字可以无限制重复被选取。 * *示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [[2,2,2,2],[2,3,3],[3,5]] * * 链接：https://leetcode-cn.com/problems/combination-sum */public class CombinationRepeatedSum { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); int sum; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { if (candidates.length == 0) return result; backtracking(candidates,target,0); return result; } private void backtracking(int[] candidates, int target,int startIndex) { if (sum == target){ result.add(new LinkedList&lt;&gt;(path)); return; }else if (sum &gt; target) return; for (int i = startIndex; i &lt; candidates.length; i++) { if (sum + candidates[i] &gt; target) continue; //剪枝优化 path.add(candidates[i]); sum += candidates[i]; backtracking(candidates,target,i); //回溯 path.removeLast(); sum -= candidates[i]; } } //================= public static void main(String[] args) { CombinationRepeatedSum combination = new CombinationRepeatedSum(); int[] cadidates = {2,3,5}; combination.combinationSum(cadidates,8); }} 5.组合总和IIleetcode题目链接 题目 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] 思路分析 本题的难点在于：集合（数组candidates）有重复元素，但还不能有重复的组合。 所以就要就行去重操作(首先对数组candidates进行排序，才能有效去重) 去重代码: 1234// 要对同一树层使用过的元素进行跳过,是一个去重操作if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-1]){ continue;} 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Arrays;import java.util.LinkedList;import java.util.List;/** * 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 * candidates 中的每个数字在每个组合中只能使用一次。 * * 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: * [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] * * 链接：https://leetcode-cn.com/problems/combination-sum-ii */public class CombinationNoRepeatSum { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); int sum; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); backtracking(candidates,target,0); return result; } private void backtracking(int[] candidates, int target, int startIndex) { if (sum == target){ result.add(new LinkedList&lt;&gt;(path)); return; }else if (sum &gt; target) return; for (int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) {//sum + candidates[i] &lt;= target为剪枝操作 // 要对同一树层使用过的元素进行跳过,是一个去重操作 if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-1]){ continue; } path.add(candidates[i]); sum += candidates[i]; backtracking(candidates,target,i + 1); path.removeLast(); sum -= candidates[i]; } } //------------------------ public static void main(String[] args) { CombinationNoRepeatSum combination = new CombinationNoRepeatSum(); int[] cadidates = {2,5,2,1,2}; combination.combinationSum2(cadidates,5); }}","categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"二叉搜索树刷题笔记","slug":"二叉搜索树刷题笔记","date":"2021-08-26T11:08:13.000Z","updated":"2021-08-26T14:34:15.601Z","comments":true,"path":"posts/9a06.html","link":"","permalink":"https://www.colorfo.top/posts/9a06.html","excerpt":"","text":"一、求二叉搜索树的属性1.二叉搜索树的搜索leetcode题目链接 题目 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 示例： 思路分析 利用二叉搜索树的性质，如果val &lt; root.val 就向左遍历，root = root.left, 如果val &gt; root.val 就向右遍历，root = root.right,如果val == root.val就返回root节点 代码详情 12345678910111213141516171819202122232425262728293031/** * 方法一：迭代，利用二叉搜索树的特性 */public TreeNode searchBST3(TreeNode root,int val){ if (root == null) return root; while (root != null){ if (val &lt; root.val) root = root.left; else if (val &gt; root.val) root = root.right; else return root; } return null;} /** * 方法二：递归 * @param root * @param val * @return */public TreeNode searchBST2(TreeNode root,int val){ if (root == null || root.val == val) return root; if (val &lt; root.val) return searchBST2(root.left,val); if (val &gt; root.val) return searchBST2(root.right,val); return null;} 2.验证二叉搜索树leetcode题目链接 题目 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 思路分析 利用中序遍历，遍历二叉搜索树，可以得到一个序列，如果这个序列是严格递增的， 则该二叉树是二叉搜索树。 代码详情 提供两个方法： 方法一：利用中序遍历将二叉搜索树变为一个序列，判断这个序列 是否是升序的 &lt;=&gt; 是否是二叉搜索树 方法二：利用双指针判断中序遍历时二叉搜索树 是否是严格递增的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.ArrayList;import java.util.List;public class ValidateBST { /** * 方法一：利用中序遍历将二叉搜索树变为一个序列，判断这个序列 是否是升序的 &lt;=&gt; 是否是二叉搜索树 * @param root * @return */ public boolean isValidBST(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); //中序遍历得到一个序列 infixOrder(root,result); //正常的BST按照中序遍历可以得到一个升序序列，所以可以以此来判断是不是一个BST int size = result.size(); for (int i = 1; i &lt; size; i++) { if (result.get(i) &lt;= result.get(i-1)) return false; } return true; } //中序遍历 private void infixOrder(TreeNode root, List&lt;Integer&gt; result) { if (root == null) return; infixOrder(root.left,result); result.add(root.val); infixOrder(root.right,result); } //---------------------- /**方法二： *利用双指针判断中序遍历时二叉搜索树 是否是严格递增的 */ TreeNode pre; boolean flag; public boolean isValidBST2(TreeNode root){ if (root == null) return false; flag = true; infixOrder2(root); return flag; } private void infixOrder2(TreeNode root) { if (root == null) return; infixOrder2(root.left); //左 if (pre != null) { //中 if (root.val &lt;= pre.val){ flag = false; return; } } pre = root; infixOrder2(root.right); //右 }} 3.二叉搜索树的最小绝对差leetcode题目链接 题目 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 示例： 提示：树中至少有两个节点 思路分析 方法一：转为有序数组 题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。 注意是二叉搜索树，二叉搜索树可是有序的。 遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了 方法二：双指针法 需要用一个pre节点记录一下cur节点的前一个节点。 代码详情 方法一：把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。 方法二：在中序遍历的过程中，利用双指针，即pre指向cur的前一个，然后做差比较，取最小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.ArrayList;import java.util.List;public class MinusTwo { /**方法一： * 把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。 * * @param root * @return */ public int getMinimumDifference(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); infixOrder(root,result); int size = result.size(); int min = Integer.MAX_VALUE; int temp; for (int i = 1; i &lt; size; i++) { temp = result.get(i) - result.get(i-1); min = min &lt; temp ? min : temp; } return min; } private void infixOrder(TreeNode root, List&lt;Integer&gt; result) { if (root == null) { return; } infixOrder(root.left,result); result.add(root.val); infixOrder(root.right,result); } /** * 方法二：在中序遍历的过程中，利用双指针，即pre指向cur的前一个，然后做差比较，取最小 */ TreeNode pre; int result = Integer.MAX_VALUE; public int getMinimumDifference2(TreeNode root){ traversal(root); return result; } private void traversal(TreeNode cur) { if (cur == null) return; traversal(cur.left);//左 if (pre != null){ //中 result = Math.min(result,cur.val - pre.val); } pre = cur; // 记录前一个 traversal(cur.right); //右 }} 4.二叉搜索树中的众数leetcode题目链接 题目 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 示例：给定 BST [1,null,2,2], 返回[2]. 提示：如果众数超过1个，不需考虑输出顺序 思路分析 在二叉树：搜索树的最小绝对差 中我们就使用了pre指针和cur指针的技巧，这次又用上了。 弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。 而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。 代码如下： 12345678if (pre == NULL) { // 第一个节点 count = 1; // 频率为1} else if (pre-&gt;val == cur-&gt;val) { // 与前一个节点数值相同 count++;} else { // 与前一个节点数值不同 count = 1;}pre = cur; // 更新上一个节点 那么如何只遍历一遍就取出所有的众数呢？ 如果 频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中（以下代码为result数组），代码如下： 123if (count == maxCount) { // 如果和最大值相同，放进result中 result.push_back(cur-&gt;val);} 是不是感觉这里有问题，result怎么能轻易就把元素放进去了呢，万一，这个maxCount此时还不是真正最大频率呢。 所以下面要做如下操作： 频率count 大于 maxCount的时候，不仅要更新maxCount，而且要清空结果集（以下代码为result数组），因为结果集之前的元素都失效了。 12345if (count &gt; maxCount) { // 如果计数大于最大值 maxCount = count; // 更新最大频率 result.clear(); // 很关键的一步，不要忘记清空result，之前result里的元素都失效了 result.push_back(cur-&gt;val);} 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.ArrayList;import java.util.List;/** * 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 */public class FindModeInBST { List&lt;Integer&gt; resCount; int count; //用来计数 int maxCount; //出现的最大次数 TreeNode pre; //cur的前一个指针 public int[] findMode(TreeNode root){ resCount = new ArrayList&lt;&gt;(); infix(root); int[] res = new int[resCount.size()]; for (int i = 0; i &lt; resCount.size(); i++) { res[i] = resCount.get(i); } return res; } //中序遍历 private void infix(TreeNode cur) { if (cur == null) return; infix(cur.left); //左 if (pre == null){ //第一个节点 count = 1; }else if (pre.val != cur.val){ //与前一个节点数值不同 count = 1; }else{ //与前一个节点数值相同 count++; } if (count == maxCount){ //如果和出现最多的频率相同 resCount.add(cur.val); } if (count &gt; maxCount){ resCount.clear(); //将resCount清空 maxCount = count; //更新maxCount resCount.add(cur.val); //将节点的值加进去 } pre = cur; //更新上一个指针 infix(cur.right); // 右 }} 5.把二叉搜索树转换为累加树leetcode题目链接 题目 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 思路分析 其实这就是一棵树，大家可能看起来有点别扭，换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]，是不是感觉这就简单了。 为什么变成数组就是感觉简单了呢？ 因为数组大家都知道怎么遍历啊，从后向前，挨个累加就完事了，这换成了二叉搜索树，看起来就别扭了一些是不是。 那么知道如何遍历这个二叉树，也就迎刃而解了，从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历（按照右 中 左） 这个二叉树，然后顺序累加就可以了。 代码详情 依然使用双指针， 利用cur.val += pre.val,来更新当前节点的值 123456789101112131415161718192021222324252627282930313233343536/** * 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree）， * 使每个节点 node的新值等于原树中大于或等于node.val的值之和。 * * 链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree * */public class BSTToGreaterSumTree { TreeNode pre; public TreeNode convertBST(TreeNode root) { if (root == null) return null; Uninfix(root); return root; } //按照右 中 左 的顺序 遍历 累加 ，然后得到一个累加树 private void Uninfix(TreeNode cur) { if (cur == null) { return; } //右 Uninfix(cur.right); //中 if (pre != null) cur.val += pre.val; pre = cur; //左 Uninfix(cur.left); }} 二、树的公共祖先问题1.二叉树的最近公共祖先leetcode题目链接 题目 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 示例： 思路分析 二叉树的最近公共祖先 代码详情 12345678910111213141516171819/**找二叉树的公共祖先，这题不太好理解，最好是背一下 * * 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 */public class ClosestAncestor { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == p || root == q || root == null) return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if (left != null &amp;&amp; right != null) return root; if (left == null &amp;&amp; right == null) return null; return left != null ? left : right; }} 2.二叉搜索树的最近公共祖先leetcode题目链接 题目 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 示例： 思路分析 本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。 在有序树里，如果判断一个节点的左子树里有p，右子树里有q呢？ 其实只要从上到下遍历的时候，cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了。 理解这一点，本题就很好解了。 和二叉树：公共祖先问题不同，普通二叉树求最近公共祖先需要使用回溯，从底向上来查找，二叉搜索树就不用了，因为搜索树有序（相当于自带方向），那么只要从上向下遍历就可以了。 那么我们可以采用前序遍历（其实这里没有中节点的处理逻辑，遍历顺序无所谓了）。 如图所示：p为节点3，q为节点5 可以看出直接按照指定的方向，就可以找到节点4，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！ 代码详情 1234567891011121314151617181920212223242526272829303132333435363738/** * 二叉搜索树的公共祖先 */public class ClosestAncestorBST { //方法一，递归 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q){ if (root == null) return null; //root.val的值不在[p,q](假设p.val &lt; q.val),则递归查找 if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) { return lowestCommonAncestor(root.right,p,q); }else if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) { return lowestCommonAncestor(root.left,p,q); }else { //root.val的值在区间内，直接返回 return root; } } //方法二：迭代法 public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) { if (root == null) return null; while (root != null){ if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) root = root.left; else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) root = root.right; else return root; } return null; }} 三、二叉搜索树的修改与构造1.二叉搜索树中的插入操作leetcode题目链接 题目 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。 提示： 给定的树上的节点数介于 0 和 10^4 之间 每个节点都有一个唯一整数值，取值范围从 0 到 10^8 -10^8 &lt;= val &lt;= 10^8 新值和原始二叉搜索树中的任意节点值都不同 思路分析 利用二叉搜索树的性质，遍历，然后找到空节点插入即可，插入时注意插入的位置(左边还是右边) 代码详情 提供两种方法，详情看代码以及注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 * 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/insert-into-a-binary-search-tree */public class InsertIntoBST { /**方法一：迭代 * 利用两个指针，当cur指针为空时，说明找到合适的位置， * 如果是val &lt; cur.val 的条件使得cur 指向 cur.left，后为空，则让pre.left = new TreeNode(val); * 如果是val &gt; cur.val 的条件使得cur 指向 cur.right，后为空，则让pre.right = new TreeNode(val); * * @param root * @param val * @return */ public TreeNode insertIntoBST2(TreeNode root, int val) { if (root == null) return new TreeNode(val); TreeNode pre = null; TreeNode cur = root; while (true) { pre = cur; if (val &lt; cur.val) { cur = cur.left; if (cur == null) { pre.left = new TreeNode(val); break; } } else if (val &gt; cur.val) { cur = cur.right; if (cur == null) { pre.right = new TreeNode(val); break; } } } return root; } /** * 方法二：递归 * @param root * @param val * @return */ public TreeNode insertIntoBST(TreeNode root,int val){ if (root == null) { return new TreeNode(val); } if (root.val &lt; val) root.right = insertIntoBST(root.right,val); else if (root.val &gt; val) root.left = insertIntoBST(root.left,val); return root; }} 2.删除二叉搜索树中的节点leetcode题目链接 题目 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 O(h)，h 为树的高度。 示例: 思路分析 删除二叉搜索树中的节点 代码详情 1234567891011121314151617181920212223242526272829303132333435363738public class DeleteNodeInBST { public TreeNode deleteNode(TreeNode root, int val) { if (root == null) return null; //没找到要删除的节点，直接返回null if (root.val == val){ //第一种情况，root节点的左右孩子都为空，说明要删除的是叶子节点，直接返回null if (root.left == null &amp;&amp; root.right == null) { return null; //第二种情况，左孩子为空，返回右孩子 } else if (root.left == null) { return root.right; //第三种情况，右孩子为空，返回左孩子 }else if (root.right == null){ return root.left; //第四种情况，左右孩子都不为空，把，左孩子添加到以右孩子为头节点的树的最左边 }else { TreeNode cur = root.right; while (cur.left != null){ //一直往左遍历，找到root节点的右孩子的最左边 cur = cur.left; } cur.left = root.left; return root.right; } } //这里相当于把新的节点返回给上一层，上一层就要用 root-&gt;left 或者 root-&gt;right接住 if (val &lt; root.val) root.left = deleteNode(root.left,val); if (val &gt; root.val) root.right = deleteNode(root.right,val); return root; }} 3.修剪二叉搜索树leetcode题目链接 题目 给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。 思路分析 修剪二叉搜索树 代码详情 123456789101112131415161718192021222324252627282930313233/**这题不太好理解，最好是背住代码！！！ * * 题目： * 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树， * 使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构 * （即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。 * 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 * * 链接：https://leetcode-cn.com/problems/trim-a-binary-search-tree */public class TrimBST { public TreeNode trimBST(TreeNode root,int low,int high){ if (root == null) { return null; } if (root.val &lt; low){ // 寻找符合区间[low, high]的节点 return trimBST(root.right,low,high); } if (root.val &gt; high){ // 寻找符合区间[low, high]的节点 return trimBST(root.left,low,high); } //代码走到这里，说明root.val的值，在[low,high]区间内 root.left = trimBST(root.left,low,high); // root-&gt;left接入符合条件的左孩子 root.right = trimBST(root.right,low,high); // root-&gt;right接入符合条件的右孩子 return root; }} 总结在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl给大家大体分分类。 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。 注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序， 二叉树：找所有路径也用了前序，这是为了方便让父节点指向子节点。 所以求普通二叉树的属性还是要具体问题具体分析。 参考：以上题目解答来自：代码随想录，感谢carl哥！！！","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"BST","slug":"BST","permalink":"https://www.colorfo.top/tags/BST/"}]},{"title":"二叉树刷题笔记②","slug":"二叉树刷题笔记②","date":"2021-08-24T05:40:11.000Z","updated":"2021-08-26T14:24:13.351Z","comments":true,"path":"posts/abcb.html","link":"","permalink":"https://www.colorfo.top/posts/abcb.html","excerpt":"","text":"1.左叶子之和leetcode题目链接 题目 计算给定二叉树的所有左叶子之和。 思路分析 首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。 因为题目中其实没有说清楚左叶子究竟是什么节点，那么我来给出左叶子的明确定义：如果左节点不为空，且左节点没有左右孩子，那么这个节点就是左叶子 如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下： 123if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null){ //处理逻辑} 代码实现 分别使用递归法和迭代法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 计算给定二叉树的所有左叶子之和。 */public class SumOfLeftLeaves { /** * 递归法求二叉树的所有左叶子节点之和 * @param root * @return */ public int sumOfLeftLeaves(TreeNode root){ if (root == null) return 0; //递归终止条件 int mid = 0; //左叶子节点的条件 if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null){ mid = root.left.val; } //递归root节点的左子树和右子树 int left = sumOfLeftLeaves(root.left); int right = sumOfLeftLeaves(root.right); //把所有找到的左叶子节点求和 int sum = mid + left + right; return sum; } //迭代法，使用栈 public int sumOfLeftLeaves2(TreeNode root){ if (root == null) return 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); int sum = 0; while (!stack.isEmpty()){ root = stack.pop(); //左叶子节点的条件 if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null){ sum += root.left.val; } if (root.right != null) stack.push(root.right); if (root.left != null) stack.push(root.left); } return sum; }} 2.找树左下角的值leetcode题目链接 题目 给定一个二叉树，在树的最后一行找到最左边的值。 思路分析 直接利用层序遍历，找到每一层最左边的节点即可 代码详情 123456789101112131415161718192021222324public class BottomLeftValue { public int findBottomLeftValue(TreeNode root) { if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int result = 0; while (!queue.isEmpty()){ int size = queue.size(); for (int i = 0; i &lt; size; i++) { TreeNode cur = queue.poll(); if (i == 0) result = cur.val; if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return result; }} 3.最大二叉树leetcode题目链接 题目 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。 示例 ： 思路分析 最大二叉树的构建过程如下： 构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。 代码详情 1234567891011121314151617181920212223242526272829303132public class ConstructMaximumBinaryTree { public TreeNode constructMaximumBinaryTree(int[] nums) { return traversal(nums,0,nums.length); } private TreeNode traversal(int[] nums, int left, int right) { //递归的参数和返回值 //递归终止条件 if (left &gt;= right){ return null; } //分割点下标,因为下面比较要用到，所以要赋初始值 int maxValueIndex = left; //寻找分割点 for (int i = left; i &lt; right; i++) { if (nums[i] &gt; nums[maxValueIndex]) maxValueIndex = i; } TreeNode root = new TreeNode(nums[maxValueIndex]); // 左闭右开：[left, maxValueIndex) root.left = traversal(nums,left,maxValueIndex); // 左闭右开：[maxValueIndex + 1, right) root.right = traversal(nums,maxValueIndex+1,right); return root; }} 4.将有序数组转为二叉搜索树leetcode题目链接 题目 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例： 思路分析 如果根据数组构造一颗二叉树。 本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间。 本题其实要比第三题 ：最大二叉树简单一些，因为有序数组构造二叉搜索树，寻找分割点就比较容易了。 分割点就是数组中间位置的节点。 那么为问题来了，如果数组长度为偶数，中间节点有两个，取哪一个？ 取哪一个都可以，只不过构成了不同的平衡二叉搜索树。 例如：输入：[-10,-3,0,5,9] 如下两棵树，都是这个数组的平衡二叉搜索树： 如果要分割的数组长度为偶数的时候，中间元素为两个，是取左边元素 就是树1，取右边元素就是树2。 代码详情 123456789101112131415161718192021222324252627282930313233343536373839404142/**题目： * 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 * 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。 * 链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree * * 本题可以不用考虑是不是高度平衡的 * 另外，此题和 最大二叉树 有点类似 * * 最大二叉树题目： * 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： * 二叉树的根是数组中的最大元素。 * 左子树是通过数组中最大值左边部分构造出的最大二叉树。 * 右子树是通过数组中最大值右边部分构造出的最大二叉树。 * 通过给定的数组构建最大二叉树，并且输出这个树的根节点。 * 题目地址：https://leetcode-cn.com/problems/maximum-binary-tree/ */public class ConvertSortedArrayToBST { public TreeNode sortedArrayToBST(int[] nums) { if (nums.length == 0) return null; TreeNode root = traversal(nums,0,nums.length - 1); return root; } private TreeNode traversal(int[] nums, int left, int right) { if (left &gt; right) return null; int mid = (left + right) / 2; TreeNode root = new TreeNode(nums[mid]); //左闭右闭 root.left = traversal(nums,left,mid-1); root.right = traversal(nums,mid+1,right); return root; }} 5.合并二叉树leetcode题目链接 题目 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例： 思路分析 以Tree1为要返回的树，如果对应的节点中，有其中一个为空，就返回另一个，如果两个都不为空，则把节点的值相加 然后递归两棵树对应的左孩子和右孩子，最后返回Tree1的头节点 代码详情 123456789101112131415public class MergeTrees { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) return root2; if (root2 == null) return root1; root1.val += root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; }} 总结 1.前序、中序和后序遍历考虑使用栈 2.层序遍历考虑使用队列 3.其它情况先考虑队列，再考虑使用栈 参考：代码随想录，感谢carl哥！！！","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"二叉树刷题笔记①","slug":"二叉树刷题笔记①","date":"2021-08-23T01:40:28.000Z","updated":"2021-08-24T06:05:33.621Z","comments":true,"path":"posts/6b0a.html","link":"","permalink":"https://www.colorfo.top/posts/6b0a.html","excerpt":"","text":"1.反转二叉树leetcode题目链接 题目 反转一颗二叉树 代码详情 1.DFS递归，可以使用前序和后序遍历，交换当前节点的左右孩子 2.BFS，利用层序遍历，交换当前节点的左右孩子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class InvertBinaryTree { /**DFS递归 * * 这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不行， * 因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了 */ public TreeNode invertTree(TreeNode root){ if (root == null){ return root; } invert(root); return root; } private void invert(TreeNode root) { if (root == null){ return; } TreeNode temp = null; temp = root.left; root.left = root.right; root.right = temp; invert(root.left); invert(root.right); } //------------------------------------ /**BFS层序遍历 *利用层序遍历，交换当前节点的左右孩子 */ public TreeNode invertTreeBFS(TreeNode root){ if (root == null){ return root; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()){ int size = queue.size(); //交换当前层的节点的左右孩子 TreeNode cur = null; TreeNode temp = null; for (int i = 0; i &lt; size; i++) { cur = queue.poll(); temp = cur.left; cur.left = cur.right; cur.right = temp; if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return root; }} 2.对称二叉树leetcode题目链接 题目:给定一个二叉树，检查它是否是镜像对称的。 方法一：递归 思路分析 首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！ 对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也是要同时遍历两棵树。 那么如果比较呢？ 比较的是两个子树的里侧和外侧的元素是否相等。如图所示： 那么遍历的顺序应该是什么样的呢？ 本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。 正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。 但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。 代码详情 1234567891011121314151617181920212223242526/** * 方法一：递归法 */ public boolean isSymmetric(TreeNode root){ if (root == null){ return true; } return compare(root.left,root.right); } private boolean compare(TreeNode left, TreeNode right) { //首先判断节点为空的情况 if (left == null &amp;&amp; right == null) return true; else if (left == null &amp;&amp; right != null) return false; else if (left != null &amp;&amp; right == null) return false; // 排除了空节点，再排除数值不相同的情况 else if (left.val != right.val) return false; // 此时就是：左右节点都不为空，且数值相同的情况 // 此时才做递归，做下一层的判断 boolean outside = compare(left.left,right.right); // 比较左节点的左孩子 和 右节点的右孩子 boolean inside = compare(left.right,right.left); // 比较左节点的右孩子 和 右节点的左孩子 boolean isSame = outside &amp;&amp; inside; // 左子树：中、 右子树：中 （逻辑处理） return isSame; } 方法二：迭代法 思路分析 通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示： 代码详情 123456789101112131415161718192021222324252627282930/** * 方法二：迭代法(使用一个队列实现) */ public boolean isSymmetric2(TreeNode root){ if (root == null) return true; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root.left); // 将左子树头结点加入队列 queue.offer(root.right); // 将右子树头结点加入队列 while (!queue.isEmpty()){ // 接下来就要判断这这两个树是否相互翻转 TreeNode leftNode = queue.poll(); TreeNode rightNode = queue.poll(); if (leftNode == null &amp;&amp; rightNode == null){ // 左节点为空、右节点为空，此时说明是对称的 continue; } // 左右一个节点不为空，或者都不为空但数值不相同，返回false if (leftNode == null || rightNode == null || leftNode.val != rightNode.val){ return false; } queue.offer(leftNode.left); // 加入左节点左孩子 queue.offer(rightNode.right); // 加入右节点右孩子 queue.offer(leftNode.right); // 加入左节点右孩子 queue.offer(rightNode.left); // 加入右节点左孩子 } return true; } 3.完全二叉树的节点个数leetcode题目链接 题目 给出一个完全二叉树，求出该树的节点个数。 方法一：层序遍历 思路分析 遍历模板稍稍修改一下，记录遍历的节点数量就可以了。 代码详情 123456789101112131415161718192021222324252627282930/**方法一 * 利用层序遍历的模板，统计二叉树的节点个数 * @param root * @return */ public int countNodes(TreeNode root) { if (root == null) { return 0; } //LinkedList可以作为Queue的实现类 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入队列 int count = 0; while (!queue.isEmpty()) { int size = queue.size(); //取出当前队列的大小 TreeNode cur = null; //将队列中的元素依次取出，然后让其左右子树(如果不为空的话)入队列 for (int i = 0; i &lt; size; i++) { count++; //记录当前二叉树的节点个数 cur = queue.poll(); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return count; } 方法二：递归 思路分析 1.确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。 代码如下： 1int getNodesNum(TreeNode root) { } 2.确定终止条件：如果为空节点的话，就返回0，表示节点数为0。 代码如下： 1if (root == null) return 0; 3.确定单层递归的逻辑：先求它的左子树的节点数量，再求的右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。 代码如下： 1234int leftNum = getNodesNum(root.left); //左int rightNum = getNodesNum(root.right); //右int treeNum = leftNum + rightNum + 1; //中return treeNum; java整体代码如下： 12345678910111213141516/**方法二 * 利用递归统计二叉树的节点个数 */ public int countNode(TreeNode root){ return getNodesNum(root); } private int getNodesNum(TreeNode root) { if (root == null) { return 0; } int leftNum = getNodesNum(root.left); //左 int rightNum = getNodesNum(root.right); //右 int treeNum = leftNum + rightNum + 1; //中 return treeNum; } 4.平衡二叉树leetcode题目链接 题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 二叉树的高度与深度 ​ 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。 ​ 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。 代码详情 下面的方法通过层序遍历获得当前节点距离叶子节点的高度 1234567891011121314151617181920//此方法可以获取当前root节点距离叶子节点的高度 private int levelOrder(TreeNode root) { if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int high = 0; while (!queue.isEmpty()){ int size = queue.size(); TreeNode cur; high++; for (int i = 0; i &lt; size; i++) { cur = queue.poll(); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return high; } 然后再用栈来模拟前序遍历，遍历每一个节点的时候，再去判断左右孩子的高度是否符合，代码如下： 1234567891011121314151617181920212223242526272829/**:迭代法，使用层序遍历 * * 用栈来模拟前序遍历，遍历每一个节点的时候， * 再去判断左右孩子的高度是否符合，代码如下 * @param root * @return */ public boolean isBalanced(TreeNode root){ if (root == null){ return true; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); TreeNode cur = null; while (!stack.isEmpty()){ cur = stack.pop(); if (Math.abs(levelOrder(cur.left) - levelOrder(cur.right)) &gt; 1){ return false; } if (cur.left != null) stack.push(cur.left); if (cur.right != null) stack.push(cur.right); } return true; } 5. 二叉树的所有路径leetcode题目链接 题目 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 思路分析 这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。 在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。 前序遍历以及回溯的过程如图： 我们先使用递归的方式，来做前序遍历。要知道递归和回溯就是一家的，本题也需要回溯。 递归三部曲 1.递归函数函数参数以及返回值 要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下 1private void traversal(TreeNode root, LinkedList&lt;Integer&gt; path, List&lt;String&gt; result) 2.递归终止条件 当 root不为空，其左右孩子都为空的时候，就找到叶子节点。 所以本题的终止条件是： 123456789101112//遍历到了叶子节点//将path保存的节点值，全部转为字符串sPath,这样就得到了路径，最后放入result集合中 if (root.left == null &amp;&amp; root.right == null){ int size = path.size(); String sPath = \"\"; for (int i = 0; i &lt; size - 1; i++) { sPath += path.get(i); sPath += \"-&gt;\"; } sPath += path.get(size - 1); //这里记录最后一个节点(叶子节点)，因为输出格式需要 result.add(sPath); } if花括号里面的是，终止的处理逻辑 3.单层递归逻辑 因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。 1path.add(root.val); //将当前节点值加入到path集合中 然后是递归和回溯的过程，上面说过没有判断root是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了(所以说能进递归函数的root节点一定是不为空的)。 所以递归前要加上判断语句，下面要递归的节点是否为空，如下 123456789if (root.left != null){ traversal(root.left,path,result); //递归 path.removeLast(); //回溯}if (root.right != null){ traversal(root.right,path,result); //递归 path.removeLast(); //回溯} 整体代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package top.colorfor.tree;import java.util.LinkedList;import java.util.List;public class PathsOfTree { public List&lt;String&gt; treePaths(TreeNode root) { List&lt;String&gt; result = new LinkedList&lt;&gt;(); //result集合作为最后的结果 if (root == null) return result; LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); //path集合保存递归过程中的节点的值 traversal(root,path,result); return result; } private void traversal(TreeNode root, LinkedList&lt;Integer&gt; path, List&lt;String&gt; result) { path.add(root.val); //将当前节点值加入到path集合中 //遍历到了叶子节点 //将path保存的节点值，全部转为字符串sPath,这样就得到了路径，最后放入result集合中 if (root.left == null &amp;&amp; root.right == null){ int size = path.size(); String sPath = \"\"; for (int i = 0; i &lt; size - 1; i++) { sPath += path.get(i); sPath += \"-&gt;\"; } sPath += path.get(size - 1); result.add(sPath); } if (root.left != null){ traversal(root.left,path,result); //递归 path.removeLast(); //回溯 } if (root.right != null){ traversal(root.right,path,result); //递归 path.removeLast(); //回溯 } } //-----------main---------------- /* public static void main(String[] args) { PathsOfTree tree = new PathsOfTree(); TreeNode root = new TreeNode(1); TreeNode node2 = new TreeNode(2); TreeNode node3 = new TreeNode(3); root.left = node2; root.right = node3; node2.left = new TreeNode(4); List&lt;String&gt; strings = tree.treePaths(root); for (String string : strings) { System.out.println(string); } }*/} 6.路径总和leetcode题目链接 题目 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 代码详情 此题可在第5题代码的基础上稍加修改得到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class PathSum { public boolean hasPathSum(TreeNode root,int targetSum){ if (root == null) return false; LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); traversal(root,path,result,targetSum); return result.contains(targetSum); } private void traversal(TreeNode root, LinkedList&lt;Integer&gt; path, List&lt;Integer&gt; result,int targetSum) { path.add(root.val); if (root.left == null &amp;&amp; root.right == null){ int size = path.size(); int sum = 0; for (int i = 0; i &lt; size; i++) { sum += path.get(i); } result.add(sum); if (sum == targetSum) { return; } } if (root.left != null){ traversal(root.left,path,result,targetSum); path.removeLast(); } if (root.right != null){ traversal(root.right,path,result,targetSum); path.removeLast(); } } //-----------main---------------- public static void main(String[] args) { PathSum tree = new PathSum(); TreeNode root = new TreeNode(1); TreeNode node2 = new TreeNode(2); TreeNode node3 = new TreeNode(3); root.left = node2; root.right = node3; node2.left = new TreeNode(4); boolean b = tree.hasPathSum(root, 4); System.out.println(b); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"二叉树的层序遍历","slug":"二叉树的层序遍历","date":"2021-08-21T12:16:58.000Z","updated":"2021-08-21T13:13:07.591Z","comments":true,"path":"posts/bd66.html","link":"","permalink":"https://www.colorfo.top/posts/bd66.html","excerpt":"","text":"1.二叉树的层序遍历 leetcode题目链接 题目 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点） 思路分析 需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。 而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。 使用队列实现二叉树广度优先遍历，动画如下： 代码详情 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; }}*///二叉树的层序遍历public class LevelOrder { /** * * @param root 二叉树的根节点 * @return 返回层序遍历的结果 */ public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root){ List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if (root == null){ return result; } //LinkedList可以作为Queue的实现类 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入队列 while (!queue.isEmpty()){ int size = queue.size(); //取出当前队列的大小 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); TreeNode cur = null; //将队列中的元素依次取出，然后让其左右子树(如果不为空的话)入队列 for (int i = 0; i &lt; size; i++) { cur = queue.poll(); list.add(cur.val); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } //将每层遍历的结果放入result集合中 result.add(list); } return result; }} 这份代码也可以作为二叉树层序遍历的模板,十分重要，一定要会 2.二叉树的层次遍历 IIleetcode题目链接 题目 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 代码详情 此题跟第一题差不多，可以使用Collections.reverse()方法，或者使用栈把第一题的结果反转一下即可， 直接给出代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//层序遍历，自底向上输出public class LevelOrder2 { /** * * @param root 二叉树的根节点 * @return 返回层序遍历的结果 */ public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root){ List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); Stack&lt;List&lt;Integer&gt;&gt; stack = new Stack&lt;&gt;(); if (root == null){ return result; } //LinkedList可以作为Queue的实现类 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入队列 while (!queue.isEmpty()){ int size = queue.size(); //取出当前队列的大小 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); TreeNode cur = null; //将队列中的元素依次取出，然后让其左右子树(如果不为空的话)入队列 for (int i = 0; i &lt; size; i++) { cur = queue.poll(); list.add(cur.val); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } //将每层遍历的结果先放入stack stack.push(list); } //将栈中保存的每层的遍历结果，依次弹出，然后加入到result集合中 //这样就实现了二叉树自底向上的层序遍历 while (!stack.isEmpty()){ result.add(stack.pop()); } return result; }} 3.二叉树的右视图leetcode题目链接 题目 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 思路分析 层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 给定一个二叉树的 根节点 root，想象自己站在它的右侧， * 按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 */public class RightSideView { /** * * @param root 二叉树的根节点 * @return 返回层序遍历的结果 */ public List&lt;Integer&gt; levelOrder(TreeNode root){ List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null){ return result; } //LinkedList可以作为Queue的实现类 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入队列 while (!queue.isEmpty()){ int size = queue.size(); //取出当前队列的大小 LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); TreeNode cur = null; //将队列中的头元素取出，然后让其左右子树(如果不为空的话)入队列 for (int i = 0; i &lt; size; i++) { cur = queue.poll(); //如果是最后一个，就加入result集合 if (i == size-1) result.add(cur.val); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return result; }} 4.二叉树的层平均值leetcode题目链接 题目 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 代码详情 本题就是层序遍历的时候把一层求个总和在取一个均值。 123456789101112131415161718192021222324252627282930313233343536/** * 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 */public class AverageOfLevels { public List&lt;Double&gt; averageOfLevels(TreeNode root){ List&lt;Double&gt; result = new LinkedList&lt;&gt;(); if (root == null){ return result; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //根节点入队列 while (!queue.isEmpty()){ int size = queue.size(); // 获取队列的大小 double average = 0.0; double sum = 0.0; TreeNode cur = null; for (int i = 0; i &lt; size; i++) { cur = queue.poll(); sum = sum + cur.val; // sum累加，把每层的节点值相加 if (i == size-1){ // 遇到每层的最后一个节点，求该层的平均值 average = sum / size; } //让左右子树(如果不为空的话)入队列 if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } result.add(average); } return result; }} 5.N叉树的层序遍历leetcode题目链接 题目 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。 例如，给定一个 3叉树 : 返回其层序遍历: [ [1], [3,2,4], [5,6] ] 代码详情 这道题依旧是模板题，只不过一个节点有多个孩子了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*public class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; }}*//** * 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。 */public class NTreeLevelOrder { public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root){ List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if (root == null) { return result; } Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入队列 while (!queue.isEmpty()){ int size = queue.size(); Node cur = null; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) { //队列的头节点出队列，并将节点的值加入该层list集合 cur = queue.poll(); list.add(cur.val); //如果该节点的子节点不为空，则全部加入队列中 if (cur.children != null){ List&lt;Node&gt; children = cur.children; int len = children.size(); int index = 0; while (index &lt; len){ queue.offer(children.get(index++)); } } } //将当前层的节点值集合list加入到result集合中 result.add(list); } return result; }} 6.在每个树行中找最大值leetcode题目链接 题目 您需要在二叉树的每一行中找到最大的值。 代码详情 层序遍历，取每一层的最大值 12345678910111213141516171819202122232425262728293031323334public class FindLargestInTreeRow { public List&lt;Integer&gt; largestValues(TreeNode root){ LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null){ return result; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入到队列中 while (!queue.isEmpty()){ int size = queue.size(); TreeNode cur = null; int maxRow = Integer.MIN_VALUE; int temp = 0; //将遍历当前层的节点，找出最大值，保存在maxRow中 for (int i = 0; i &lt; size; i++) { cur = queue.poll(); temp = cur.val; maxRow = temp &gt; maxRow ? temp : maxRow; //如果当前节点的左右子树不为空，则加入队列 if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } result.add(maxRow); } return result; }} 7.填充每个节点的下一个右侧节点指针leetcode题目链接 题目 给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 12345678910111213141516171819202122/*// Definition for a Node.class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; }};*/ 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 思路分析 本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点， 然后在遍历的时候让当前节点的next域指向下一个节点（next）就可以了 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。 * 如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 */public class NextConnectRight { public Node connect(Node root){ if (root == null) { return null; } Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入队列 while (!queue.isEmpty()){ int size = queue.size(); //获取队列的大小 Node cur = null; if (!queue.isEmpty()){ cur = queue.poll(); //使用cur指针，指向本层的第一个节点 //如果当前节点的左右子节点不为空，将左右子节点加入队列 if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } Node next = null; for (int i = 1; i &lt; size; i++) { //由于本层的第一个节点已经出队列，所以i从1开始 next = queue.poll(); //让cur右边的节点出队列 cur.next = next; //cur的next域指向cur右边的节点 //如果当前节点的左右子节点不为空，将左右子节点加入队列 if (next.left != null) queue.offer(next.left); if (next.right != null) queue.offer(next.right); //让cur往右边移动一位，为下一次循环做准备 cur = next; } } return root; }} 关联题目:填充每个节点的下一个右侧节点指针II 8.二叉树的最大深度leetcode题目链接 题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 返回它的最大深度 3 。 代码详情 本题依旧使用层序遍历，每遍历一层，二叉树的深度就加1 1234567891011121314151617181920212223242526272829public class MaxDepthOfTree { public int maxDepth(TreeNode root){ if (root == null) { return 0; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int depth = 0; while (!queue.isEmpty()){ int size = queue.size(); TreeNode cur = null; for (int i = 0; i &lt; size; i++) { cur = queue.poll(); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } depth++; } return depth; }} 9.二叉树的最小深度leetcode题目链接 题目 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 代码详情 相对于 104.二叉树的最大深度 ，本题还也可以使用层序遍历的方式来解决，思路是一样的。 需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点 1234567891011121314151617181920212223242526272829303132public class MinDepthOfTree { public int minDepth(TreeNode root){ if (root == null) { return 0; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int depth = 0; while (!queue.isEmpty()){ int size = queue.size(); depth++; TreeNode cur = null; for (int i = 0; i &lt; size; i++) { cur = queue.poll(); //如果当前节点的左右孩子都为空，直接返回最小深度 if (cur.left == null &amp;&amp; cur.right == null){ return depth; } if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return depth; }} 以上题目参考:代码随想录 感谢哈工大师兄Carl！！！","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://www.colorfo.top/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}]},{"title":"用递归和非递归的方式实现二叉树的遍历","slug":"用递归和非递归的方式实现二叉树的遍历","date":"2021-08-20T07:55:12.000Z","updated":"2021-08-20T08:13:23.224Z","comments":true,"path":"posts/a2eb.html","link":"","permalink":"https://www.colorfo.top/posts/a2eb.html","excerpt":"","text":"1.用递归的方式实现二叉树的前序、中序和后序遍历 递归三要素 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 代码实现 1234567891011121314//TreeNode节点类public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; } } 123456789101112131415161718192021222324252627282930313233343536373839404142public class RecursionTree { public void preOrderRecur(TreeNode root){ System.out.println(\"前序遍历二叉树(递归)\"); if (root == null){ return; } //中 左 右 System.out.println(root.val); preOrderRecur(root.left); preOrderRecur(root.right); } //中序遍历二叉树，递归 public void inOrderRecur(TreeNode root){ if (root == null){ return; } //前 中 右 inOrderRecur(root.left); System.out.println(root.val); inOrderRecur(root.right); } //后序遍历二叉树，递归 public void postOrderRecur(TreeNode root){ if (root == null){ return; } //左 右 中 postOrderRecur(root.left); postOrderRecur(root.right); System.out.println(root.val); }} 2.用非递归的方式实现二叉树的前序、中序和后序遍历2.1前序遍历 思路分析 前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。 为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839/**前序遍历，非递归 * * 思路分析: * * 1.申请一个新的栈，即为stack,然后将root节点压入栈中 * * * * 2.从stack中弹出栈顶节点，记为root,然后将root节点的值放入result集合， * * 再将root节点的右子节点(不为空的话)先压入栈中， * * 最后将root节点的左子节点(不为空的话)压入栈中 * * * * 3.不断重复步骤2,直到stack为空，全部过程结束 * * @param root */ public List&lt;Integer&gt; preOrderUnRecur(TreeNode root){ List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root != null){ //如果根节点不为空，将其压入栈中 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()){ //从栈中弹出栈顶元素，并打印其节点的值 root = stack.pop(); result.add(root.val); //如果当前节点的右子节点不为空，将右子节点压入栈中 if (root.right != null){ stack.push(root.right); } //如果当前节点的左子节点不为空，将左子节点压入栈中 if (root.left != null){ stack.push(root.left); } } } return result; } 2.2中序遍历 思路分析 分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。 那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。 那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。 代码实现 12345678910111213141516171819202122232425262728293031323334/**中序遍历二叉树(非递归) * * 思路分析： * 1.中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问， * 直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result集合中）， * 这就造成了处理顺序和访问顺序是不一致的。 * 2.在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。 * * @param root 二叉树的根节点 * @return 返回一个list集合，保存中序遍历的结果 */ public List&lt;Integer&gt; inOrderUnRecur(TreeNode root){ List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null){ return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()){ if (cur != null){ //指针来访问节点，访问到最底层 stack.push(cur); // 将访问的节点放进栈 cur = cur.left; //左 }else { cur = stack.pop(); //从栈里面弹出的数据就是要处理的数据 result.add(cur.val); //放进result集合中 cur = cur.right; } } return result; } 2.3 后序遍历 思路分析 再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图： 代码实现 123456789101112131415161718192021222324252627282930313233343536/**后序遍历二叉树(非递归) * * 思路分析: * 先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序， * 就变成中右左的遍历顺序，然后在反转result集合，输出的结果顺序就是左右中了 * * @param root 二叉树的根节点 * @return 返回一个list集合，保存中序遍历的结果 */ public List&lt;Integer&gt; postOrderUnRecur(TreeNode root){ List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null){ return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()){ root = stack.pop(); result.add(root.val); if (root.left != null){ stack.push(root.left); } if (root.right != null){ stack.push(root.right); } } Collections.reverse(result); return result; } 参考：代码随想录","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"二叉树的遍历","slug":"二叉树的遍历","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"}]},{"title":"KMP算法匹配字符串","slug":"KMP算法匹配字符串","date":"2021-08-15T08:13:07.000Z","updated":"2021-08-15T11:21:33.706Z","comments":true,"path":"posts/c86b.html","link":"","permalink":"https://www.colorfo.top/posts/c86b.html","excerpt":"","text":"一、KMP算法匹配字符串1.题目leetcode-链接 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 12输入：haystack = \"aabaabaaf\", needle = \"aabaaf\"输出：3 2.解答方法一：朴素解法 思路分析 直观的解法的是：枚举原串 ss 中的每个字符作为「发起点」，每次从原串的「发起点」和匹配串的「首位」开始尝试匹配： 匹配成功：返回本次匹配的原串「发起点」。匹配失败：枚举原串的下一个「发起点」，重新尝试匹配。 参考：宫水三叶 代码详情 12345678910111213141516171819class Solution { public int strStr(String ss, String pp) { int n = ss.length(), m = pp.length(); char[] s = ss.toCharArray(), p = pp.toCharArray(); // 枚举原串的「发起点」 for (int i = 0; i &lt;= n - m; i++) { // 从原串的「发起点」和匹配串的「首位」开始，尝试匹配 int a = i, b = 0; while (b &lt; m &amp;&amp; s[a] == p[b]) { a++; b++; } // 如果能够完全匹配，返回原串的「发起点」下标 if (b == m) return i; } return -1; }} 方法二:KMP算法参考：代码随想录 一、构造next数组构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步： 初始化 处理前后缀不相同的情况 处理前后缀相同的情况 1.初始化： 定义两个指针i和j，j指向前缀起始位置，i指向后缀起始位置。 然后还要对next数组进行初始化赋值，如下： 12int j = -1;next[0] = j; j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。 next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j） 所以初始化next[0] = j 。 2.处理前后缀不相同的情况 因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。 所以遍历模式串s的循环下标i 要从 1开始，代码如下： 1for(int i = 1; i &lt; s.size(); i++) { 如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。 怎么回退呢？ next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。 那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。 所以，处理前后缀不相同的情况代码如下： 1234while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退} 3.处理前后缀相同的情况 如果s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。 代码如下： 1234if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++;}next[i] = j; 最后整体构建next数组的函数代码如下： 12345678910111213void getNext(int* next, const string&amp; s){ int j = -1; next[0] = j; for(int i = 1; i &lt; s.size(); i++) { // 注意i从1开始 while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; // 将j（前缀的长度）赋给next[i] }} 代码构造next数组的逻辑流程动画如下： 二、使用next数组来做匹配在文本串s里 找是否出现过模式串t。 定义两个下标j 指向模式串起始位置，i指向文本串起始位置。 那么j初始值依然为-1，为什么呢？ 依然因为next数组里记录的起始位置为-1。 i就从0开始，遍历文本串，代码如下： 1for (int i = 0; i &lt; s.size(); i++) 接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。 如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。 代码如下： 123while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) { j = next[j];} 如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下： 123if (s[i] == t[j + 1]) { j++; // i的增加在for循环里} 如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。 本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。 代码如下： 123if (j == (t.size() - 1) ) { return (i - t.size() + 1);} 那么使用next数组，用模式串匹配文本串的整体代码如下： 123456789101112int j = -1; // 因为next数组里记录的起始位置为-1for (int i = 0; i &lt; s.size(); i++) { // 注意i就从0开始 while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) { // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动 j++; // i的增加在for循环里 } if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t return (i - t.size() + 1); }} 此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class KMPStr { public int[] getNext(String pattern){ char[] s = pattern.toCharArray(); int[] next = new int[s.length]; //初始化一个next数组 int j = -1; //j+1指向前缀起始位置 next[0] = j; for (int i = 1; i &lt; s.length; i++) { //i指向后缀起始位置,从1 开始 while(j &gt;= 0 &amp;&amp; s[i] != s[j+1]){// 前后缀不相同了 j = next[j]; //让j+1向前回退 } if(s[i] == s[j+1]){// 找到相同的前后缀 j++; //j+1后移一位 } next[i] = j; //将j（前缀的长度）赋给next[i] } return next; } public int strStr(String haystack,String needle){ if (needle.length() == 0){ return 0; } char[] s = haystack.toCharArray(); char[] t = needle.toCharArray(); int j = -1; // 因为next数组里记录的起始位置为-1 int[] next = getNext(needle); //获取next数组 for (int i = 0; i &lt; s.length; i++) { // 注意i就从0开始 while (j &gt;= 0 &amp;&amp; s[i] != t[j+1]){ // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (s[i] == t[j+1]){ // 匹配，j和i同时向后移动,i的增加在for循环里 j++; } if (j == t.length-1){ // 文本串s里出现了模式串t return i - t.length + 1; } } return -1; } //------------main------------ public static void main(String[] args) { KMPStr kmp = new KMPStr(); int[] next = kmp.getNext(\"aabaaf\"); System.out.println(Arrays.toString(next)); int i = kmp.strStr(\"aabaabaaf\", \"aabaaf\"); System.out.println(i); }} 二、重复的子字符串leetcode题目链接 题目 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 12345678910111213示例 1:输入: \"abab\"输出: True解释: 可由子字符串 \"ab\" 重复两次构成。示例 2:输入: \"aba\"输出: False示例 3:输入: \"abcabcabcabc\"输出: True解释: 可由子字符串 \"abc\" 重复四次构成。 (或者子字符串 \"abcabc\" 重复两次构成。) 思路分析 参考：代码随想录 此题依旧需要用到KMP算法的next数组。 next 数组记录的就是最长相同前后缀( 字符串：KMP算法精讲 这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。 最长相等前后缀的长度为：next[len - 1] + 1。 数组长度为：len 如果len % (len - (next[len - 1] + 1)) == 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被 数组的长度整除，说明有该字符串有重复的子字符串。 数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法 如图： next[len - 1] = 7，next[len - 1] + 1 = 8，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。 (len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf） 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class RepeatedSubstringKMP { public int[] getNext(String pattern){ char[] s = pattern.toCharArray(); int[] next = new int[s.length]; int j = -1; next[0] = j; for (int i = 1; i &lt; s.length; i++) { while (j &gt;= 0 &amp;&amp; s[i] != s[j+1]){ j = next[j]; //当前缀和后缀不相等时，j+1前移 } if (s[i] == s[j+1]){ //当前缀和后缀相等时，i,j+1分别后移 j++; } next[i] = j; } return next; } public boolean isRepeated(String pattern){ if (pattern.length() == 0){ return false; } int[] next = getNext(pattern); int len = next.length; //利用next数组判断，一个字符串是否可以由它的一个子串重复多次构成 if (next[len-1] != -1 &amp;&amp; len%(len-(next[len-1]+1)) == 0){//核心代码 return true; } return false; } //------------main--------------- public static void main(String[] args) { RepeatedSubstringKMP kmp = new RepeatedSubstringKMP(); int[] next = kmp.getNext(\"aabaaf\"); System.out.println(Arrays.toString(next)); System.out.println(kmp.isRepeated(\"aabaab\")); }}","categories":[],"tags":[{"name":"KMP算法","slug":"KMP算法","permalink":"https://www.colorfo.top/tags/KMP%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://www.colorfo.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"数组刷题笔记","slug":"数组刷题笔记","date":"2021-08-11T12:46:27.000Z","updated":"2021-08-12T12:56:04.736Z","comments":true,"path":"posts/7dec.html","link":"","permalink":"https://www.colorfo.top/posts/7dec.html","excerpt":"","text":"1.数组的二分查找 题目 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1 123输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 代码实现 12345678910111213141516171819202122232425262728293031323334353637public class BinarySearch { //二分查找 public int binarySearch(int[] nums,int target){ //先判断要查找的值是否在数组的范围内 if(target &lt; nums[0] || target &gt; nums[nums.length-1]){ return -1; } int left = 0; int right = nums.length-1; while (left &lt;= right){ int middle = (left+right)/2; if (nums[middle] == target){ return middle; }else if (target &lt; nums[middle]){ //如果要查找的值在左边 right = middle - 1; }else { //如果要查找的值在右边 left = middle+1; } } return -1; } //----------main------------- public static void main(String[] args) { BinarySearch binarySearch = new BinarySearch(); int[] arr = {-1,0,3,5,9,12}; int target = 4; int res = binarySearch.binarySearch(arr,target); System.out.println(res); }} 参考：代码随想录 2.移除数组中的元素题目链接 题目 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。 元素的顺序可以改变，你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 ​ 你不需要考虑数组中超出新长度后面的元素。 方法一：暴力求解 思路分析 这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。 代码实现 123456789101112131415161718192021222324252627282930313233343536public class RemoveElement { /**暴力移除数组的元素 * * @param arr 输入的数组 * @param val 要移除的元素 * @return 返回新的数组的长度 */ public int removeElement(int[] arr,int val){ int size = arr.length; for (int i = 0; i &lt; arr.length; i++) { //如果找到要删除的值,就利用一个for循环,将下标i后面的值统统后移 if (arr[i] == val){ for (int j = i+1; j &lt; arr.length; j++) { arr[j-1] = arr[j]; } i--; // 因为此时i后面的值后移了，i位置上是新的值，所以i要减去1 //这样下一次循环时(i++)，i上的值相当于原先i位置上的下一个 size--; } } return size; } //--------main------------ public static void main(String[] args) { RemoveElement remove = new RemoveElement(); int[] arr = {1,2,3,4,6,6}; int length = remove.removeElement(arr, 2); for (int i = 0; i &lt; length; i++) { System.out.println(arr[i]); } }} 方法二：双指针法 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 代码实现 12345678910111213141516171819202122public class RemoveElement2 { public int removeElement(int[] nums,int val){ int slowIndex = 0; for (int fastIndex = 0; fastIndex &lt; nums.length; fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } public static void main(String[] args) { RemoveElement2 remove = new RemoveElement2(); int[] arr = {0,1,2,3,3,0,4,2}; int length = remove.removeElement(arr, 2); for (int i = 0; i &lt; length; i++) { System.out.println(arr[i]); } }} 3.有序数组的平方 题目 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 思路：双指针法 数组其实是有序的， 只不过负数平方之后可能成为最大数了。 那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。 此时可以考虑双指针法了，i指向起始位置，j指向终止位置。 定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。 如果A[i] * A[i] &lt; A[j] * A[j] 那么result[k--] = A[j] * A[j]; 如果A[i] * A[i] &gt;= A[j] * A[j] 那么result[k--] = A[i] * A[i]; 代码详情 1234567891011121314151617181920212223242526272829303132public class SquareOfSortArray { public int[] sortedSquare(int[] arr){ int[] res = new int[arr.length]; int k = arr.length-1; int left = 0; int right = arr.length-1; while (left &lt;= right){ if (arr[right]*arr[right] &gt; arr[left]*arr[left]){ res[k--] = arr[right]*arr[right]; right--; }else { res[k--] = arr[left]*arr[left]; left++; } } return res; } //--------main------ public static void main(String[] args) { SquareOfSortArray sortArray = new SquareOfSortArray(); int[] arr = {-4,-1,2,3,10}; int[] square = sortArray.sortedSquare(arr); for (int i : square) { System.out.println(i); } }} 参考：代码随想录 4.长度最小的子数组题目链接 题目 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 示例： 输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 方法一：暴力解法 代码详情 这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2) 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 长度最小的子数组 */public class MinSubArrayLen { /** 暴力求解，利用两个for循环 * * @param nums 输入的数组 * @param s 要求子数组的和 &gt;= s * @return 返回子数组的长度 */ public int minSubArrayLen(int[] nums,int s){ int result = Integer.MAX_VALUE; // 要返回的子数组的长度 int subLen = 0; // 子数组的长度，中间变量，用于比较各个子数组 int sum = 0; //用于计算子数组的和 for (int i = 0; i &lt; nums.length; i++) { //遍历数组 sum = 0; for (int j = i; j &lt; nums.length ; j++) { //j从i的位置往后累加 sum += nums[j]; if(sum &gt;= s){ subLen = j-i+1; //当累加结果sum大于等于s时，保留此时的子数组长度 result = subLen &lt; result ? subLen : result; //更新result的值 break; //跳出循环，进行下一轮 } } } return result == Integer.MAX_VALUE ? 0 : result; //如果result的值不变， // 说明为找到符合条件的子数组，则返回0 } //--------------main--------------- public static void main(String[] args) { MinSubArrayLen subArrayLen = new MinSubArrayLen(); int[] nums = {2,3,1,2,4,3}; int len = subArrayLen.minSubArrayLen(nums, 7); System.out.println(len); }} 方法二：滑动窗口 思路分析 接下来就开始介绍数组操作中另一个重要的方法：滑动窗口。 所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。 这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程： 最后找到 4，3 是最短距离。 其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。 在本题中实现滑动窗口，主要确定如下三点： 窗口内是什么？ 如何移动窗口的起始位置？ 如何移动窗口的结束位置？ 窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。 窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。 窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。 解题的关键在于 窗口的起始位置如何移动，如图所示： 可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。 为什么时间复杂度是O(n): 不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是$O(n)$。 代码实现 12345678910111213141516171819202122232425262728/** 滑动窗口，也可以理解为双指针 * * @param nums 输入的数组 * @param s 要求子数组的和 &gt;= s * @return 返回子数组的长度 */ public int minSubArrayLengthWindow(int[] nums,int s){ int result = Integer.MAX_VALUE; // 要返回的子数组的长度 int subLen = 0; // 子数组的长度，中间变量，用于比较各个子数组 int sum = 0; //用于计算子数组的和 int i = 0; //滑动窗口的起始位置 for (int j = 0; j &lt; nums.length; j++) { //j表示滑动窗口的终止位置 sum += nums[j]; //sum滑动窗口内保存的值 //滑动窗口的精髓 while(sum &gt;= s){ //当滑动窗口内的值大于等于s时，滑动窗口的起始位置移动 subLen = j-i+1; result = result &lt; subLen ? result : subLen; //更新result的值 sum = sum - nums[i++]; //滑动窗口内的值减去nums[i],同时，滑动窗口的起始位置右移 } } return result == Integer.MAX_VALUE ? 0 : result; //如果result的值不变， // 说明为找到符合条件的子数组，则返回0 } 转载自：代码随想录，向大佬表示感谢。 5.螺旋矩阵 题目 题目地址：https://leetcode-cn.com/problems/spiral-matrix-ii/ 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例: 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 思路分析 求解本题依然是要坚持循环不变量原则。 模拟顺时针画矩阵的过程: 填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 由外向内一圈一圈这么画下去。 这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开又闭的原则，这样这一圈才能按照统一的规则画下来。 那么我按照左闭右开的原则，来画一圈，大家看一下： 这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。 这也是坚持了每条边左闭右开的原则。 一些同学做这道题目之所以一直写不好，代码越写越乱。 就是因为在画每一条边的时候，一会左开又闭，一会左闭右闭，一会又来左闭右开，岂能不乱。 代码详情 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SpiralMatrix { public static int[][] generateMatrix(int n) { int[][] res = new int[n][n]; // 定义一个二维数组 int startx = 0, starty = 0; // 定义每循环一个圈的起始位置 int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理 int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2) int count = 1; // 用来给矩阵中每一个空格赋值 int offset = 1; // 每一圈循环，需要控制每一条边遍历的长度 int i,j; while ( loop &gt; 0 ) { i = startx; j = starty; // 下面开始的四个for就是模拟转了一圈 // 模拟填充上行从左到右(左闭右开) for (j = starty; j &lt; starty + n - offset; j++) { res[i][j] = count++; } // 模拟填充右列从上到下(左闭右开) for (i = startx; i &lt; startx + n - offset; i++) { res[i][j] = count++; } // 模拟填充下行从右到左(左闭右开) for (; j &gt; starty; j--) { res[i][j] = count++; } // 模拟填充左列从下到上(左闭右开) for (; i &gt; startx; i--) { res[i][j] = count++; } loop--; // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1) startx++; starty++; // offset 控制每一圈里每一条边遍历的长度 offset += 2; } // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值 if (n % 2 == 1) { res[mid][mid] = count; } return res; } //---------------main------------- public static void main(String[] args) { int[][] ints = generateMatrix(5); for (int[] anInt : ints) { for (int i : anInt) { System.out.print(i+\"\\t\"); } System.out.println(\" \"); } }} 转载自：代码随想录，向大佬表示感谢。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://www.colorfo.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指offer题解之链表","slug":"剑指offer题解之链表","date":"2021-08-10T04:35:34.000Z","updated":"2021-08-13T05:05:25.624Z","comments":true,"path":"posts/ae99.html","link":"","permalink":"https://www.colorfo.top/posts/ae99.html","excerpt":"","text":"1.返回链表中倒数最后k个结点牛客网-JZ14 题目：输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。 如果该链表长度小于k，请返回一个长度为 0 的链表。 思路分析 设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K +1个节点处，该位置就是倒数第 K 个节点。 代码实现 123456789101112131415161718//Node节点类public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 返回链表中倒数最后k个结点 * * 注意：此题中链表的头节点即为第一个有效的节点 */public class FindKthToTail { public void add(Node head,Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list(Node head) { if (head == null){ System.out.println(\"链表为空！！！\"); return; } Node cur = head; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } /**输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。 * 如果该链表长度小于k，请返回一个长度为 0 的链表。 * * @param head 输入链表的头节点 * @param k 倒数第k个 * @return 倒数第k个结点至尾节点的全部节点 的 头节点 */ public Node findKthToTail(Node head,int k){ if (head == null){ return null; } Node p1 = head; Node p2 = head; while (p1 != null &amp;&amp; k &gt; 0){ p1 = p1.next; k--; } if (k &gt; 0){ return null; } while (p1 != null){ p1 = p1.next; p2 = p2.next; } return p2; } //---------------main----------------- public static void main(String[] args) { FindKthToTail list = new FindKthToTail(); Node head = new Node(1); list.add(head,new Node(2)); list.add(head,new Node(3)); list.add(head,new Node(4)); list.add(head,new Node(5)); list.list(head); System.out.println(\"--------findKthToTail---------\"); Node newHead = list.findKthToTail(head, 3); list.list(newHead); }} 2.两个链表的第一个公共结点牛客网-JZ36 题目：输入两个无环的单链表，找出它们的第一个公共结点。 解题思路 设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。 当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。 核心代码 12345678public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) { ListNode l1 = pHead1, l2 = pHead2; while (l1 != l2) { l1 = (l1 == null) ? pHead2 : l1.next; l2 = (l2 == null) ? pHead1 : l2.next; } return l1;} 本题转载自：CyC2018 3.环形链表II 题目 https://leetcode-cn.com/problems/linked-list-cycle-ii/ 题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 思路分析 代码详情 123456789101112131415161718192021public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) {// 有环 ListNode index1 = fast; ListNode index2 = head; // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口 while (index1 != index2) { index1 = index1.next; index2 = index2.next; } return index1; } } return null; }} 转载自：代码随想录","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.colorfo.top/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"链表刷题日记","slug":"链表刷题日记","date":"2021-08-08T08:27:43.000Z","updated":"2021-08-09T14:06:39.161Z","comments":true,"path":"posts/3568.html","link":"","permalink":"https://www.colorfo.top/posts/3568.html","excerpt":"","text":"1.在单链表中删除倒数第K个节点 题目 给定一个单链表，要求删除倒数第K个节点，并返回该节点 解答 代码详情 Node节点类 123456789101112131415161718public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 单链表类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class SingleLinkedList { private Node head = new Node(-1); public void add(Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list() { if (head.next == null) { System.out.println(\"链表为空！！！\"); return; } Node cur = head.next; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } /**在单链表中删除倒数第k个节点 * * @param lastKth 倒数第k个 * @return 删除的倒数第k个节点 */ public Node removeLastKthNode(int lastKth){ Node cur = head; if (head.next == null || lastKth &lt; 1){ System.out.println(\"链表为空或者参数输入有误！！！\"); return cur; } //遍历链表，每移动一次，lathKth的值就减去1 while (cur.next != null){ cur = cur.next; lastKth--; } Node res = null; if (lastKth &gt; 0){ //lastKth的值大于链表的长度，直接返回 return cur; }else if(lastKth == 0){ // 此时，lastKth就是第一个节点 this.head = this.head.next; return this.head; }else { //如果lastKth &lt; 0 cur = this.head; while (lastKth != 0){ cur = cur.next; lastKth++; } res = cur.next; //将要删除的节点赋值给res,用来返回 cur.next = cur.next.next; } return res; } //------------------------------main----------------- public static void main(String[] args) { SingleLinkedList linkedList = new SingleLinkedList(); linkedList.add(new Node(1)); linkedList.add(new Node(2)); linkedList.add(new Node(3)); linkedList.add(new Node(4)); linkedList.add(new Node(5)); Node node = linkedList.removeLastKthNode(3); linkedList.list(); System.out.println(\"-------------\"); System.out.println(node); }} 2.单链表的反转 题目 给定一个单链表，实现单链表的反转 思路分析 代码实现 Node节点类 12345678910111213141516171819public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 反转链表类ReverseList 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ReverseList { private Node head = new Node(-1); public void add(Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list() { if (head.next == null) { System.out.println(\"链表为空！！！\"); return; } Node cur = head.next; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } /** * 反转单链表的方法 */ public void reverseList(){ if(head.next == null || head.next.next == null ){ System.out.println(\"不用反转该链表\"); return; } Node cur = head.next; Node next = null; Node newHead = new Node(-2); while(cur != null){ //遍历链表，cur为遍历到的当前节点 next = cur.next; //next 指向当前节点[cur]的下一个节点 cur.next = newHead.next; //当前节点[cur]的next域指向新的头节点的下一个节点 newHead.next = cur; //newHead的next域指向当前节点[cur] cur = next; //cur后移一位 } head.next = newHead.next; } //--------------main-------------------- public static void main(String[] args) { ReverseList reverseList = new ReverseList(); reverseList.add(new Node(1)); reverseList.add(new Node(3)); reverseList.add(new Node(2)); reverseList.add(new Node(4)); reverseList.list(); System.out.println(\"---反转后的链表---\"); reverseList.reverseList(); reverseList.list(); }} 3.判断一个链表是否为回文结构 题目 给定一个链表，请判断该链表是否为回文结构 例如： 1-&gt;2-&gt;1,返回true 1-&gt;2-&gt;2-&gt;1,返回true 1-&gt;2-&gt;3,返回false 思路分析 1.遍历链表，将链表的节点依次压入一个栈中 2.依次弹出栈中的节点，与链表中的节点作比较，如果每次比较的节点的值都相等，则为回文结构 代码实现 1234567891011121314151617//Node节点类public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 判断链表是否是回文结构 */public class IsPalindrome { private Node head = new Node(-1); public void add(Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public boolean isPalindrome(){ if (head.next == null){ System.out.println(\"链表为空！！！\"); return false; } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node cur = head.next; while (cur != null){ stack.push(cur); cur = cur.next; } cur = head.next; Node popNode = null; boolean flag = true; while (!stack.isEmpty() &amp;&amp; cur != null){ popNode = stack.pop(); if (popNode.val != cur.val){ flag = false; } cur = cur.next; } return flag; } //--------------main---------------- public static void main(String[] args) { IsPalindrome palindrome = new IsPalindrome(); palindrome.add(new Node(1)); palindrome.add(new Node(2)); palindrome.add(new Node(2)); palindrome.add(new Node(1)); boolean palindrome1 = palindrome.isPalindrome(); System.out.println(palindrome1); }} 4.删除无序链表中值重复出现的节点 题目(难度一星) 给定一个无序单链表，删除其中值重复出现的节点 例如:1-&gt;2-&gt;2-&gt;4-&gt;5-&gt;4-&gt;null,删除值重复之后的链表为：1-&gt;2-&gt;4-&gt;5-&gt;null 思路分析 1.遍历当前链表，创建Node节点cur指向当前节点，pre指向cur的前一个节点 2.生成一个哈希表，如果cur的值已经存在于哈希表中，就将当前节点删除(pre.next = cur.next) ​ 如果cur的值不存在哈希表中，将其加入到哈希表中，同时令pre = cur(为下一次遍历做准备) 代码实现 123456789101112131415161718public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 删除链表中的重复节点 */public class RemoveRepeat { private Node head = new Node(-1); public void add(Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list() { if (head.next == null) { System.out.println(\"链表为空！！！\"); return; } Node cur = head.next; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } public void removeRepeat(){ if (head.next == null){ System.out.println(\"链表为空！！！\"); return; } Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Node cur = head.next; //cur指向当前节点 Node pre = head; //cur指向当前节点的前一个节点 while (cur != null){ if (set.contains(cur.val)){ //如果哈希表中包含当前节点cur的值，就删除cur节点 pre.next = cur.next; }else { //如果不包含，则将cur节点的值加入到哈希表中 set.add(cur.val); pre = cur; //pre后移一位 } cur = cur.next; } } //-------------------main--------------------- public static void main(String[] args) { RemoveRepeat remove = new RemoveRepeat(); remove.add(new Node(1)); remove.add(new Node(2)); remove.add(new Node(2)); remove.add(new Node(4)); remove.add(new Node(5)); remove.add(new Node(4)); remove.removeRepeat(); remove.list(); }} 5.合并两个有序的单链表 题目(难度一星) 给定两个有序单链表的头节点head1,head2,请合并两个有序链表，合并后的链表依然有序，并返回合并后链表的头节点 例如： 0-&gt;2-&gt;3-&gt;7-&gt;null 1-&gt;3-&gt;5-&gt;7-&gt;9-&gt;null 合并后的链表：0-&gt;1-&gt;2-&gt;3-&gt;3-&gt;5-&gt;7-&gt;7-&gt;9-&gt;null 思路分析 1.当两个链表都不为空时，遍历两个链表，并比较链表中节点值的大小，将较小的节点加入到 新的以newHead为头节点的链表中，如果相等，则依次加入两个相等的节点。 2.若两个链表中其中一个遍历到了末尾，则把另一个链表中的节点加入到新的链表中 代码实现 12345678910111213141516171819//Node节点类public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * 合并两个有序的单链表 */public class MergeLinkedList { public void add(Node head,Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list(Node head) { if (head.next == null){ System.out.println(\"链表为空！！！\"); return; } Node cur = head.next; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } /** * 合并两个单链表 * @param head1 第一个链表的头节点 * @param head2 第二个链表的头节点 * @return 返回新的链表的头节点 */ public Node merge(Node head1,Node head2){ if (head1.next == null &amp;&amp; head2.next == null){ System.out.println(\"两个链表为空！！！\"); return null; } Node newHead = new Node(-1); Node cur = newHead; head1 = head1.next; head2 = head2.next; while (head1 != null &amp;&amp; head2 != null){ if (head1.val &lt; head2.val){ cur.next = head1; cur = cur.next; head1 = head1.next; }else if (head2.val &lt; head1.val){ cur.next = head2; cur = cur.next; head2 = head2.next; }else { cur.next = head1; cur = cur.next; head1 = head1.next; cur.next = head2; cur = cur.next; head2 = head2.next; } } while (head1 != null){ cur.next = head1; cur = cur.next; head1 = head1.next; } while (head2 != null){ cur.next = head2; cur = cur.next; head2 = head2.next; } return newHead; } //----------------main-------------- public static void main(String[] args) { MergeLinkedList merge = new MergeLinkedList(); Node head1 = new Node(-1); Node head2 = new Node(-1); merge.add(head1,new Node(0)); merge.add(head1,new Node(2)); merge.add(head1,new Node(3)); merge.add(head1,new Node(7)); merge.add(head2,new Node(1)); merge.add(head2,new Node(3)); merge.add(head2,new Node(5)); merge.add(head2,new Node(7)); merge.add(head2,new Node(9)); Node merge1 = merge.merge(head1, head2); merge.list(merge1); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.colorfo.top/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单向环形链表之约瑟夫环","slug":"单向环形链表之约瑟夫环","date":"2021-08-07T08:38:52.000Z","updated":"2021-08-08T14:30:13.745Z","comments":true,"path":"posts/d2de.html","link":"","permalink":"https://www.colorfo.top/posts/d2de.html","excerpt":"","text":"Josephus问题: 约瑟夫问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 例如： n = 5 , 即有5个人 k = 1, 从第一个人开始报数 m = 2, 数2下 出圈的顺序 2-&gt;4-&gt;1-&gt;5-&gt;3 思路图解 构建单向环形链表 节点出圈的思路图解 代码详情 Node节点类 123456789101112131415//小孩节点类public class Boy { int no; Boy next; public Boy(int no) { this.no = no; } public Boy() { }} 下面是单向环形链表类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//单向环形链表-约瑟夫环public class SingleCircle { private Boy first; /** * 将小孩加入约瑟夫环的方法 * @param num 表示环中结点的个数 */ public void add(int num){ first = null; Boy curBoy = null; //辅助变量，用来帮助小孩进圈 for (int i = 1; i &lt;= num; i++) { Boy boy = new Boy(i); //当加入第一个小孩时，让其自己成环 if (i == 1){ first = boy; //first始终指向第一个小孩 first.next = first; curBoy = first; } //新的小孩结点的进圈操作 curBoy.next = boy; curBoy = curBoy.next; curBoy.next = first; } } //遍历圈中的小孩结点 public void list(){ if (first == null){ System.out.println(\"圈中没有小孩结点\"); return; } Boy cur = first; while (true){ System.out.printf(\"当前的小孩编号:%d \\n\",cur.no); if (cur.next == first){ break; } cur = cur.next; } } /** * 小孩出圈的方法 * @param startNo 从第几个小孩开始数 * @param count 数几次 * @param num 圈中小孩的个数 */ public void remove(int startNo,int count,int num){ if (first == null || startNo &lt; 1 || startNo &gt; num){ System.out.println(\"参数输入有误！！！\"); return; } Boy helper = first;//创建一个辅助指针，让其始终位于first指针的前一个 //先让first移动到startNo处，即开始报数的位置 for (int i = 1; i &lt;= startNo-1; i++) { first = first.next; } //再让helper 移动到first的前一位 while (helper.next != first){ helper = helper.next; } while (helper != first){ //开始报数，让helper和first移动到指定位置 for (int i = 1; i &lt;= count-1; i++) { helper = helper.next; first = first.next; } //此时first指向要移除的小孩结点 System.out.printf(\"出圈小孩的编号：%d \\n\",first.no); first = first.next; helper.next = first; } System.out.printf(\"最后出圈小孩的编号：%d \\n\",first.no); } //***************写个main方法测试一下******************* public static void main(String[] args) { SingleCircle singleCircle = new SingleCircle(); singleCircle.add(5); singleCircle.remove(1,2,5); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"约瑟夫环","slug":"约瑟夫环","permalink":"https://www.colorfo.top/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"}]},{"title":"单链表的增删改查和插入","slug":"单链表的增删改查和插入","date":"2021-08-05T07:07:50.000Z","updated":"2021-08-05T07:13:27.881Z","comments":true,"path":"posts/64b9.html","link":"","permalink":"https://www.colorfo.top/posts/64b9.html","excerpt":"","text":"本篇博文属于单链表的入门案例，包含单链表的一些基础操作:增删改查、插入 1.首先创建一个Node结点类 1234567891011121314151617181920212223public class Node { Integer id; String name; Node next; public Node() { } public Node(Integer id, String name) { this.id = id; this.name = name; } @Override public String toString() { return \"Node{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; }} 2.然后创建一个单链表类(包含了单链表的增删改查等方法) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public class SingleList { //头结点 private Node head = new Node(); //为当前单向链表添加一个结点 public void add(Node node){ //定义一个临时结点指向头结点 Node temp = head; //一直遍历链表，直到temp.next == null while (temp.next != null){ temp = temp.next; } //temp.next == null,说明找到了链表的尾部，将node加入链表中 temp.next = node; } //按照id修改链表的name public void update(Node node){ if (head.next == null){ return; } Node temp = head.next; while (temp != null){ if (temp.id == node.id){ temp.name = node.name; break; } temp = temp.next; } } //根据id删除节点 public void delete(int id){ if (head.next == null){ return; } Node temp = head; while (temp.next != null){ if (temp.next.id == id){ temp.next = temp.next.next; break; } temp = temp.next; } } //遍历链表 public void list(){ if (head.next == null){ return; } Node temp = head.next; while (temp != null){ System.out.println(temp); temp = temp.next; } } /** * 按照id编号的大小顺序插入，从小到大 * @param node */ public void insertById(Node node){ Node temp = head; boolean flag = false; while (true){ //如果temp结点的下一个为空，直接跳出循环,从这里跳出循环flag=false; if(temp.next == null){ break; } //程序走到这里，说明，temp.next != null if (node.id == temp.next.id){ flag = true; //从这里跳出循环flag = true break; }else if(node.id &lt; temp.next.id){ break; //从这里跳出循环flag = false; } //这里不用写出node.id &gt; temp.next.id的情况， //因为这种情况会一直遍历到链表的末尾，满足temp.next == null条件后，跳出循环，最后在链表末尾加上node temp = temp.next; //temp 向后移动一位，用来遍历单链表 } if (flag){ System.out.println(\"编号已经存在\"); }else { //在此处执行结点的插入操作(适用于在head结点后加结点(即temp.next == null)，以及node.id 小于 temp.next.id的情况) node.next = temp.next; temp.next = node; } } public static void main(String[] args) { SingleList list = new SingleList(); /*list.add(new Node(1,\"张三\")); list.add(new Node(2,\"lisi\")); list.update(new Node(2,\"李四\")); list.add(new Node(3,\"王五\")); list.add(new Node(4,\"赵六\")); list.delete(1); list.delete(4); list.list();*/ //*****************上面是增删改查的测试************ //*****************下面是按顺序插入的测试************ list.insertById(new Node(3,\"王3\")); list.insertById(new Node(2,\"王2\")); list.insertById(new Node(1,\"王1\")); list.insertById(new Node(5,\"王5\")); list.insertById(new Node(4,\"王4\")); list.insertById(new Node(6,\"王6\")); list.list(); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"https://www.colorfo.top/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"}]},{"title":"栈和队列刷题笔记","slug":"栈和队列刷题笔记","date":"2021-08-04T07:36:20.000Z","updated":"2021-08-16T11:28:53.485Z","comments":true,"path":"posts/f354.html","link":"","permalink":"https://www.colorfo.top/posts/f354.html","excerpt":"","text":"1.用一个栈实现另一个栈的排序 题目： ​ 一个栈中的类型为整型，现在想将该栈从顶到底按照从大到小的顺序排序，只允许申请一个栈，除此之外，可以申请新的变量，如何排序？ 思路分析： ​ 将要排序的栈记为stack,申请的辅助栈记为help，在stack上执行pop操作，弹出的元素记为cur 如果cur小于或等于help的栈顶元素，直接将cur压入help 如果cur大于help的栈顶元素，则将help中的元素逐次弹出，然后压入stack中，直到cur小于或等于help的栈顶元素，再将cur压入help栈中； 如果在help栈的弹栈过程中，help已经空了，则说明cur是当前的最大元素，则直接将cur压入help中 最后，help中的数，从栈顶到栈底为从小到大的顺序，将help中的数依次弹出压入stack中，则stack从栈顶到栈底为从大到小的顺序 难度：一星 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 用一个栈实现另一个栈的排序 */public class SortStackByStack { public static Stack sortStack(Stack&lt;Integer&gt; stack){ Stack&lt;Integer&gt; help = new Stack&lt;&gt;(); while (!stack.isEmpty()){ int cur = stack.pop(); while(!help.isEmpty() &amp;&amp; cur &gt; help.peek()){ stack.push(help.pop()); } help.push(cur); } while (!help.isEmpty()){ stack.push(help.pop()); } return stack; } public static void main(String[] args) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(2); stack.push(1); stack.push(8); stack.push(7); stack.push(3); stack.push(4); stack.push(4); stack = sortStack(stack); int size = stack.size(); for (int i = 0; i &lt; size; i++) { System.out.println(stack.pop()); } }} 2.数组中元素与下一个比它大的元素之间的距离力扣（Medium） 12Input: [73, 74, 75, 71, 69, 72, 76, 73]Output: [1, 1, 4, 2, 1, 1, 0, 0] 说明：对于此题，提供两种解法，详情见下面代码 方法一：暴力求解,时间复杂度O(N^2) 12345678910111213141516171819202122232425262728293031323334/** * 时间复杂度为O(N^2),每个位置向右遍历一下即可 */public class DailyTemperature2 { public static int[] rightWay(int arr[]){ int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) { int cur = i+1; int rightMoreIndex = 0; while (cur &lt; arr.length){ if (arr[cur] &gt; arr[i]){ res[i] = cur - i; break; } cur++; } } return res; } //写个main方法测试一下 public static void main(String[] args) { int[] arr = {73,74,75,71,69,72,76,73}; int[] res = rightWay(arr); for (int re : res) { System.out.println(re); } }} 方法二：遍历数组时，使用栈把数组的下标存起来,时间复杂度O(N) 思路分析： 123456789/** * 1.用dist数组存放距离当前位置的距离，用stack存放原始数组temperature的下标 * 2.用cur指向temperature数组的下标，pre指向stack栈的栈顶元素 * * 3.如果stack不为空，并且当前遍历的数temperature[cur] 大于 栈顶对应的数temperature[stack.peek()]， * 就将stack的栈顶元素弹出，存到pre变量中，cur - pre即为与pre的距离dist[pre].之后再将cur压入stack中。 * 4.如果stack为空，直接将cur压入stack中。 * */ 1234567891011121314151617181920212223242526272829public class DailyTemperatures { public static void main(String[] args) { int[] temperature = {73, 74, 75, 71, 69, 72, 76, 73}; int[] dist = dailyTemperatures(temperature); for (int i : dist) { System.out.print(i+\" \"); } } public static int[] dailyTemperatures(int[] temperatures) { int[] dist = new int[temperatures.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int cur = 0; cur &lt; temperatures.length; cur++) { int pre = 0; while (!stack.isEmpty() &amp;&amp; temperatures[cur] &gt; temperatures[stack.peek()]){ pre = stack.pop(); dist[pre] = cur - pre; } stack.push(cur); } return dist; }} 3.返回数组的最近邻位置（利用单调栈） 题目： 给定一个不含重复值的数组arr,找到每一个位置i左边和右边离i位置最近且值比arr[i]小的位置，返回左右位置的相应信息 举例： 123456789101112intput: arr = {3,4,1,5,6,2,7}output: { {-1,2}, {0,2}, {-1,-1}, {2,5}, {3,5}, {2,-1}, {5,-1}, } 解答：方法一 本题实现复杂度为O(N^2)的解释非常容易的，每个位置向左和向右遍历一下，总可以确定，见以下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MonotoneStack { public static int[][] rightWay(int[] arr){ int[][] res = new int[arr.length][2]; for (int i = 0; i &lt; arr.length; i++) { int leftLessIndex = -1; int rightLessIndex = -1; int cur = i-1; while (cur &gt;= 0){ if (arr[cur] &lt; arr[i]){ leftLessIndex = cur; break; } cur--; } cur = i+1; while (cur &lt; arr.length){ if (arr[cur] &lt; arr[i]){ rightLessIndex = cur; break; } cur++; } res[i][0] = leftLessIndex; res[i][1] = rightLessIndex; } return res; } public static void printArr2(int[][] arr){ for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[0].length; j++) { System.out.print(arr[i][j]+\" \"); } System.out.println(\"\"); } } public static void main(String[] args) { int[] arr = {3,4,1,5,6,2,7}; int[][] res = rightWay(arr); printArr2(res); }} 方法二：利用单调栈结构，时间复杂度为O(N) 思路分析： 12345678910111213141516171819202122232425/** * 单调栈——返回最近邻的位置 * * 准备一个栈，记为Stack&lt;integer&gt;,栈中存放的元素是数组的位置，开始stack为空，如果找到每一个位置i左边 * 和右边离i位置最近且值比arr[i]小的位置，那么需要让stack从栈顶到栈底的位置所代表的值是递减的(也就是从大到小)； * 如果找到每一个位置i左边和右边离i位置最近且值比arr[i]大的位置，那么需要让stack从栈顶到栈底的位置所代表的值是递增的。 * 本题需要解决是前者。 * 下面举例展示单调栈的使用和求解流程，以arr = {3,4,1,5,6,2,7}为例。 * 1.初始时，arr = {3,4,1,5,6,2,7},stack为空。 * 2.遍历arr数组，遍历到arr[0] = 3时，stack为空，直接将0压入stack中，此时，stack中从栈顶到栈底为{0(值为3)} * 3.遍历到arr[1]=4时，`arr[1] &gt; arr[stack.peek()]`，将1压入到stack中，此时，stack从栈顶到栈底为 * {1(值为4)，0(值为3)} * 4.遍历到arr[2] = 1时，如果将下标2压入stack中，会破坏stack从栈顶到栈底所代表的的值是递减的规律， * 那么，此时将stack的栈顶元素\"1\"弹出，位置1左边比它代表的值小的下标即为此时stack栈的栈顶元素\"0\"， * 位置1右边比它代表的值小的下标，即为当前遍历的下标\"2\"，那么res[1] = {0,2}。此时，stack从栈顶到栈底为{0(值为3)}， * 如果将下标2压入stack中，依旧会破坏stack从栈顶到栈底的元素所代表的值是递减的规律，此时将stack的栈顶元素\"0\"弹出，stack栈已经空了， * 位置0左边不存在比它小的数，默认取-1，位置0右边比它代表的值小的下标，即为当前遍历的下标\"2\"，那么res[0] = {-1,2}。 * 这时，stack为空，将\"2\"压入stack中，stack从栈顶到栈底的元素为{2(值为1)} * 5.按照此规律继续遍历下去...... * 6.遍历阶段结束后，stack从栈顶到栈底的元素为{6(值为7),5(值为2),2(值为1)}。 * 下面清算stack中剩下的元素，将stack的栈顶元素\"6\"弹出，栈中它的下面位置是5，而由于6位置是清算阶段弹出的，所以res[6] = {5,-1}; * 弹出5位置，栈中它的下面位置是2,5位置是清算阶段弹出的，所以res[5] = {2,-1}; * 弹出2位置，栈中它的下面没有位置了,2位置是清算阶段弹出的，所以res[2] = {-1,-1}; * */ 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 单调栈——返回最近邻的位置 */public class MonotoneStack2 { public static int[][] getNearLessNoRepeat(int[] arr){ int[][] res = new int[arr.length][2]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); //遍历阶段 for (int i = 0; i &lt; arr.length; i++) { while (!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[stack.peek()]){ int popIndex = stack.pop(); int leftLessIndex = stack.isEmpty() ? -1 : stack.peek(); res[popIndex][0] = leftLessIndex; res[popIndex][1] = i; } stack.push(i); } //开始清算阶段 while(!stack.isEmpty()){ int popIndex = stack.pop(); int leftLessIndex = stack.isEmpty() ? -1 : stack.peek(); res[popIndex][0] = leftLessIndex; res[popIndex][1] = -1; } return res; } public static void printArr2(int[][] arr){ for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[0].length; j++) { System.out.print(arr[i][j]+\" \"); } System.out.println(\"\"); } } public static void main(String[] args) { int[] arr = {3,4,1,5,6,2,7}; int[][] res = getNearLessNoRepeat(arr); printArr2(res); }} 4.滑动窗口最大值LeetCode题目链接 题目 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 思路分析 参考：程序员代码面试指南第2版（18-20），左程云著 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.Arrays;import java.util.LinkedList;/** * 获取滑动窗口的最大值，使用双端队列 */public class MaxWindow { public int[] getMaxWindow(int[] arr,int w){ int[] res = new int[arr.length-w+1]; // res数组用来放每个滑动窗口的最大值 LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;&gt;(); //qmax 可以理解为一个双向的队列结构，用来放arr的下标 //qmax从队列头到队列尾应该是单调递减的 //qmax的队列头始终保存当前滑动窗口的最大值 int index = 0; //res数组的下标 for (int i = 0; i &lt; arr.length; i++) { //当双向递减队列不为空，并且当前的arr[i] 大于等于 arr[队列尾部(下标)] //就将队列尾部元素弹出 while (!qmax.isEmpty() &amp;&amp; arr[i] &gt;= arr[qmax.peekLast()]){ qmax.pollLast(); } //程序走到此处，说明队列为空，或者，arr[i] &lt; arr[qmax.peekLast()] //此时将下标i加到队列尾部 qmax.addLast(i); if (qmax.peekFirst() == i-w){ //说明qmax的队列头已经过期了，或者说滑动窗口已经滑动到下一个位置了，必须更新队列头 qmax.pollFirst(); } if (i &gt;= w-1){ //当i==2,到达第一个滑动窗口，更新res[] res[index++] = arr[qmax.peekFirst()]; } } return res; } //------------main----------- public static void main(String[] args) { MaxWindow window = new MaxWindow(); int[] arr = {4,3,5,4,3,3,6,7}; int[] maxWindow = window.getMaxWindow(arr, 3); System.out.println(Arrays.toString(maxWindow)); }} 5.前 K 个高频元素LeetCode题目链接 题目 12345678910111213141516给定一个非空的整数数组，返回其中出现频率前 k 高的元素。示例 1:输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]示例 2:输入: nums = [1], k = 1输出: [1]提示：你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。你可以按任意顺序返回答案。 思路分析 题目最终需要返回的是前 k 个频率最大的元素，可以想到借助堆这种数据结构，对于 k 频率之后的元素不用再去处理， 进一步优化时间复杂度。 具体操作为： 借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率维护一个元素数目为 k 的最小堆每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中最终，堆中的 k个元素即为前 k 个高频元素 参考：程序员吴师兄 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;public class TopKFrequent { public int[] topK(int[] nums,int k){ HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) { if (map.containsKey(num)){ //如果包含num map.put(num,map.get(num)+1); //将value的值+1 }else { map.put(num,1); } } //上面循环结束，统计到了每个num出现的次数，key=num,value=frequency // 遍历map，用最小堆保存出现频率最大的前k个元素 PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return map.get(o1)-map.get(o2); } }); Set&lt;Integer&gt; keySet = map.keySet(); for (Integer key : keySet) { if (priorityQueue.size() &lt; k){ priorityQueue.add(key); }else if (map.get(key) &gt; map.get(priorityQueue.peek())){ priorityQueue.remove(); priorityQueue.add(key); } } int[] res = new int[k]; int index = res.length-1; while (!priorityQueue.isEmpty()){ res[index--] = priorityQueue.remove(); } return res; } //-----------main--------- public static void main(String[] args) { TopKFrequent topK = new TopKFrequent(); int[] nums = {1,1,1,2,2,3}; int[] res = topK.topK(nums,2); System.out.println(Arrays.toString(res)); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"}]},{"title":"Leetcode题解-栈和队列","slug":"Leetcode题解-栈和队列","date":"2021-08-02T07:38:51.000Z","updated":"2021-08-16T08:28:27.508Z","comments":true,"path":"posts/b04a.html","link":"","permalink":"https://www.colorfo.top/posts/b04a.html","excerpt":"","text":"1.用栈实现队列栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class StackForQueue { //首先准备两个栈 private Stack&lt;Integer&gt; in = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; out = new Stack&lt;&gt;(); //首先将元素压入第一个栈 public void push(Integer val){ in.push(val); } //将入栈的数据弹出，压入出栈中 //在这个过程中，必须保证出栈为空 public void in2out(){ if (out.isEmpty()){ //如果出栈为空，才操作 while(!in.isEmpty()){ out.push(in.pop()); } } } //相当于一个出队列的操作 public int pop(){ //先将 入栈 中的数据 压入到出栈中，这样，经过栈的两次“先进后出”，就实现了队列的“先进先出” in2out(); return out.pop(); } //查看当前的队列的头 public int peek(){ in2out(); return out.peek(); } //判断队列是否为空 public boolean isEmpty(){ return in.isEmpty() &amp;&amp; out.isEmpty(); } //编写一个main方法测试一下结果 *********************************************** public static void main(String[] args) { StackForQueue queue = new StackForQueue(); for (int i = 1; i &lt;= 8; i++) { queue.push(i); } for (int i = 0; i &lt; 8; i++) { System.out.println(queue.pop()); } }} 2.用队列实现栈在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 在队列这种数据结构中，最先插入的元素将是最先被删除的元素； * 反之最后插入的元素将是最后被删除的元素，因此队列又称为“先进先出”（FIFO—first in first out）的线性表。 * * Queue用法小结： * Queue使用时要尽量避免Collection的add()和remove()方法， * 而是要使用offer()来加入元素，使用poll()来获取并移出元素。 * 它们的优点是通过返回值可以判断成功与否。 * 而add()和remove()方法在失败的时候会抛出异常。 * 如果要使用前端而不移出该元素，使用element()或者peek()方法。 */public class QueueForStack { private Queue&lt;Integer&gt; queue; public QueueForStack(){ //LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用 queue = new LinkedList&lt;&gt;(); } public void push(int val){ //首先将val加入到队列中，此时，val位于队列的最后一位 queue.offer(val); //获取队列的大小 int count = queue.size(); while (count &gt; 1){ //将当前队列的除val之外的所有元素，先取出队列，再放入队列 //此时，val就位于队列的首位，那么，就实现了栈的“后进先出” queue.offer(queue.poll()); count--; } } public int pop(){ return queue.poll(); } public int peek(){ //查看当前的队列头 return queue.peek(); } public boolean isEmpty(){ return queue.isEmpty(); } //编写一个main方法，测试一下 ***************************************** public static void main(String[] args) { QueueForStack queue = new QueueForStack(); for (int i = 1; i &lt;= 8; i++) { queue.push(i); } for (int i = 0; i &lt; 8; i++) { System.out.println(queue.pop()); } }} 3.最小值栈：设计一个有getMin功能的栈 题目：实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作 要求： 1.pop,push,getMin操作的时间复杂度都是O(1) 设计的栈类型可以使用现成的栈结构 思路分析：在设计时，使用两个栈，一个栈用来保存所有的元素，其功能和一个正常的栈没有区别，这个栈记为dataStack. 另一个用来保存每一步的最小值，这个栈的栈针始终指向当前放入栈中元素的最小值，这个栈记为minStack. 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MyMinStack { private Stack&lt;Integer&gt; dataStack; private Stack&lt;Integer&gt; minStack; public MyMinStack(){ dataStack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); } public void push(int data){ dataStack.push(data); //当minStack为空时，放入data if (minStack.isEmpty()){ minStack.push(data); }else { //当minStack不为空时,如果minStack的栈顶元素大于data时， // 将data放入minStack,此时就能保证,minStack的栈顶元素为dataStack的最小值 if(minStack.peek() &gt; data){ minStack.push(data); } } } public int pop(){ if (dataStack.isEmpty()){ throw new RuntimeException(\"Your Stack is empty!!!\"); } return dataStack.pop(); } public int getMin(){ if (minStack.isEmpty()){ throw new RuntimeException(\"Your Stack is empty!\"); } return minStack.peek(); } public boolean isEmpty(){ return dataStack.isEmpty(); } //编写一个main测试一下****************************************** public static void main(String[] args) { MyMinStack stack = new MyMinStack(); stack.push(1); stack.push(3); stack.push(5); stack.push(2); stack.push(2); stack.push(4); stack.push(1); stack.push(8); stack.push(2); System.out.println(stack.getMin()); //1 }} ​ 对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。 4. 用栈实现括号的匹配（Easy）力扣 12345678910case1:Input:\"()[]{}\"Output : true case2:Input:\"({})\"Output : true 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 用栈实现括号的匹配 * * Input:\"()[]{}\" * * Output : true */public class ValidParentheses { private Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); public boolean isValid(String s){ for (char c : s.toCharArray()){ if (c == '(' || c == '{' || c == '['){ //当满足\"左括号\"的条件时，压入栈中 stack.push(c); }else{ //如果此时栈中还为空，则不满足条件 if (stack.isEmpty()){ return false; } //走到这一步，说明栈中不为空，此时\"c\"，满足为括号的右半部分 //此时弹栈拿出括号的坐半部分left char left = stack.pop(); //以下三个条件说明，在弹栈得到的left时,括号右半部分匹配不上，就返回false; boolean b1 = left == '(' &amp;&amp; c != ')'; boolean b2 = left == '{' &amp;&amp; c != '}'; boolean b3 = left == '[' &amp;&amp; c != ']'; if (b1 || b2 || b3){ return false; } } } return stack.isEmpty(); } //测试 ******************************* public static void main(String[] args) { ValidParentheses vp = new ValidParentheses(); System.out.println(vp.isValid(\"()\")); //true System.out.println(vp.isValid(\"()[]{}\")); //true System.out.println(vp.isValid(\"{[]}\")); //true System.out.println(vp.isValid(\"(]\")); //false System.out.println(vp.isValid(\"([)]\")); //false }} 5.逆波兰表达式求值leetcode题目链接 题目 12345678910111213141516171819202122根据 逆波兰表示法，求表达式的值。有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。说明：整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。示例 1：输入: [\"2\", \"1\", \"+\", \"3\", \" * \"]输出: 9解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9示例 2：输入: [\"4\", \"13\", \"5\", \"/\", \"+\"]输出: 6解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6示例 3：输入: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \" * \", \"/\", \" * \", \"17\", \"+\", \"5\", \"+\"]输出: 22 思路分析 遍历String[] tokens ,如果tokens[i] 是数字，则直接压入栈中， 如果是“+”，“-”，“*”，“/”运算符，则从栈中弹出两个数字，然后再把计算结果压入栈中 最后返回栈中的数字，即为最后的运算结果 注意：1.如果是运算符是“-”，“/”,注意计算的顺序 2.String的比较要用equals()方法 3.char类型的比较可以使用“==” 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 逆波兰表达式求值 */public class EvaluateReversePolishNotation { public int evalRPN(String[] tokens){ Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; tokens.length; i++) { // 遍历tokens数组 if(tokens[i].equals(\"+\") || tokens[i].equals(\"-\") || tokens[i].equals(\"*\") || tokens[i].equals(\"/\")){//如果是加减乘除字符 //如果是操作符，直接弹出两个数字，准备进行运算 int num1 = stack.pop(); int num2 = stack.pop(); if (tokens[i].equals(\"+\")){ stack.push(num1+num2); }else if (tokens[i].equals(\"-\")){ stack.push(num2-num1); }else if (tokens[i].equals(\"*\")){ stack.push(num1*num2); }else{ stack.push(num2 / num1); } }else{ //如果是数字的话，直接压入 stack.push(stoi(tokens[i])); } } return stack.pop(); } private Integer stoi(String token) { // 将String转为Integer return Integer.valueOf(token); } //--------------main----------- public static void main(String[] args) { EvaluateReversePolishNotation RPN = new EvaluateReversePolishNotation(); /** * 该算式转化为常见的中缀算术表达式为： * ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 * = ((10 * (6 / (12 * -11))) + 17) + 5 * = ((10 * (6 / -132)) + 17) + 5 * = ((10 * 0) + 17) + 5 * = (0 + 17) + 5 * = 17 + 5 * = 22 */ int i = RPN.evalRPN(new String[]{\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"}); System.out.println(i); //转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 int i1 = RPN.evalRPN(new String[]{\"4\", \"13\", \"5\", \"/\", \"+\"}); System.out.println(i1); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://www.colorfo.top/tags/%E9%98%9F%E5%88%97/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.colorfo.top/tags/LeetCode/"}]},{"title":"利用数组实现栈","slug":"利用数组实现栈","date":"2021-08-01T13:20:26.000Z","updated":"2021-08-01T14:51:43.284Z","comments":true,"path":"posts/c93a.html","link":"","permalink":"https://www.colorfo.top/posts/c93a.html","excerpt":"","text":"本例子利用数组实现”栈”这种数据结构，算一个栈的入门案例 栈的特点：先进后出，后进先出 在实现栈的弹栈，压栈的操作之前，要判断栈是否为空栈或满栈 数组的长度即为栈的容量 写一个ArrayForStack类，在这个类中，实现栈的弹栈、压栈等方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ArrayForStack { private int maxSize; private int[] array; //栈针 private int top = -1; public ArrayForStack(){ } //有参构造方法，利用构造方法给属性赋值 public ArrayForStack(int maxSize){ this.maxSize = maxSize; this.array = new int[maxSize]; } public boolean isEmpty(){ return top == -1; } public boolean isFull(){ return top == maxSize-1; } public void push(int num) throws Exception { if (isFull()){ throw new Exception(\"栈已经满了，不能继续压栈了\"); } array[++top] = num; } public int pop() throws Exception { if (isEmpty()){ throw new Exception(\"栈已经空了，不能弹栈\"); } int temp; temp = array[top--]; return temp; }} 编写一个测试类，测试栈的方法 12345678910111213141516171819public class StackTest { public static void main(String[] args) throws Exception { //栈的容量 int maxSize = 6; ArrayForStack stack = new ArrayForStack(maxSize); //压栈 for (int i = 0; i &lt; maxSize; i++) { stack.push(i); //依次压入0 1 2 3 4 5 } //弹栈 for (int i = 0; i &lt; maxSize; i++) { System.out.println(stack.pop()); //依次弹出5 4 3 2 1 0 } }} 接下来利用上面编写的ArrayForStack类，再实现一个回文字符串判断的例子 所谓的回文字符串即为：从左往右 与 从右往左 读这个字符串，结果是一样的 比如：”aba”就是一个回文串，而:”hello”,从右往左为”olleh”,则”hello”不是一个回文串 1234567891011121314151617181920212223242526272829303132public class TestPalindrome { public static void main(String[] args) throws Exception { System.out.println(detection(\"abcdedcba\")); //true } public static boolean detection(String str) throws Exception { int length = str.length(); ArrayForStack stack = new ArrayForStack(length); for (int i = 0; i &lt; length; i++) { stack.push(str.charAt(i)); } String newStr = \"\"; for (int i = 0; i &lt; length; i++) { if (!stack.isEmpty()){ char s = (char)stack.pop(); newStr += s; } } if (str.equals(newStr)){ return true; } return false; }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"},{"name":"数组","slug":"数组","permalink":"https://www.colorfo.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"回文","slug":"回文","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%96%87/"}]},{"title":"github高效搜索项目","slug":"github高效搜索项目","date":"2021-07-31T08:56:16.000Z","updated":"2021-07-31T09:18:54.323Z","comments":true,"path":"posts/2a1b.html","link":"","permalink":"https://www.colorfo.top/posts/2a1b.html","excerpt":"","text":"利用项目名(仓库名) 例如in:name spring boot 利用项目名+stars in:name spring boot stars:&gt;1000 利用项目名+stars+forks in:name spring boot stars:&gt;1000 forks:&gt;100 利用readme in:readme springboot 利用readme+stars in:readme springboot stars:&gt;1000 利用description in:description 微服务 利用description + language in:description 微服务 language:java 利用description + language+日期 in:description 微服务 language:java pushed:&gt;2019-9-9 点进去查看项目的：描述利用了那些技术，代码结构、最新push日期、火热程度等，查看项目的readme文档 把github用起来，多去github看开源项目","categories":[],"tags":[{"name":"github搜索","slug":"github搜索","permalink":"https://www.colorfo.top/tags/github%E6%90%9C%E7%B4%A2/"}]},{"title":"git和github的使用","slug":"git和github的使用","date":"2021-07-30T08:42:22.000Z","updated":"2021-07-31T06:57:42.597Z","comments":true,"path":"posts/ec43.html","link":"","permalink":"https://www.colorfo.top/posts/ec43.html","excerpt":"","text":"[toc] git1.Git常用命令 2.分支的操作 3.远程仓库操作 4.IDEA集成git、github 1.确保idea已经集成了git和github 2.回到idea主界面，创建一个git repository 3.将代码加入暂存区 代码加入暂存区后，文件名由红色变为蓝色 4.将代码提交至本地库 代码提交至本地库后，文件名由蓝色变为正常的白色 5.查看git的log和master信息 切换version 创建分支 6.合并分支 在hot_fix分支下，加一行代码，并提交至本地库 注意：master分支想要合并hot_fix分支，必须在master分支下merge 已经切换至master 开始合并 成功合并 备注：以上演示的为无冲突合并，如果遇到冲突合并(简单理解为：对代码做了不同的修改)，需要进行手动选择代码，然后合并 7.将代码推送至远程github仓库 7.1 使用ssh免密登陆 进入C:/Users/Administrator/.ssh文件夹，右键选择“Git Bash Here ” 在命令行输入ssh-keygen -t rsa -C 邮箱 ，连续三次回车(其中有一次问你，要不要覆盖文件) 然后输入cat id_rsa.pub ,得到其文件内容，如下图 复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys →New SSH key 新建一个SSH key 7.2新建一个远程github仓库，用来储存来自本地仓库的代码，如下图 方式二，新建github仓库 7.3push代码到github仓库 push代码的重要提示 注意： push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说， 要想 push 成功，一定要保证本地库的版本要比远程库的版本高！ 因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送！ 8 pull 拉取远程库到本地库 首先更新一下github仓库的代码，以示本地和远程的区别 9.克隆代码到本地，并利用idea打开","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.colorfo.top/tags/git/"},{"name":"github","slug":"github","permalink":"https://www.colorfo.top/tags/github/"}]},{"title":"springboot集成mybatis-plus","slug":"springboot集成mybatis-plus","date":"2021-07-28T05:05:31.000Z","updated":"2021-07-28T11:29:26.531Z","comments":true,"path":"posts/667f.html","link":"","permalink":"https://www.colorfo.top/posts/667f.html","excerpt":"","text":"本博客基于springboot-web项目，集成thymeleaf，和mybatis-plus可以实现数据的CRUD和分页显示数据功能 案例一：实现数据的CRUD 依赖及配置 1.新建一个springboot-web项目，并选中thymeleaf模板引擎 2.加入依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 3.配置mysql的账号密码 1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=mysql密码 代码详情 1.控制层代码 1234567891011121314151617181920@Controllerpublic class MybatisController { //自动注入业务层的StudentService @Autowired private StudentService studentService; @RequestMapping(\"/queryAll\") //请求路径 public String queryAll(Model model){ //调用业务层的方法，查询所有学生 List&lt;Student&gt; students = studentService.list(); model.addAttribute(\"students\",students); //将查询结果放入request作用域，并返回到视图层 return \"mybatis-plus\"; }} 2.业务层代码(包括一个接口和实现类) 1234public interface StudentService extends IService&lt;Student&gt; { //IService&lt;T&gt; 中的 T 是实体} IService为mybatis-plus提供的接口，里面提供了CRUD的基本方法,我们的业务层接口需要实现IService这个接口 3.业务接口实现类 12345@Servicepublic class StudentServiceImpl extends ServiceImpl&lt;StudentMapper, Student&gt; implements StudentService { //ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; 中的泛型：M 是 mapper 对象，T 是实体} StudentServiceImpl 继承了ServiceImpl，而ServiceImpl是IService 实现类，它提供了IService中方法的具体实现。我们写的业务接口实现类需要继承ServiceImpl这个类，并且要实现我们自己写的StudentService这个接口 下面给出ServiceImpl类的部分代码 12//IService 实现类（ 泛型：M 是 mapper 对象，T 是实体 ）public class ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; implements IService&lt;T&gt; {} 4.持久层代码 1234@Mapperpublic interface StudentMapper extends BaseMapper&lt;Student&gt; {} StudentMapper继承了 BaseMapper这一接口，当我们编写的Mapper接口 继承该接口后，无需编写 mapper.xml 文件，即可获得CRUD功能 说明：除了在该类的上面添加@Mapper,注明这是一个持久层之外，还可以在程序的主入口添加@MapperScan注解(两个注解选择一个使用即可) 5.实体类 1234567891011121314151617@TableName(\"t_student\")public class Student { @TableField(exist = false) private String email; private Integer id; private String name; private Integer age; setter and getter toString } @TableName(“t_student”)由mybatis-plus提供，作用使该实体类与对应的数据库中的表名对应，例如类Student&lt;===&gt;表t_student @TableField(exist = false)由mybatis-plus提供,作用是标注出，数据库中的表不存在该字段 5.视图层的代码(由控制层转到视图层mybatis-plus.html) 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;查询所有学生&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div &gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"student:${students}\"&gt; &lt;!--thymeleaf循环一个list--&gt; &lt;td&gt;[[${student.id}]]&lt;/td&gt; &lt;!--thymeleaf的行内写法，取出相应的变量--&gt; &lt;td&gt;[[${student.name}]]&lt;/td&gt; &lt;td&gt;[[${student.age}]]&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6查询结果 与数据库中的数据一致 案例二：实现分页数据的展示 数据的分页展示，在案例一的基础上修改而来 分页功能具体实现 1.新建一个配置类，用来加载分页插件 123456789101112@Configuration//@Deprecatedpublic class MyBatisPlusConfig { @Bean public PaginationInterceptor paginationInterceptor() { System.out.println(\"加载分页插件\"); return new PaginationInterceptor(); }} 2.修改控制层代码 12345678910111213141516171819202122232425@Controller@Slf4jpublic class MybatisController { @Autowired private StudentService studentService; @RequestMapping(\"/queryAll\") public String queryAll(@RequestParam(value = \"pn\",defaultValue = \"1\") Integer pn, Model model){ //分页查询，pn表示当前页，6表示每页几条数据 Page&lt;Student&gt; studentPage = new Page&lt;&gt;(pn,6); //分页查询结果 Page&lt;Student&gt; page = studentService.page(studentPage, null); page.getCurrent(); //获取当前页 page.getPages(); //获取总的页数 page.getTotal(); //获取总记录数 model.addAttribute(\"page\",page); return \"mybatis-plus\"; }} 访问路径为“/queryAll”,请求参数为pn,表示当前页，默认为1 调用studentService.page(),即可得到Page对象，其内部属性，就是我们想要的与分页功能相关的数据 将page放入request作用域 3.修改视图显示的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;查询所有学生&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div &gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"student:${page.records}\"&gt; &lt;!--thymeleaf循环一个list--&gt; &lt;td&gt;[[${student.id}]]&lt;/td&gt; &lt;!--thymeleaf的行内写法，取出相应的变量--&gt; &lt;td&gt;[[${student.name}]]&lt;/td&gt; &lt;td&gt;[[${student.age}]]&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;br&gt; &lt;!--上方展示的student详情的list集合，必须从page.records中取--&gt; &lt;!--#########################以下内容与分页功能相关###############################--&gt; &lt;!--[[${page.current}]]为thymeleaf的写法，可以取出request域的变量--&gt; &lt;!--page.current、page.pages、page.total都是放在request作用域中的变量page的属性}--&gt; &lt;div&gt;当前第 [[${page.current}]] 页 总计 [[${page.pages}]] 页 共 [[${page.total}]] 条记录&lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;!--#numbers.sequence(1,page.pages)，该表达式是thymeleaf的写法。 表示可以生成一个从\"1\"到\"page.pages\"的序列,然后用thymeleaf的foreach循环，就可以得到页码num了--&gt; &lt;li th:each=\"num:${#numbers.sequence(1,page.pages)}\" &gt; &lt;!--下面的写法为thymeleaf的超链接写法 [[${num}]]用来显示页码数 @{/queryAll(pn=${num})}表示超链接的链接地址,(pn=${num})表示请求参数 @{/queryAll(pn=${num})}等价于@{/queryAll?pn=num} --&gt; &lt;a th:href=\"@{/queryAll(pn=${num})}\"&gt;[[${num}]]&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 前端分页功能代码的说明见注释 结果展示","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/tags/springboot/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://www.colorfo.top/tags/mybatis-plus/"},{"name":"分页","slug":"分页","permalink":"https://www.colorfo.top/tags/%E5%88%86%E9%A1%B5/"}]},{"title":"springboot定制化组件的方式","slug":"springboot定制化组件的方式","date":"2021-07-27T11:58:08.000Z","updated":"2021-07-27T12:17:50.877Z","comments":true,"path":"posts/4e7c.html","link":"","permalink":"https://www.colorfo.top/posts/4e7c.html","excerpt":"","text":"定制化组件的常见方式 修改配置文件； xxxxxCustomizer； 编写自定义的配置类 xxxConfiguration；+ @Bean替换、增加容器中默认组件；视图解析器 Web应用 编写一个配置类实现 WebMvcConfigurer 即可定制化web功能；(+ @Bean给容器中再扩展一些组件,可选的) 12@Configurationpublic class AdminWebConfig implements WebMvcConfigurer{} @EnableWebMvc + WebMvcConfigurer —— @Bean 可以全面接管SpringMVC，所有规则全部自己重新配置； 实现定制和扩展功能 原理 1、WebMvcAutoConfiguration 默认的SpringMVC的自动配置功能类。静态资源、欢迎页….. 2、一旦使用 @EnableWebMvc 会 @Import(DelegatingWebMvcConfiguration.class) 3、DelegatingWebMvcConfiguration 的 作用，只保证SpringMVC最基本的使用 把所有系统中的 WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer 合起来一起生效 自动配置了一些非常底层的组件。RequestMappingHandlerMapping、这些组件依赖的组件都是从容器中获取 public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport 4、WebMvcAutoConfiguration 里面的配置要能生效 必须 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 5、@EnableWebMvc 导致了 WebMvcAutoConfiguration 没有生效。","categories":[],"tags":[{"name":"springboot定制化组件","slug":"springboot定制化组件","permalink":"https://www.colorfo.top/tags/springboot%E5%AE%9A%E5%88%B6%E5%8C%96%E7%BB%84%E4%BB%B6/"}]},{"title":"SpringBoot文件上传","slug":"SpringBoot文件上传","date":"2021-07-27T07:56:20.000Z","updated":"2021-08-01T08:31:15.837Z","comments":true,"path":"posts/c59d.html","link":"","permalink":"https://www.colorfo.top/posts/c59d.html","excerpt":"","text":"[toc] 简介 springboot中文件上传，可以将上传的文件保存到本地，或者保存到文件服务器，OSS 下面通过一个springboot-thymeleaf项目，演示这一过程 项目流程 1.浏览器地址栏访问：http:localhost:8080/,跳转到templates/file_form.html 2.在file_form.html页面，选择需要上传的文件(支持单个、多个文件上传，文件的最大值在配置文件中指定)，提交后转到控制层的upload方法 3.在upload方法中，上传的文件被保存到本地 代码演示 项目文件结构 控制层代码 123456789101112131415161718192021222324252627282930313233@Controllerpublic class MyController { @RequestMapping(\"/\") public String upload(){ return \"file_form\"; } @PostMapping(\"/upload\") @ResponseBody public String upload(@RequestPart(\"picture\") MultipartFile picture, @RequestPart(\"photos\") MultipartFile[] photos) throws IOException { if(!picture.isEmpty()){ String originalFilename = picture.getOriginalFilename(); //保存文件到本地 picture.transferTo(new File(\"E:\\\\test\\\\\"+originalFilename)); } if (photos.length &gt; 0){ for (MultipartFile photo : photos) { if (!photo.isEmpty()){ String originalFilename = photo.getOriginalFilename(); //保存文件到本地 photo.transferTo(new File(\"E:\\\\test\\\\\"+originalFilename)); } } } return \"文件上传成功\"; }} 前端的file_form.html页面 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"post\" th:action=\"@{/upload}\" enctype=\"multipart/form-data\" &gt; 单个文件:&lt;input type=\"file\" name=\"picture\"&gt;&lt;br&gt; 多个文件:&lt;input type=\"file\" name=\"photos\" multiple&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 项目的配置文件 1234# 上传总文件的最大值spring.servlet.multipart.max-request-size=100MB# 单个文件的最大值spring.servlet.multipart.max-file-size=10MB 启动程序 123456789@SpringBootApplicationpublic class SpringbootFileUploadApplication { public static void main(String[] args) { SpringApplication.run(SpringbootFileUploadApplication.class, args); }}","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://www.colorfo.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"Interceptor拦截器的使用","slug":"Interceptor拦截器的使用","date":"2021-07-26T13:43:47.000Z","updated":"2021-07-26T14:37:16.414Z","comments":true,"path":"posts/ce45.html","link":"","permalink":"https://www.colorfo.top/posts/ce45.html","excerpt":"","text":"springboot项目中拦截器的使用 1.编写一个拦截器实现HandlerInterceptor接口 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors） 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】 1.实现HandlerInterceptor接口123456789101112131415161718192021222324252627282930313233@Slf4jpublic class MyInterceptor implements HandlerInterceptor { //目标方法执行之前，进行拦截 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(\"preHandle方法执行了{}\",request.getRequestURI()); String userName = (String) request.getSession().getAttribute(\"userName\"); if(userName != null){ return true; } request.getRequestDispatcher(\"/\").forward(request,response); return false; } //目标方法执行完成之后 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.info(\"postHandle方法执行了{}\",modelAndView); } //页面渲染之后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { log.info(\"afterCompletion方法执行了\"); }} 2.拦截器注册到容器中 实现WebMvcConfigurer的addInterceptors 1234567891011@Configurationpublic class MyConfiguration implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()) .addPathPatterns(\"/**\") //需要拦截的资源 .excludePathPatterns(\"/\",\"/login\"); //需要放行的资源 }} 3.拦截器原理1、根据当前请求，找到HandlerExecutionChain【可以处理请求的handler以及handler的所有 拦截器】 2、先来顺序执行 所有拦截器的 preHandle方法 1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle 2、如果当前拦截器返回为false。直接 倒序执行所有已经执行了的拦截器的 afterCompletion； 3、如果任何一个拦截器返回false。直接跳出不执行目标方法 4、所有拦截器的prehandler都返回true，才执行目标方法 5、倒序执行所有拦截器的postHandle方法。 6、前面的步骤有任何异常都会直接倒序触发 afterCompletion 7、页面成功渲染完成以后，也会倒序触发 afterCompletion","categories":[],"tags":[{"name":"Interceptor","slug":"Interceptor","permalink":"https://www.colorfo.top/tags/Interceptor/"}]},{"title":"springboot集成websocket实现聊天室的index.jsp代码","slug":"springboot集成websocket实现聊天室的index-jsp代码","date":"2021-07-25T06:54:58.000Z","updated":"2021-07-25T13:30:24.709Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://www.colorfo.top/posts/undefined.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"${pageContext.request.contextPath}/js/jquery.min.js\"&gt;&lt;/script&gt; &lt;title&gt;SpringBoot+WebSocket+JSP&lt;/title&gt;&lt;/head&gt;&lt;body style=\"margin: 45px;\"&gt; &lt;h4&gt;在线聊天室&lt;/h4&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"content\"&gt;&lt;/label&gt; &lt;textarea id=\"content\" readonly=\"readonly\" cols=\"80\" rows=\"15\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"form-group\" style=\"margin-top: 8px\"&gt; &lt;textarea id=\"message\" cols=\"80\" rows=\"5\" placeholder=\"请输入消息\"&gt;&lt;/textarea&gt; &lt;div style=\"margin-top: 10px\"&gt; &lt;button id=\"toSend\" class=\"btn btn-info\"&gt;发送&lt;/button&gt; &lt;button id=\"user_exit\" class=\"btn btn-danger\"&gt;离开&lt;/button&gt; &lt;input id=\"username\" value=\"${username}\" style=\"display: none\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; $(function () { var ws; if (\"WebSocket\" in window) { var baseUrl = 'ws://localhost:8080/websocket/'; var userName = $('#username').val(); ws = new WebSocket(baseUrl + userName); // 连通之后的回调事件，建立连接 ws.onopen = function () { console.log(\"建立 websocket 连接...\"); }; // 接收后台服务端的消息 ws.onmessage = function (event) { $('#content').append(event.data + '\\n\\n'); console.log(\"接收到服务端发送的消息...\" + event.data + '\\n'); }; ws.onerror = function (event) { console.log(\"websocket发生错误...\" + event + '\\n'); } // 连接关闭的回调事件 ws.onclose = function () { $('#content').append('[' + userName + '] 已离开!'); console.log(\"关闭 websocket 连接...\"); }; } else { // 浏览器不支持 WebSocket alert(\"您的浏览器不支持WebSocket!\"); } // 客户端发送消息到服务器 $('#toSend').click(function () { sendMsg(); }); $(document).keyup(function (event) { // 回车键事件 if (event.keyCode == 13) { sendMsg(); } }); // 发送消息 function sendMsg() { //websocket发送消息 ws.send($('#message').val()); $('#message').val(\"\"); } // 退出 $('#user_exit').click(function () { if (ws) { ws.close(); } }); }); &lt;/script&gt;&lt;/body&gt;&lt;%--此页面的源代码即为index.jsp的代码--%&gt;&lt;%--点击右键即可查看网页源代码--%&gt;&lt;/html&gt;","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"}]},{"title":"springboot集成websocket实现聊天室","slug":"springboot集成websocket实现聊天室","date":"2021-07-25T04:04:39.000Z","updated":"2021-07-25T13:30:26.881Z","comments":true,"path":"posts/3a35.html","link":"","permalink":"https://www.colorfo.top/posts/3a35.html","excerpt":"","text":"1.websocket简介WebSocket协议WebSocket协议是由HTML5定义的，基于TCP协议实现的一种网络协议，通过该协议服务器可以主动向客户端发送信息； WebSocket 协议在2008年诞生，2011年成为W3C国际标准；我们已经有了 HTTP 协议，为什么出现一个websocket协议？ http协议是短连接，因为请求之后，都会关闭连接，下次重新请求数据，需要再次打开链接；WebSocket协议是一种长连接，只需要通过一次请求来初始化连接，然后所有的请求和响应都是通过这个TCP连接进行通讯； 所以HTTP协议通信只能是客户端向服务器发出请求，服务器返回响应结果，HTTP 协议做不到服务器主动向客户端推送信息，而websocket能实现服务器和客户端全双工通信； 何谓全双工 信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工，信息能够同时双向传送则称为全双工； 基本实现原理 WebSocket协议基于TCP协议实现，客户端和服务器只需要做一个握手的动作之后，形成了一条基于客户端和服务器之间的快速通道，之后客户端与服务端之间便可以进行多次数据帧双向传输；这样实现的目的是客户端和服务器进行频繁双向通信时，可以使服务器避免频繁创建HTTP连接，节约资源，提高工作效率和资源利用率。 传统Web推送实现​ 在没有WebSocket协议之前，服务器如何向浏览器端推送消息？通常的实现方式是在页面通过Ajax定时轮询，比如每隔1秒中向服务器发送一次HTTP请求，询问服务器是否有新消息，服务器返回结果；这种形式缺点很明显，浏览器需要不断的向服务器发出HTTP请求，而HTTP请求包含较长的头部，有效信息相对较少，反复的无效请求占用了大量的带宽和 CPU 资源，造成很大的浪费，所以，WebSocket 应运而生；HTML5定义的WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯； WebSocket协议本质上是一个基于TCP的协议，因此与HTTP协议没有什么关系； WebSocket的特点全双工通信，客户端和服务器可以双向平等通信； 建立在TCP协议之上，服务器端的实现比较容易； 数据格式比较轻量，性能开销小，通信高效； 可以发送文本，也可以发送二进制数据； 通信具有更强的实时性； 协议标识符是ws，服务器地址就是：ws://www.abc.com/some/path http协议： http:// websocket的业务场景WebSocket聊天室； 股票实时价格显示等应用； 即时通讯、游戏、可视化大屏展示等领域； 企业内部管理通讯等功能，主要通讯协议websocket； web网页聊天、客服系统实现； 系统提醒、用户上下线提醒、客户端同步，实时数据更新，多屏幕同步，用户在线状态，消息通知，扫描二维码登录/二维码支付，弹幕、各类信息提醒，在线选座，实时监控大屏等等； Java中的WebSocket API在Java EE 7中Java语言开始支持websocket协议，Java EE 7中定义了一套Websocket API规范，也就是一系列接口，没有实现，位于包javax.websocket下，包含客户端API和服务端API，WebSocket的Java API 只是规范，具体实现需要web容器（比如tomcat就实现了Java websocket api）、Java EE服务器或者框架提供； 在java中服务端的实现 1、Tomcat：java中的websocket实现，需要tomcat 7.0.47+以上才支持， Java EE7的支持； 2、Spring的websocket，需要Spring 4.x，所以springboot也可以用； 2.Websocket开发相关注解及API方法websocket注解 @ServerEndpoint(“/websocket/{uid}”) 申明这是一个websocket服务； 需要指定访问该服务的地址，在地址中可以指定参数，需要通过{}进行占位； @OnOpen 用法：public void onOpen(Session session, @PathParam(\"uid\") String uid) throws IOException{} 该方法将在建立连接后执行，会传入session对象，就是客户端与服务端建立的长连接通道，通过@PathParam获取url中声明的参数； @OnClose 用法：public void onClose() {} 该方法是在连接关闭后执行； @OnMessage 用法：public void onMessage(String message, Session session) throws IOException {} 该方法用于接收客户端发送的消息； message：发来的消息数据； session：会话对象（也是长连接通道）； 发送消息到客户端； 用法：session.getBasicRemote().sendText(\"hello,websocket.\"); 通过session进行消息发送； 前端技术对websocket的支持Websocket是html5规范，主流浏览器都支持；（某些老浏览器不支持） jQuery、vueJS、React JS、angularjs等都可以支持webscoket对象； 底层是javascript支持的一个webscoket的js对象，通过这个对象可以建立websocket的连接：ws://localhost:8080/websocket/12345 WebSocket有很多优点，弥补了http协议的不足，但是如果服务端维护很多长连接也是很耗费资源的，服务器集群带来了复杂性以及存在老版本浏览器兼容性问题，各大厂目前大多数还是基于轮询的方式实现的，比如：扫码登录、支付成功通知、秒杀成功通知等； 在秒杀场景中，用轮询即可，前端轮询一般不可能穿透到后端数据库查询，一般是采用高性能的缓存标记来判定秒杀是否成功，相对于websocket长连接以及其不确定因素，轮询依然是相对比较合适的方案； Websocket各浏览器的支持情况： https://caniuse.com/#search=websocket 3.springboot集成WebSocket实现多人聊天室 项目代码结构分布 pom文件依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;!--此项目的GAV坐标--&gt; &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt; &lt;artifactId&gt;041-springboot-websocket&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--springboot web项目的起步依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--spring-boot-starter-websocket--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok,需要在IDEA中安装lombok插件才能使用该依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入Spring Boot内嵌的Tomcat对JSP的解析包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署插件(该依赖不是必选项)--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;!--src/main/java下的.xml配置文件编译到target下去--&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!--src/main/resources下的配置文件编译到target下去--&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!--src/main/webapp下的jsp页面编译到META-INF/resources下才能访问--&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 前端代码 项目的主配置文件application.properties 123#设置jsp文件的前缀和后缀spring.mvc.view.prefix=/spring.mvc.view.suffix=.jsp index.jsp文件详情 1234hexo博客不能正常显示jsp格式的代码代码详情见本站的博文：\"springboot集成websocket实现聊天室的index-jsp代码\"，进入该博文页面后，点击右键即可查看index.jsp的源代码 还需要一个jquery.min.js文件，可以去网上下载 后端代码 后端代码结构 首先是endpoint包下的chatServerEndpoint.java 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.bjpowernode.endpoint;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import javax.websocket.*;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;import java.io.IOException;/** * 说明： * 1、@ServerEndpoint注解中指定WebSocket协议的地址； * 2、@OnOpen、@OnMessage、@OnClose、@OnError注解与WebSocket中监听事件对应 * **/@Slf4j //lombok jar包，帮我们自动生成一些代码：@Data@Component@ServerEndpoint(\"/websocket/{username}\")public class ChatServerEndpoint { /** * 连接建立时触发 */ @OnOpen public void openSession(@PathParam(\"username\") String username, Session session) { log.info(\"用户{}登录\", username); String message = \"用户[\" + username + \"] 已进入聊天室！\"; // 发送登录消息给其他人 WebSocketUtils.sendMessageAll(message); // 获取当前在线人数，发给自己 String onlineInfo = WebSocketUtils.getOnlineInfo(); //发送消息 WebSocketUtils.sendMessage(session, onlineInfo); // 添加自己到map中 WebSocketUtils.CLIENTS.put(username, session); } /** * 客户端接收服务端数据时触发 */ @OnMessage public void onMessage(@PathParam(\"username\") String username, String message) { log.info(\"发送消息：{}, {}\", username, message); //广播，把消息同步给其他客户端 WebSocketUtils.sendMessageAll(\"[\" + username + \"] : \" + message); } /** * 连接关闭时触发 */ @OnClose public void onClose(@PathParam(\"username\") String username, Session session) { // 当前的Session移除某个用户 WebSocketUtils.CLIENTS.remove(username); // 离开消息通知所有人 WebSocketUtils.sendMessageAll(\"[\" + username + \"] 已离开！\"); try { //关闭WebSocket Session会话 session.close(); log.info(\"{} 已退出, onclose\", username); } catch (IOException e) { e.printStackTrace(); log.error(\"onClose error\", e); } } /** * 通信发生错误时触发 */ @OnError public void onError(Session session, Throwable throwable) { try { //关闭WebSocket Session会话 session.close(); } catch (IOException e) { e.printStackTrace(); log.error(\"onError Exception\", e); } log.info(\"Throwable msg \" + throwable.getMessage()); }} endpoint包下的WebSocketUtils.java 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.bjpowernode.endpoint;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.websocket.RemoteEndpoint;import javax.websocket.Session;import java.io.IOException;import java.util.Map;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;public final class WebSocketUtils { private static final Logger logger = LoggerFactory.getLogger(WebSocketUtils.class); /** * 存储WebSocket session * &lt;p&gt; * 用户名为key，WebSocket Session对象为value */ public static final Map&lt;String, Session&gt; CLIENTS = new ConcurrentHashMap&lt;&gt;(); /** * 使用连接发送数据 * * @param session 用户session * @param message 发送内容 */ public static void sendMessage(Session session, String message) { if (session == null) { return; } final RemoteEndpoint.Basic basic = session.getBasicRemote(); if (basic == null) { return; } try { //发送 basic.sendText(message); } catch (IOException e) { e.printStackTrace(); logger.error(\"sendMessage IOException \", e); } } /** * 发送消息给其他所有人 * * @param message */ public static void sendMessageAll(String message) { CLIENTS.forEach((sessionId, session) -&gt; sendMessage(session, message)); } /** * 获取所有在线用户 */ public static String getOnlineInfo() { Set&lt;String&gt; userNames = CLIENTS.keySet(); if (userNames.size() == 0) { return \"当前无人在线...\"; } return CLIENTS.keySet().toString() + \"在线\"; }} 接着是controller包下的ChatController.java文件 1234567891011121314151617181920package com.bjpowernode.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.concurrent.atomic.AtomicInteger;@Controllerpublic class ChatController { private AtomicInteger idProducer = new AtomicInteger(); @RequestMapping(\"/\") public String index(Model model) { model.addAttribute(\"username\",\"user\" + idProducer.getAndIncrement()); return \"index\"; }} 项目启动后，访问根路径，转发到index.jsp 最后是config包下的WebSocketConfig.java文件 123456789101112131415161718192021package com.bjpowernode.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.config.annotation.EnableWebSocket;import org.springframework.web.socket.server.standard.ServerEndpointExporter;@EnableWebSocket //启用WebSocket支持@Configuration //表示配置类public class WebSocketConfig { /** * 配置ServerEndpointExporter的bean * * 该Bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint */ @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); }} 最后的最后，是程序的主入口Application.java，用来启动整个项目 123456789101112package com.bjpowernode;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 项目启动运行 在浏览器地址栏输入http://localhost:8080/ 示例如下 在另一个浏览器地址栏(或者相同浏览器新建一个窗口)输入http://localhost:8080/，即可实现多人聊天","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"}]},{"title":"springboot之-MatrixVariable注解使用","slug":"springboot之-MatrixVariable注解使用","date":"2021-07-24T14:51:43.000Z","updated":"2021-08-26T11:13:51.255Z","comments":true,"path":"posts/80aa.html","link":"","permalink":"https://www.colorfo.top/posts/80aa.html","excerpt":"","text":"简介​ 根据 URI 规范 RFC 3986 中 URL 的定义，路径片段中可以可以包含键值对。规范中没对对应的术语。一般 “URL 路径参数” 可以被应用，尽管更加独特的 “矩阵 URI” 也经常被使用并且相当有名。在 Spring MVC 它被称为矩阵变量。 矩阵变量可以出现在任何路径片段中，每一个矩阵变量都用分号（;）隔开。比如 /cars;color=red;year=2012。多个值可以用逗号隔开，比如color=red,green,blue，或者分开写 color=red;color=green;color=blue。 如果你希望一个 URL 包含矩阵变量，那么请求映射模式必须用 URI 模板来表示这些矩阵变量。这样的话，不管矩阵变量顺序如何，都能够保证请求可以正确的匹配。 Springboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。 下面用一个springboot项目演示 @MatrixVariable的具体使用方法 1.前端代码部分 项目的结构分布 前端index.html的代码如下 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;springboot注解之@MatrixVariable&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;springboot注解之@MatrixVariable&lt;/h1&gt;&lt;br/&gt;&lt;a href=\"/car/sell;num=10;brand=BYD,AuDi\"&gt;@MatrixVariable（矩阵变量）/car/{sell}&lt;/a&gt;&lt;br/&gt;&lt;a href=\"/boss/1;age=20/2;age=30\"&gt;@MatrixVariable（矩阵变量）/boss/{bossId}/{empId}&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; ​ 1.在/car/sell路径下访问，请求参数为num和brand 2.在/boss/{bossId}/{empId}路径下访问.请求参数age=20表示/boss/bossId?age=20. 而请求参数age=30则表示访问路径/boss/bossId/empId?age=30 2.后端代码部分2.1 配置类MyConfig.javaSpringboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。 12345678910111213141516171819package com.bjpowernode.springboot.conf;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.PathMatchConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.util.UrlPathHelper;@Configuration(proxyBeanMethods = false)public class MyConfig implements WebMvcConfigurer{ @Override public void configurePathMatch(PathMatchConfigurer configurer) { UrlPathHelper urlPathHelper = new UrlPathHelper(); urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); }} 2.2 控制器AnnotationController.java123456789101112131415161718192021222324252627282930313233343536373839package com.bjpowernode.springboot.web;import org.springframework.web.bind.annotation.*;import java.util.HashMap;import java.util.List;import java.util.Map;@RestControllerpublic class AnnotationController { @RequestMapping(\"/car/{path}\") public Map getCar(@MatrixVariable(\"num\") Integer num, @MatrixVariable(\"brand\") List&lt;String&gt; brand, @PathVariable(\"path\") String path){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"num\",num); map.put(\"brand\",brand); map.put(\"path\",path); return map; } @GetMapping(\"/boss/{bossId}/{empId}\") public Map getAge(@PathVariable(\"bossId\") Integer bossId, @PathVariable(\"empId\") Integer empId, @MatrixVariable(value = \"age\",pathVar = \"bossId\") Integer bossAge, @MatrixVariable(value = \"age\",pathVar = \"empId\") Integer empAge){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"bossId\",bossId); map.put(\"empId\",empId); map.put(\"bossAge\",bossAge); map.put(\"empAge\",empAge); return map; }} 2.3 主程序入口1234567891011121314package com.bjpowernode.springboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringbootAnnotationApplication { public static void main(String[] args) { SpringApplication.run(SpringbootAnnotationApplication.class, args); }} 3.结果演示 启动主程序SpringbootAnnotationApplication，在浏览器地址栏输入：http://localhost:8080/,可以得到如下页面 点击第一个链接，得到如下结果 点击第二个链接，得到如下结果","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"MatrixVariable","slug":"MatrixVariable","permalink":"https://www.colorfo.top/tags/MatrixVariable/"},{"name":"springboot注解","slug":"springboot注解","permalink":"https://www.colorfo.top/tags/springboot%E6%B3%A8%E8%A7%A3/"}]},{"title":"markdown语法的使用、博文标题的使用","slug":"markdown语法的使用、博文标题的使用","date":"2021-06-19T07:40:00.000Z","updated":"2021-08-01T08:18:17.177Z","comments":true,"path":"posts/9892.html","link":"","permalink":"https://www.colorfo.top/posts/9892.html","excerpt":"","text":"[TOC] 关于博文的Front-matter的使用 Front-matter中的内容为非必填项，但建议至少填写title和date 最全示例 12345678910111213141516171819---title: 基于 Hexo GitHub 从零开始搭建个人博客date: 2019-12-30 09:25:00author: Sitoiimg: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Hexokeywords: Hexo GitHub blogtags: - Hexo - Blog - GitHub--- 转载自:https://sitoi.cn/posts/63466.html markdown 的基本语法1.斜体和粗体12341. *斜体*或者_斜体_2. **粗体**3. ***加粗斜体***4. ~~删除线~~ 显示效果： 斜体或者_斜体_ 粗体 加粗斜体 删除线 2.分级标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 3.超链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。 3.1 行内式 介绍：[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。 123示例：1. 欢迎访问[我的博客](www.colorfo.top)2. 欢迎访问[我的博客](www.colorfo.top \"colorfo\") 欢迎访问我的博客 欢迎访问我的博客 3.2 参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明：参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 12345678我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3][Leanote 笔记][2]是一个不错的[网站][]。[1]:http://www.google.com \"Google\"[2]:http://www.leanote.com \"Leanote\"[3]:http://www.colorfo.top \"自己的博客\"[网站]:http://http://blog.leanote.com/freewalk 显示效果： 我经常去的几个网站Google、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 更多内容请参考—&gt;原文链接：https://blog.csdn.net/witnessai1/article/details/52551362","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.colorfo.top/tags/markdown/"},{"name":"front-matter","slug":"front-matter","permalink":"https://www.colorfo.top/tags/front-matter/"}],"author":"QianJL"},{"title":"hexo博客的启动和部署","slug":"hexo博客的启动和部署","date":"2021-06-02T08:12:23.000Z","updated":"2021-06-03T11:29:48.212Z","comments":true,"path":"posts/be0d.html","link":"","permalink":"https://www.colorfo.top/posts/be0d.html","excerpt":"","text":"本篇博客主要记录hexo博客的启动和部署启动hexo博客 在blog文件夹下，输入cmd,进入Windows的命令提示行窗口 输入”hexo server”即可启动 hexo 博客 打开浏览器，输入地址：http://localhost:4000,即可从本地访问hexo博客 添加部署信息 在_config.yml文件中操作(_config.yml文件的最下面修改)，可以将博客部署到github或者gitee 例如我的设置为： 1234deploy:type: gitrepo: https://gitee.com/ColorQian/ColorQian.gitbranch: master 修改好配置后，运行如下命令，将代码部署到gitee 123hexo clean hexo generate hexo deploy 在gitee的Gitee Pages 页面更新部署 在浏览器地址栏输入：http://colorqian.gitee.io 即可访问博客","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.colorfo.top/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-04-15T08:12:23.000Z","updated":"2021-06-03T09:23:14.311Z","comments":true,"path":"posts/3d22.html","link":"","permalink":"https://www.colorfo.top/posts/3d22.html","excerpt":"","text":"关于我姓名：钱佳乐😄来自南京理工大学你可以通过邮箱联系我：qjl@njust.edu.cn 关于这个博客网站网站名：”http://colorqian.gitee.io\"我将会不定期的在这个网站上发布一些关于java的文章 技术支持程序羊","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.colorfo.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"回溯","slug":"回溯","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"BST","slug":"BST","permalink":"https://www.colorfo.top/tags/BST/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://www.colorfo.top/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"二叉树的遍历","slug":"二叉树的遍历","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"name":"KMP算法","slug":"KMP算法","permalink":"https://www.colorfo.top/tags/KMP%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://www.colorfo.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://www.colorfo.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","permalink":"https://www.colorfo.top/tags/%E9%93%BE%E8%A1%A8/"},{"name":"约瑟夫环","slug":"约瑟夫环","permalink":"https://www.colorfo.top/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"name":"单链表","slug":"单链表","permalink":"https://www.colorfo.top/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://www.colorfo.top/tags/%E9%98%9F%E5%88%97/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.colorfo.top/tags/LeetCode/"},{"name":"回文","slug":"回文","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%96%87/"},{"name":"github搜索","slug":"github搜索","permalink":"https://www.colorfo.top/tags/github%E6%90%9C%E7%B4%A2/"},{"name":"git","slug":"git","permalink":"https://www.colorfo.top/tags/git/"},{"name":"github","slug":"github","permalink":"https://www.colorfo.top/tags/github/"},{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/tags/springboot/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://www.colorfo.top/tags/mybatis-plus/"},{"name":"分页","slug":"分页","permalink":"https://www.colorfo.top/tags/%E5%88%86%E9%A1%B5/"},{"name":"springboot定制化组件","slug":"springboot定制化组件","permalink":"https://www.colorfo.top/tags/springboot%E5%AE%9A%E5%88%B6%E5%8C%96%E7%BB%84%E4%BB%B6/"},{"name":"文件上传","slug":"文件上传","permalink":"https://www.colorfo.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"Interceptor","slug":"Interceptor","permalink":"https://www.colorfo.top/tags/Interceptor/"},{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"},{"name":"MatrixVariable","slug":"MatrixVariable","permalink":"https://www.colorfo.top/tags/MatrixVariable/"},{"name":"springboot注解","slug":"springboot注解","permalink":"https://www.colorfo.top/tags/springboot%E6%B3%A8%E8%A7%A3/"},{"name":"markdown","slug":"markdown","permalink":"https://www.colorfo.top/tags/markdown/"},{"name":"front-matter","slug":"front-matter","permalink":"https://www.colorfo.top/tags/front-matter/"},{"name":"博客","slug":"博客","permalink":"https://www.colorfo.top/tags/%E5%8D%9A%E5%AE%A2/"}]}