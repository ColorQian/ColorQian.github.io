{"meta":{"title":"color","subtitle":"一万年太久,只争朝夕","description":"专注于java后端的学习","author":"QianJL","url":"https://www.colorfo.top","root":"/"},"pages":[{"title":"404","date":"2021-06-02T08:41:10.000Z","updated":"2021-06-03T06:11:32.904Z","comments":true,"path":"404.html","permalink":"https://www.colorfo.top/404.html","excerpt":"","text":""},{"title":"about","date":"2021-06-03T04:25:30.000Z","updated":"2021-06-19T12:52:10.726Z","comments":true,"path":"about/index.html","permalink":"https://www.colorfo.top/about/index.html","excerpt":"","text":"基本信息 😘 昵称 : color 🌇 城市 : 南京 🎓 学历 : 硕士在读 💪 我努力的方向 : java后端 🏀 爱好 : 篮球 | 跑步 | 羽毛球 | 乒乓球等 联系我 QQ : 1255574204 ✉ : qjl@njust.edu.cn"},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2021-06-02T08:08:48.360Z","comments":true,"path":"categories/index.html","permalink":"https://www.colorfo.top/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-06-03T05:14:00.000Z","updated":"2021-06-03T07:51:07.993Z","comments":true,"path":"contact/index.html","permalink":"https://www.colorfo.top/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2021-06-02T08:13:51.665Z","comments":true,"path":"friends/index.html","permalink":"https://www.colorfo.top/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2021-06-02T08:07:41.432Z","comments":true,"path":"tags/index.html","permalink":"https://www.colorfo.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"springboot集成websocket实现聊天室","slug":"springboot集成websocket实现聊天室","date":"2021-07-25T04:04:39.000Z","updated":"2021-07-25T06:48:24.093Z","comments":true,"path":"posts/3a35.html","link":"","permalink":"https://www.colorfo.top/posts/3a35.html","excerpt":"","text":"[TOC] 1.websocket简介WebSocket协议WebSocket协议是由HTML5定义的，基于TCP协议实现的一种网络协议，通过该协议服务器可以主动向客户端发送信息； WebSocket 协议在2008年诞生，2011年成为W3C国际标准；我们已经有了 HTTP 协议，为什么出现一个websocket协议？ http协议是短连接，因为请求之后，都会关闭连接，下次重新请求数据，需要再次打开链接；WebSocket协议是一种长连接，只需要通过一次请求来初始化连接，然后所有的请求和响应都是通过这个TCP连接进行通讯； 所以HTTP协议通信只能是客户端向服务器发出请求，服务器返回响应结果，HTTP 协议做不到服务器主动向客户端推送信息，而websocket能实现服务器和客户端全双工通信； 何谓全双工 信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工，信息能够同时双向传送则称为全双工； 基本实现原理 WebSocket协议基于TCP协议实现，客户端和服务器只需要做一个握手的动作之后，形成了一条基于客户端和服务器之间的快速通道，之后客户端与服务端之间便可以进行多次数据帧双向传输；这样实现的目的是客户端和服务器进行频繁双向通信时，可以使服务器避免频繁创建HTTP连接，节约资源，提高工作效率和资源利用率。 传统Web推送实现​ 在没有WebSocket协议之前，服务器如何向浏览器端推送消息？通常的实现方式是在页面通过Ajax定时轮询，比如每隔1秒中向服务器发送一次HTTP请求，询问服务器是否有新消息，服务器返回结果；这种形式缺点很明显，浏览器需要不断的向服务器发出HTTP请求，而HTTP请求包含较长的头部，有效信息相对较少，反复的无效请求占用了大量的带宽和 CPU 资源，造成很大的浪费，所以，WebSocket 应运而生；HTML5定义的WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯； WebSocket协议本质上是一个基于TCP的协议，因此与HTTP协议没有什么关系； WebSocket的特点全双工通信，客户端和服务器可以双向平等通信； 建立在TCP协议之上，服务器端的实现比较容易； 数据格式比较轻量，性能开销小，通信高效； 可以发送文本，也可以发送二进制数据； 通信具有更强的实时性； 协议标识符是ws，服务器地址就是：ws://www.abc.com/some/path http协议： http:// websocket的业务场景WebSocket聊天室； 股票实时价格显示等应用； 即时通讯、游戏、可视化大屏展示等领域； 企业内部管理通讯等功能，主要通讯协议websocket； web网页聊天、客服系统实现； 系统提醒、用户上下线提醒、客户端同步，实时数据更新，多屏幕同步，用户在线状态，消息通知，扫描二维码登录/二维码支付，弹幕、各类信息提醒，在线选座，实时监控大屏等等； Java中的WebSocket API在Java EE 7中Java语言开始支持websocket协议，Java EE 7中定义了一套Websocket API规范，也就是一系列接口，没有实现，位于包javax.websocket下，包含客户端API和服务端API，WebSocket的Java API 只是规范，具体实现需要web容器（比如tomcat就实现了Java websocket api）、Java EE服务器或者框架提供； 在java中服务端的实现 1、Tomcat：java中的websocket实现，需要tomcat 7.0.47+以上才支持， Java EE7的支持； 2、Spring的websocket，需要Spring 4.x，所以springboot也可以用； 2.Websocket开发相关注解及API方法websocket注解 @ServerEndpoint(“/websocket/{uid}”) 申明这是一个websocket服务； 需要指定访问该服务的地址，在地址中可以指定参数，需要通过{}进行占位； @OnOpen 用法：public void onOpen(Session session, @PathParam(\"uid\") String uid) throws IOException{} 该方法将在建立连接后执行，会传入session对象，就是客户端与服务端建立的长连接通道，通过@PathParam获取url中声明的参数； @OnClose 用法：public void onClose() {} 该方法是在连接关闭后执行； @OnMessage 用法：public void onMessage(String message, Session session) throws IOException {} 该方法用于接收客户端发送的消息； message：发来的消息数据； session：会话对象（也是长连接通道）； 发送消息到客户端； 用法：session.getBasicRemote().sendText(\"hello,websocket.\"); 通过session进行消息发送； 前端技术对websocket的支持Websocket是html5规范，主流浏览器都支持；（某些老浏览器不支持） jQuery、vueJS、React JS、angularjs等都可以支持webscoket对象； 底层是javascript支持的一个webscoket的js对象，通过这个对象可以建立websocket的连接：ws://localhost:8080/websocket/12345 WebSocket有很多优点，弥补了http协议的不足，但是如果服务端维护很多长连接也是很耗费资源的，服务器集群带来了复杂性以及存在老版本浏览器兼容性问题，各大厂目前大多数还是基于轮询的方式实现的，比如：扫码登录、支付成功通知、秒杀成功通知等； 在秒杀场景中，用轮询即可，前端轮询一般不可能穿透到后端数据库查询，一般是采用高性能的缓存标记来判定秒杀是否成功，相对于websocket长连接以及其不确定因素，轮询依然是相对比较合适的方案； Websocket各浏览器的支持情况： https://caniuse.com/#search=websocket 3.springboot集成WebSocket实现多人聊天室 项目代码结构分布 pom文件依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.5.2&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;!--此项目的GAV坐标--> &lt;groupId>com.bjpowernode&lt;/groupId> &lt;artifactId>041-springboot-websocket&lt;/artifactId> &lt;version>1.0.0&lt;/version> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;/properties> &lt;dependencies> &lt;!--springboot web项目的起步依赖--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;!--spring-boot-starter-websocket--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-websocket&lt;/artifactId> &lt;/dependency> &lt;!--lombok,需要在IDEA中安装lombok插件才能使用该依赖--> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;/dependency> &lt;!--引入Spring Boot内嵌的Tomcat对JSP的解析包--> &lt;dependency> &lt;groupId>org.apache.tomcat.embed&lt;/groupId> &lt;artifactId>tomcat-embed-jasper&lt;/artifactId> &lt;/dependency> &lt;!--热部署插件(该依赖不是必选项)--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;resources> &lt;!--src/main/java下的.xml配置文件编译到target下去--> &lt;resource> &lt;directory>src/main/java&lt;/directory> &lt;includes> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;/resource> &lt;!--src/main/resources下的配置文件编译到target下去--> &lt;resource> &lt;directory>src/main/resources&lt;/directory> &lt;includes> &lt;include>**/*.*&lt;/include> &lt;/includes> &lt;/resource> &lt;!--src/main/webapp下的jsp页面编译到META-INF/resources下才能访问--> &lt;resource> &lt;directory>src/main/webapp&lt;/directory> &lt;targetPath>META-INF/resources&lt;/targetPath> &lt;includes> &lt;include>**/*.*&lt;/include> &lt;/includes> &lt;/resource> &lt;/resources> &lt;/build> &lt;/project> 前端代码 项目的主配置文件application.properties #设置jsp文件的前缀和后缀 spring.mvc.view.prefix=/ spring.mvc.view.suffix=.jsp index.jsp文件详情 SpringBoot+WebSocket+JSP 在线聊天室 发送 离开 $(function () { var ws; if (\"WebSocket\" in window) { var baseUrl = 'ws://localhost:8080/websocket/'; var userName = $('#username').val(); ws = new WebSocket(baseUrl + userName); // 连通之后的回调事件，建立连接 ws.onopen = function () { console.log(\"建立 websocket 连接...\"); }; // 接收后台服务端的消息 ws.onmessage = function (event) { $('#content').append(event.data + '\\n\\n'); console.log(\"接收到服务端发送的消息...\" + event.data + '\\n'); }; ws.onerror = function (event) { console.log(\"websocket发生错误...\" + event + '\\n'); } // 连接关闭的回调事件 ws.onclose = function () { $('#content').append('[' + userName + '] 已离开!'); console.log(\"关闭 websocket 连接...\"); }; } else { // 浏览器不支持 WebSocket alert(\"您的浏览器不支持WebSocket!\"); } // 客户端发送消息到服务器 $('#toSend').click(function () { sendMsg(); }); $(document).keyup(function (event) { // 回车键事件 if (event.keyCode == 13) { sendMsg(); } }); // 发送消息 function sendMsg() { //websocket发送消息 ws.send($('#message').val()); $('#message').val(\"\"); } // 退出 $('#user_exit').click(function () { if (ws) { ws.close(); } }); }); 还需要一个jquery.min.js文件，可以去网上下载 后端代码 后端代码结构 首先是endpoint包下的chatServerEndpoint.java 文件 package com.bjpowernode.endpoint; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import javax.websocket.*; import javax.websocket.server.PathParam; import javax.websocket.server.ServerEndpoint; import java.io.IOException; /** * 说明： * 1、@ServerEndpoint注解中指定WebSocket协议的地址； * 2、@OnOpen、@OnMessage、@OnClose、@OnError注解与WebSocket中监听事件对应 * **/ @Slf4j //lombok jar包，帮我们自动生成一些代码：@Data @Component @ServerEndpoint(\"/websocket/{username}\") public class ChatServerEndpoint { /** * 连接建立时触发 */ @OnOpen public void openSession(@PathParam(\"username\") String username, Session session) { log.info(\"用户{}登录\", username); String message = \"用户[\" + username + \"] 已进入聊天室！\"; // 发送登录消息给其他人 WebSocketUtils.sendMessageAll(message); // 获取当前在线人数，发给自己 String onlineInfo = WebSocketUtils.getOnlineInfo(); //发送消息 WebSocketUtils.sendMessage(session, onlineInfo); // 添加自己到map中 WebSocketUtils.CLIENTS.put(username, session); } /** * 客户端接收服务端数据时触发 */ @OnMessage public void onMessage(@PathParam(\"username\") String username, String message) { log.info(\"发送消息：{}, {}\", username, message); //广播，把消息同步给其他客户端 WebSocketUtils.sendMessageAll(\"[\" + username + \"] : \" + message); } /** * 连接关闭时触发 */ @OnClose public void onClose(@PathParam(\"username\") String username, Session session) { // 当前的Session移除某个用户 WebSocketUtils.CLIENTS.remove(username); // 离开消息通知所有人 WebSocketUtils.sendMessageAll(\"[\" + username + \"] 已离开！\"); try { //关闭WebSocket Session会话 session.close(); log.info(\"{} 已退出, onclose\", username); } catch (IOException e) { e.printStackTrace(); log.error(\"onClose error\", e); } } /** * 通信发生错误时触发 */ @OnError public void onError(Session session, Throwable throwable) { try { //关闭WebSocket Session会话 session.close(); } catch (IOException e) { e.printStackTrace(); log.error(\"onError Exception\", e); } log.info(\"Throwable msg \" + throwable.getMessage()); } } endpoint包下的WebSocketUtils.java 文件 package com.bjpowernode.endpoint; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import javax.websocket.RemoteEndpoint; import javax.websocket.Session; import java.io.IOException; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public final class WebSocketUtils { private static final Logger logger = LoggerFactory.getLogger(WebSocketUtils.class); /** * 存储WebSocket session * &lt;p> * 用户名为key，WebSocket Session对象为value */ public static final Map&lt;String, Session> CLIENTS = new ConcurrentHashMap&lt;>(); /** * 使用连接发送数据 * * @param session 用户session * @param message 发送内容 */ public static void sendMessage(Session session, String message) { if (session == null) { return; } final RemoteEndpoint.Basic basic = session.getBasicRemote(); if (basic == null) { return; } try { //发送 basic.sendText(message); } catch (IOException e) { e.printStackTrace(); logger.error(\"sendMessage IOException \", e); } } /** * 发送消息给其他所有人 * * @param message */ public static void sendMessageAll(String message) { CLIENTS.forEach((sessionId, session) -> sendMessage(session, message)); } /** * 获取所有在线用户 */ public static String getOnlineInfo() { Set&lt;String> userNames = CLIENTS.keySet(); if (userNames.size() == 0) { return \"当前无人在线...\"; } return CLIENTS.keySet().toString() + \"在线\"; } } 接着是controller包下的ChatController.java文件 package com.bjpowernode.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import java.util.concurrent.atomic.AtomicInteger; @Controller public class ChatController { private AtomicInteger idProducer = new AtomicInteger(); @RequestMapping(\"/\") public String index(Model model) { model.addAttribute(\"username\",\"user\" + idProducer.getAndIncrement()); return \"index\"; } } 项目启动后，访问根路径，转发到index.jsp 最后是config包下的WebSocketConfig.java文件 package com.bjpowernode.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.config.annotation.EnableWebSocket; import org.springframework.web.socket.server.standard.ServerEndpointExporter; @EnableWebSocket //启用WebSocket支持 @Configuration //表示配置类 public class WebSocketConfig { /** * 配置ServerEndpointExporter的bean * * 该Bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint */ @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } 最后的最后，是程序的主入口Application.java，用来启动整个项目 package com.bjpowernode; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 项目启动运行 在浏览器地址栏输入http://localhost:8080/ 示例如下 在另一个浏览器地址栏(或者相同浏览器新建一个窗口)输入http://localhost:8080/，即可实现多人聊天","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"}]},{"title":"springboot之-MatrixVariable注解使用","slug":"springboot之-MatrixVariable注解使用","date":"2021-07-24T14:51:43.000Z","updated":"2021-07-24T14:53:39.425Z","comments":true,"path":"posts/80aa.html","link":"","permalink":"https://www.colorfo.top/posts/80aa.html","excerpt":"","text":"简介​ 根据 URI 规范 RFC 3986 中 URL 的定义，路径片段中可以可以包含键值对。规范中没对对应的术语。一般 “URL 路径参数” 可以被应用，尽管更加独特的 “矩阵 URI” 也经常被使用并且相当有名。在 Spring MVC 它被称为矩阵变量。 矩阵变量可以出现在任何路径片段中，每一个矩阵变量都用分号（;）隔开。比如 /cars;color=red;year=2012。多个值可以用逗号隔开，比如color=red,green,blue，或者分开写 color=red;color=green;color=blue。 如果你希望一个 URL 包含矩阵变量，那么请求映射模式必须用 URI 模板来表示这些矩阵变量。这样的话，不管矩阵变量顺序如何，都能够保证请求可以正确的匹配。 Springboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。 下面用一个springboot项目演示 @MatrixVariable的具体使用方法 1.前端代码部分 项目的结构分布 前端index.html的代码如下 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>springboot注解之@MatrixVariable&lt;/title> &lt;/head> &lt;body> &lt;h1>springboot注解之@MatrixVariable&lt;/h1>&lt;br/> &lt;a href=\"/car/sell;num=10;brand=BYD,AuDi\">@MatrixVariable（矩阵变量）/car/{sell}&lt;/a> &lt;br/> &lt;a href=\"/boss/1;age=20/2;age=30\">@MatrixVariable（矩阵变量）/boss/{bossId}/{empId}&lt;/a> &lt;/body> &lt;/html> ​ 1.在/car/sell路径下访问，请求参数为num和brand 2.在/boss/{bossId}/{empId}路径下访问.请求参数age=20表示/boss/bossId?age=20. 而请求参数age=30则表示访问路径/boss/bossId/empId?age=30 2.后端代码部分2.1 配置类MyConfig.javaSpringboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。 package com.bjpowernode.springboot.conf; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.PathMatchConfigurer; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import org.springframework.web.util.UrlPathHelper; @Configuration(proxyBeanMethods = false) public class MyConfig implements WebMvcConfigurer{ @Override public void configurePathMatch(PathMatchConfigurer configurer) { UrlPathHelper urlPathHelper = new UrlPathHelper(); urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); } } 2.2 控制器AnnotationController.javapackage com.bjpowernode.springboot.web; import org.springframework.web.bind.annotation.*; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController public class AnnotationController { @RequestMapping(\"/car/{path}\") public Map getCar(@MatrixVariable(\"num\") Integer num, @MatrixVariable(\"brand\") List&lt;String> brand, @PathVariable(\"path\") String path){ Map&lt;String,Object> map = new HashMap&lt;>(); map.put(\"num\",num); map.put(\"brand\",brand); map.put(\"path\",path); return map; } @GetMapping(\"/boss/{bossId}/{empId}\") public Map getAge(@PathVariable(\"bossId\") Integer bossId, @PathVariable(\"empId\") Integer empId, @MatrixVariable(value = \"age\",pathVar = \"bossId\") Integer bossAge, @MatrixVariable(value = \"age\",pathVar = \"empId\") Integer empAge){ Map&lt;String,Object> map = new HashMap&lt;>(); map.put(\"bossId\",bossId); map.put(\"empId\",empId); map.put(\"bossAge\",bossAge); map.put(\"empAge\",empAge); return map; } } 2.3 主程序入口package com.bjpowernode.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class SpringbootAnnotationApplication { public static void main(String[] args) { SpringApplication.run(SpringbootAnnotationApplication.class, args); } } 3.结果演示 启动主程序SpringbootAnnotationApplication，在浏览器地址栏输入：http://localhost:8080/,可以得到如下页面 点击第一个链接，得到如下结果 点击第二个链接，得到如下结果","categories":[{"name":"springboot注解","slug":"springboot注解","permalink":"https://www.colorfo.top/categories/springboot%E6%B3%A8%E8%A7%A3/"}],"tags":[{"name":"MatrixVariable","slug":"MatrixVariable","permalink":"https://www.colorfo.top/tags/MatrixVariable/"}]},{"title":"markdown语法的使用、博文标题的使用","slug":"markdown语法的使用、博文标题的使用","date":"2021-06-19T07:40:00.000Z","updated":"2021-06-19T12:48:46.141Z","comments":true,"path":"posts/9892.html","link":"","permalink":"https://www.colorfo.top/posts/9892.html","excerpt":"","text":"[TOC] 关于博文的Front-matter的使用 Front-matter中的内容为非必填项，但建议至少填写title和date 最全示例 --- title: 基于 Hexo GitHub 从零开始搭建个人博客 date: 2019-12-30 09:25:00 author: Sitoi img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Hexo keywords: Hexo GitHub blog tags: - Hexo - Blog - GitHub --- 转载自Sitoi的博客 markdown 的基本语法1.斜体和粗体1. *斜体*或者_斜体_ 2. **粗体** 3. ***加粗斜体*** 4. ~~删除线~~ 显示效果： 斜体或者_斜体_ 粗体 加粗斜体 删除线 2.分级标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 3.超链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。 3.1 行内式 介绍：[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。 示例： 1. 欢迎访问[我的博客](www.colorfo.top) 2. 欢迎访问[我的博客](www.colorfo.top \"colorfo\") 欢迎访问我的博客 欢迎访问我的博客 3.2 参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明：参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3] [Leanote 笔记][2]是一个不错的[网站][]。 [1]:http://www.google.com \"Google\" [2]:http://www.leanote.com \"Leanote\" [3]:http://www.colorfo.top \"自己的博客\" [网站]:http://http://blog.leanote.com/freewalk 显示效果： 我经常去的几个网站Google、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 更多内容请参考—&gt;原文链接：https://blog.csdn.net/witnessai1/article/details/52551362","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.colorfo.top/tags/markdown/"},{"name":"front-matter","slug":"front-matter","permalink":"https://www.colorfo.top/tags/front-matter/"}],"author":"QianJL"},{"title":"hexo博客的启动和部署","slug":"hexo博客的启动和部署","date":"2021-06-02T08:12:23.000Z","updated":"2021-06-03T11:29:48.212Z","comments":true,"path":"posts/be0d.html","link":"","permalink":"https://www.colorfo.top/posts/be0d.html","excerpt":"","text":"本篇博客主要记录hexo博客的启动和部署启动hexo博客 在blog文件夹下，输入cmd,进入Windows的命令提示行窗口 输入”hexo server”即可启动 hexo 博客 打开浏览器，输入地址：http://localhost:4000,即可从本地访问hexo博客 添加部署信息 在_config.yml文件中操作(_config.yml文件的最下面修改)，可以将博客部署到github或者gitee 例如我的设置为： deploy: type: git repo: https://gitee.com/ColorQian/ColorQian.git branch: master 修改好配置后，运行如下命令，将代码部署到gitee hexo clean hexo generate hexo deploy 在gitee的Gitee Pages 页面更新部署 在浏览器地址栏输入：http://colorqian.gitee.io 即可访问博客","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.colorfo.top/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-04-15T08:12:23.000Z","updated":"2021-06-03T09:23:14.311Z","comments":true,"path":"posts/3d22.html","link":"","permalink":"https://www.colorfo.top/posts/3d22.html","excerpt":"","text":"关于我姓名：钱佳乐😄来自南京理工大学你可以通过邮箱联系我：qjl@njust.edu.cn 关于这个博客网站网站名：”http://colorqian.gitee.io\"我将会不定期的在这个网站上发布一些关于java的文章 技术支持程序羊","categories":[],"tags":[]}],"categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"},{"name":"springboot注解","slug":"springboot注解","permalink":"https://www.colorfo.top/categories/springboot%E6%B3%A8%E8%A7%A3/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"},{"name":"MatrixVariable","slug":"MatrixVariable","permalink":"https://www.colorfo.top/tags/MatrixVariable/"},{"name":"markdown","slug":"markdown","permalink":"https://www.colorfo.top/tags/markdown/"},{"name":"front-matter","slug":"front-matter","permalink":"https://www.colorfo.top/tags/front-matter/"},{"name":"博客","slug":"博客","permalink":"https://www.colorfo.top/tags/%E5%8D%9A%E5%AE%A2/"}]}