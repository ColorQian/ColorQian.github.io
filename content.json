{"meta":{"title":"color","subtitle":null,"description":"一个记录学习经历与分享技术的地方!","author":"QianJL","url":"https://www.colorfo.top","root":"/"},"pages":[{"title":"404","date":"2021-06-02T08:41:10.000Z","updated":"2021-06-03T06:11:32.904Z","comments":true,"path":"404.html","permalink":"https://www.colorfo.top/404.html","excerpt":"","text":""},{"title":"关于我","date":"2021-06-03T04:25:30.000Z","updated":"2021-08-10T12:18:48.663Z","comments":true,"path":"about/index.html","permalink":"https://www.colorfo.top/about/index.html","excerpt":"","text":"基本信息 😘 昵称 : color 🌇 城市 : 南京 🎓 学历 : 硕士在读 💪 我努力的方向 : java后端 🏀 爱好 : 篮球 | 跑步 | 羽毛球 | 乒乓球等 联系我 QQ : 1255574204 ✉ : qjl@njust.edu.cn"},{"title":"友链","date":"2021-08-11T04:08:26.000Z","updated":"2021-08-11T04:54:56.517Z","comments":true,"path":"link/index.html","permalink":"https://www.colorfo.top/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-09-30T09:25:30.000Z","updated":"2021-08-10T12:19:21.064Z","comments":true,"path":"categories/index.html","permalink":"https://www.colorfo.top/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2018-12-12T13:25:30.000Z","updated":"2021-08-10T12:20:10.959Z","comments":true,"path":"friends/index.html","permalink":"https://www.colorfo.top/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-09-30T10:23:38.000Z","updated":"2021-08-10T12:20:39.463Z","comments":true,"path":"tags/index.html","permalink":"https://www.colorfo.top/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-06-03T05:14:00.000Z","updated":"2021-08-10T12:19:39.398Z","comments":true,"path":"comments/index.html","permalink":"https://www.colorfo.top/comments/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"}],"posts":[{"title":"进程的基础知识","slug":"进程的基础知识","date":"2021-10-23T09:18:45.000Z","updated":"2021-10-23T09:22:03.763Z","comments":true,"path":"posts/91b5.html","link":"","permalink":"https://www.colorfo.top/posts/91b5.html","excerpt":"","text":"1.进程的概念​ 我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个运行中的程序，就被称为「进程」（Process）。 操作系统管理进程的核心:多个进程，交替执行。 2.进程的状态在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。 上图中各个状态的意义： 运行状态（Runing）：该时刻进程占用 CPU； 就绪状态（Ready）：可运行，由于其他进程处于运行状态而暂时停止运行； 阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行； 当然，进程还有另外两个基本状态： 创建状态（new）：进程正在被创建时的状态； 结束状态（Exit）：进程正在从系统中消失时的状态； 于是，一个完整的进程状态的变迁如下图: 再来详细说明一下进程的状态变迁： NULL -&gt; 创建状态：一个新进程被创建时的第一个状态； 创建状态 -&gt; 就绪状态：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的； 就绪态 -&gt; 运行状态：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程； 运行状态 -&gt; 结束状态：当进程已经运行完成或出错时，会被操作系统作结束状态处理； 运行状态 -&gt; 就绪状态：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行； 运行状态 -&gt; 阻塞状态：当进程请求某个事件且必须等待时，例如请求 I/O 事件； 阻塞状态 -&gt; 就绪状态：当进程要等待的事件完成时，它从阻塞状态变到就绪状态； 进程的挂起状态 如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，显然不是我们所希望的，毕竟物理内存空间是有限的，被阻塞状态的进程占用着物理内存就一种浪费物理内存的行为。 所以，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。 那么，就需要一个新的状态，来描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。 另外，挂起状态可以分为两种： 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现； 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行； 这两种挂起状态加上前面的五种状态，就变成了七种状态变迁（留给我的颜色不多了），见如下图： 导致进程挂起的原因不只是因为进程所使用的内存空间不在物理内存，还包括如下情况： 通过 sleep 让进程间歇性挂起，其工作原理是设置一个定时器，到期后唤醒进程。 用户希望挂起一个程序的执行，比如在 Linux 中用 Ctrl+Z 挂起进程； 3.进程的控制结构在操作系统中，是用进程控制块（process control block，PCB）数据结构来描述进程的。 PCB 是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。 PCB具体包含什么信息呢？ 进程描述信息： 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符； 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务； 进程控制和管理信息： 进程当前状态，如 new、ready、running、waiting 或 blocked 等； 进程优先级：进程抢占 CPU 时的优先级； 资源分配清单： 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。 CPU 相关信息： CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。 每个PCB是如何组织的呢？ 通常是通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。比如： 将所有处于就绪状态的进程链在一起，称为就绪队列； 把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列； 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。 除了链接的组织方式，还有索引方式，它的工作原理：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。 一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。 4.进程的控制 我们熟知了进程的状态变迁和进程的数据结构 PCB 后，再来看看进程的创建、终止、阻塞、唤醒的过程，这些过程也就是进程的控制。 01 创建进程 操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止时，其在父进程处继承的资源应当还给父进程。同时，终止父进程时同时也会终止其所有的子进程。 注意：Linux 操作系统对于终止有子进程的父进程，会把子进程交给 1 号进程接管。本文所指出的进程终止概念是宏观操作系统的一种观点，最后怎么实现当然是看具体的操作系统。 创建进程的过程如下： 为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB，PCB 是有限的，若申请失败则创建失败； 为进程分配资源，此处如果资源不足，进程就会进入等待状态，以等待资源； 初始化 PCB； 如果进程的调度队列能够接纳新进程，那就将进程插入到就绪队列，等待被调度运行； 02 终止进程 进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 kill 掉）。 终止进程的过程如下： 查找需要终止的进程的 PCB； 如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程； 如果其还有子进程，则应将其所有子进程终止； 将该进程所拥有的全部资源都归还给父进程或操作系统； 将其从 PCB 所在队列中删除； 03 阻塞进程 当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。 阻塞进程的过程如下： 找到将要被阻塞进程标识号对应的 PCB； 如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行； 将该 PCB 插入到阻塞队列中去； 04 唤醒进程 进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。 如果某进程正在等待 I/O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。 唤醒进程的过程如下： 在该事件的阻塞队列中找到相应进程的 PCB； 将其从阻塞队列中移出，并置其状态为就绪状态； 把该 PCB 插入到就绪队列中，等待调度程序调度； 进程的阻塞和唤醒是一对功能相反的语句，如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句。 5.进程的上下文切换 CPU上下文切换 各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个一个进程切换到另一个进程运行，称为进程的上下文切换。 在详细说进程上下文切换前，我们先来看看 CPU 上下文切换 大多数操作系统都是多任务，通常支持大于 CPU 数量的任务同时运行。实际上，这些任务并不是同时运行的，只是因为系统在很短的时间内，让各个任务分别在 CPU 运行，于是就造成同时运行的错觉。 任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。 所以，操作系统需要事先帮 CPU 设置好 CPU 寄存器和程序计数器。 CPU 寄存器是 CPU 内部一个容量小，但是速度极快的内存（缓存）。我举个例子，寄存器像是你的口袋，内存像你的书包，硬盘则是你家里的柜子，如果你的东西存放到口袋，那肯定是比你从书包或家里柜子取出来要快的多。 再来，程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。 所以说，CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 CPU 上下文。 CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。 系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。 进程的上下文切换 上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。 进程是由内核管理和调度的，所以进程的切换只能发生在内核态。 所以，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示： 大家需要注意，进程的上下文开销是很关键的，我们希望它的开销越小越好，这样可以使得进程可以把更多时间花费在执行程序上，而不是耗费在上下文切换。 发生进程上下文切换有哪些场景？ 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行； 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行； 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度； 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行； 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序； 以上，就是发生进程上下文切换的常见场景了。 以上内容参考公众号：小林coding","categories":[{"name":"图解系统","slug":"图解系统","permalink":"https://www.colorfo.top/categories/%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"进程","slug":"进程","permalink":"https://www.colorfo.top/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"进程的状态","slug":"进程的状态","permalink":"https://www.colorfo.top/tags/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"},{"name":"PCB","slug":"PCB","permalink":"https://www.colorfo.top/tags/PCB/"}]},{"title":"内存管理","slug":"内存管理","date":"2021-10-18T07:22:08.000Z","updated":"2021-10-18T07:26:51.180Z","comments":true,"path":"posts/9a8a.html","link":"","permalink":"https://www.colorfo.top/posts/9a8a.html","excerpt":"","text":"1.虚拟内存 操作系统为每个进程分配一套虚拟地址，这样就可以把每个进程所使用的地址隔离开来。但是有个前提，每个进程都不能直接访问物理地址，而是需要通过虚拟地址映射到物理地址上 操作系统会提供一种机制，将不同进程的虚拟地址和不同的物理内存地址映射起来 操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示： 操作系统如何管理虚拟地址和物理地址之间的关系？ 主要由内存分段和内存分页 2.内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。 1.虚拟地址和物理地址的映射关系 分段机制下，虚拟地址和物理地址是如何映射的？ 分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。 虚拟地址是通过段表与物理地址进行映射的 段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。 虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。 举例说明内存分段机制下，虚拟地址和物理地址之间的映射关系： 虚拟地址是通过段表与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图： 如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。 分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处： 第一个就是内存碎片的问题。 第二个就是内存交换的效率低的问题。 2.内存碎片 这里的内存碎片的问题共有两处地方： 外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载； 内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费； 针对上面两种内存碎片的问题，解决的方式会有所不同。 解决外部内存碎片的问题就是内存交换。 3.内存交换可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。 这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。 再来看看，分段为什么会导致内存交换效率低的问题？ 对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。 因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。 所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。 为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。 3.内存分页分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。 要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是内存分页（Paging）。 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。 1.虚拟地址和物理地址的映射关系虚拟地址与物理地址之间通过页表来映射，如下图： 页表是存储在内存里的，内存管理单元 （MMU）就做将虚拟内存地址转换成物理地址的工作。 而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。 分页是怎么解决分段的内存碎片、内存交换效率低的问题？ 由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。(不会产生内存分段那种大的内存碎片) 如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。(内存交换的开销小，效率高) 更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。 分页机制下，虚拟地址和物理地址是如何映射的？ 在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。 总结一下，对于一个内存地址转换，其实就是这样三个步骤： 把虚拟内存地址，切分成页号和偏移量； 根据页号，从页表里面，查询对应的物理页号； 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。 简单的分页有什么缺陷吗？(消耗过多的内存空间) 因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。 在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。 这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。 那么，100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。 2.多级页表要解决上面的问题，就需要采用一种叫作多级页表（Multi-Level Page Table）的解决方案。 在前面我们知道了，对于单页表的实现方式，在 32 位和页大小 4KB 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。 我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024个「页表项」，形成二级分页。如下图所示： 你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？ 当然如果 4GB 的虚拟地址全部都映射到了物理内存上的话，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。 其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的局部性原理么？ 每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。 如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 是不是一个巨大的节约？ 那么为什么不分级的页表就做不到这样节约内存呢？我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。 我们把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。 对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是： 全局页目录项 PGD（Page Global Directory）； 上层页目录项 PUD（Page Upper Directory）； 中间页目录项 PMD（Page Middle Directory）； 页表项 PTE（Page Table Entry）； 3.TLB(Translation Lookaside Buffer)-页表缓存、快表 多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。 程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。 我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。 在 CPU 芯片里面，封装了内存管理单元（Memory Management Unit）芯片，它用来完成地址转换和 TLB 的访问与交互。 有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。 TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。 4.段页式内存管理段页式内存管理实现的方式： 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页； 这样，地址结构就由段号、段内页号和页内位移三部分组成。 用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示： 段页式地址变换中要得到物理地址须经过三次内存访问： 第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址。 可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。 4.总结 为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套虚拟地址空间，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。 每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。 那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。 那么对于虚拟地址与物理地址的映射关系，可以有分段和分页的方式，同时两者结合都是可以的。 内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致内存碎片和内存交换效率低的问题。 于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 4KB。由于分了页后，就不会产生细小的内存碎片。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。 再来，为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。 Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。 另外，Linxu 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。 以上内容参考公众号：小林coding","categories":[{"name":"图解系统","slug":"图解系统","permalink":"https://www.colorfo.top/categories/%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"https://www.colorfo.top/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"内存分页","slug":"内存分页","permalink":"https://www.colorfo.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5/"},{"name":"内存分段","slug":"内存分段","permalink":"https://www.colorfo.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5/"}]},{"title":"反转字符串与旋转数组","slug":"反转字符串与旋转数组","date":"2021-10-02T14:16:36.000Z","updated":"2021-10-02T14:32:49.781Z","comments":true,"path":"posts/5f98.html","link":"","permalink":"https://www.colorfo.top/posts/5f98.html","excerpt":"","text":"1.旋转数组题目链接：https://leetcode-cn.com/problems/rotate-array/ 题目 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 进阶： 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6]。向右旋转 2 步: [6,7,1,2,3,4,5]。向右旋转 3 步: [5,6,7,1,2,3,4]。 代码详情 12345678910111213141516171819/** * https://leetcode-cn.com/problems/rotate-array/ */public class RotateArray { //旋转数组 public void rotate(int[] nums, int k) { int len = nums.length; int[] temp = new int[len]; //将nums[i]中的元素 移动后 放入temp数组中 for (int i = 0; i &lt; len; i++) { temp[(i + k) % len] = nums[i]; } //再将temp数组中的值 赋值给nums数组 for (int i = 0; i &lt; len; i++) { nums[i] = temp[i]; } }} 2.反转字符串leetcode题目链接 题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1：输入：[“h”,”e”,”l”,”l”,”o”] 输出：[“o”,”l”,”l”,”e”,”h”] 示例 2：输入：[“H”,”a”,”n”,”n”,”a”,”h”] 输出：[“h”,”a”,”n”,”n”,”a”,”H”] 思路分析 利用双指针，将左右两边的字母交换，然后左指针右移，右指针左移 代码详情 12345678910111213141516171819/** * https://leetcode-cn.com/problems/reverse-string/ */public class ReverseString { //反转字符串 public void reverseString(char[] s) { int len = s.length; int left = 0; int right = len - 1; while (left &lt; right) { char temp = ' '; temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } }} 3.反转字符串IIleetcode题目链接 题目 给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例: 输入: s = “abcdefg”, k = 2 输出: “bacdfeg” 思路分析 在遍历字符串的过程中，只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。 因为要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。 所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。 代码详情 12345678910111213141516171819202122232425262728293031/** * https://leetcode-cn.com/problems/reverse-string-ii/ */public class ReverseString2 { public String reverseStr(String s, int k) { char[] chars = s.toCharArray(); int len = chars.length; for (int i = 0; i &lt; len; i += 2 * k) { //1.每隔 2k 个字符的前 k 个字符进行反转 if (i + k - 1 &lt;= len - 1) { reverse(i, i + k - 1, chars); continue; } //2.剩余字符串小于k个，则将剩余的全部反转 reverse(i, len - 1, chars); } return String.valueOf(chars); } private void reverse(int start, int end, char[] chars) { while (start &lt; end) { char temp = ' '; temp = chars[start]; chars[start] = chars[end]; chars[end] = temp; start++; end--; } }} 4.替换空格leetcode题目链接 题目 请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 1：输入：s = “We are happy.” 输出：”We%20are%20happy.” 代码详情 12345678910111213141516public class ReplaceSpace { public String replace(String s){ StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()){ if (\" \".equals(String.valueOf(c))){ //String.valueOf() 将char转为String sb.append(\"%20\"); }else{ sb.append(c); } } return sb.toString(); }} 5.翻转字符串里的单词leetcode题目链接 题目 给定一个字符串，逐个翻转字符串中的每个单词。 示例 1：输入: “the sky is blue”输出: “blue is sky the” 示例 2：输入: “ hello world! “输出: “world! hello”解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 代码详情 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 定义[left,right]为需要读取单词的区间 * 指针left、right定义为在去掉字符串首尾空格后字符串的首尾位置 * 1.去掉字符串首尾左右空格，移动left、right指针指向去掉空格后的首尾位置。 * while（left&lt;=right）{ * 2.从后往前一个个遍历单词，设置index指针，指向right位置，index从后往前遍历，直到遇到空格或者末尾 * 说明此时已经将其中一个单词遍历完。 * 3.此时index+1为该单词的首位，遍历字符串[index+1,right]区间，加入到StringBuffer中 * 4.判断index位置，加入空格：若index位置已经到达头位置了，说明不需要添加空格，否则都需要添加空格隔开单词 * 5.index继续从后往前遍历，跳过空格直到遇到非空字符，将right指向index的位置执行下一次循环 * } * 6.返回StringBuilder.toString(); * * https://leetcode-cn.com/problems/reverse-words-in-a-string/ */public class ReverseWords { public String reverseWords(String s) { char[] ch = s.toCharArray(); int len = ch.length; int left = 0; int right = len - 1; //去除字符串两端的空格 while (left &lt; len &amp;&amp; ch[left] == ' ') left++; while (right &gt;= 0 &amp;&amp; ch[right] == ' ') right--; StringBuilder sb = new StringBuilder(); while (left &lt;= right) { int index = right; //记录当前最右边的位置 //从右向左遍历 while (index &gt;= left &amp;&amp; ch[index] != ' ') index--; //将index~right范围内的单词加入到StringBuilder for (int i = index + 1; i &lt;= right; i++) { sb.append(ch[i]); } //在新加入的单词之间加一个空格 if (index &gt;= left) sb.append(\" \"); //去除原先字符串的单词之间多余的空格 while (index &gt;= left &amp;&amp; ch[index] == ' ') index--; right = index; } return sb.toString(); }} 6.剑指Offer58-II.左旋转字符串leetcode题目链接 题目 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。 示例 1：输入: s = “abcdefg”, k = 2输出: “cdefgab” 示例 2：输入: s = “lrloseumgh”, k = 6输出: “umghlrlose” 代码详情 123456789101112/** * https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/ */public class RotateStr { public String reverseLeftWords(String s, int n) { int len = s.length(); String str1 = s.substring(0, n); String str2 = s.substring(n, len); return str2 + str1; }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://www.colorfo.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://www.colorfo.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"单调栈刷题笔记","slug":"单调栈刷题笔记","date":"2021-10-02T07:25:00.000Z","updated":"2021-10-02T08:43:48.189Z","comments":true,"path":"posts/17ab.html","link":"","permalink":"https://www.colorfo.top/posts/17ab.html","excerpt":"","text":"1.每日温度leetcode题目链接 题目 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 思路分析 方法一：暴力解法，两层for循环，把至少需要等待的天数就搜出来了。时间复杂度是O(n^2) 方法二：单调栈 1.先把下标0压入栈中 2.利用for循环遍历temperatures数组， ​ 1)如果当前遍历到的数组元素，大于**栈顶(stack.peek())**中保存的下标对应的元素 ​ 则说明出现了更高的气温，记录到result数组中，接着将栈顶元素弹出，将下标i压栈 ​ 2)如果当前遍历到的数组元素，小于等于**栈顶(stack.peek())**中保存的下标对应的元素 ​ 则直接将下标i压栈 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Stack;/** * https://leetcode-cn.com/problems/daily-temperatures/ */public class DailyTemperatures { //方法一：单调栈 public int[] dailyTemperatures(int[] temperatures) { int len = temperatures.length; if (len == 1) return new int[1]; int[] result = new int[len]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(0); //栈中放入数组的下标 for (int i = 1; i &lt; len; i++) { while (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) { result[stack.peek()] = i - stack.peek(); stack.pop(); } stack.push(i); } return result; } //方法二：暴力求解 public int[] dailyTemperatures2(int[] temperatures) { int len = temperatures.length; if (len == 1) return new int[1]; int[] result = new int[len]; for (int i = 0; i &lt; len; i++) { for (int j = i + 1; j &lt; len; j++) { if (temperatures[j] &gt; temperatures[i]) { result[i] = j - i; break; } } } return result; }} 2.下一个更大元素 Ileetcode题目链接 题目 给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。 请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。 nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。 示例 1: 输入: nums1 = [4,1,2], nums2 = [1,3,4,2].输出: [-1,3,-1]解释:对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。 示例 2:输入: nums1 = [2,4], nums2 = [1,2,3,4].输出: [3,-1]解释:对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出-1 。 思路分析 1.定义一个result数组，并赋初值为-1 2.在遍历nums2的过程中，我们要判断nums2[i]是否在nums1中出现过，因为最后是要根据nums1元素的下标来更新result数组。 注意题目中说是两个没有重复元素 的数组 nums1 和 nums2。 没有重复元素，我们就可以用HashMap来做映射了。根据数值快速找到下标，还可以判断nums2[i]是否在nums1中出现过。 3.接着使用单调栈 栈头到栈底的顺序，要从小到大，也就是保持栈里的元素为递增顺序。只要保持递增，才能找到右边第一个比自己大的元素。 可能这里有一些同学不理解，那么可以自己尝试一下用递减栈，能不能求出来。其实递减栈就是求右边第一个比自己小的元素了。 接下来就要分析如下三种情况，一定要分析清楚。 情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况 此时满足递增栈（栈头到栈底的顺序），所以直接入栈。 情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况 如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！ 情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况 此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。 判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。 记录结果这块逻辑有一点小绕，要清楚，此时栈顶元素在nums2中右面第一个大的元素是nums2[i]即当前遍历元素。 代码详情 123456789101112131415161718192021222324252627282930313233import java.util.Arrays;import java.util.HashMap;import java.util.Stack;/** * https://leetcode-cn.com/problems/next-greater-element-i/ */public class NextGreaterElement1 { public int[] nextGreaterElement(int[] nums1, int[] nums2) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int[] result = new int[nums1.length]; Arrays.fill(result, -1); //将nums1的下标，元素放入map中 for (int i = 0; i &lt; nums1.length; i++) { map.put(nums1[i], i); } stack.push(0); for (int i = 1; i &lt; nums2.length; i++) { while (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) { if (map.containsKey(nums2[stack.peek()])) { //看一下nums1中是否包含这个元素 int index = map.get(nums2[stack.peek()]); //获取该元素在nums1中的下标 result[index] = nums2[i]; } stack.pop(); } stack.push(i); } return result; }} 3.下一个更大元素IIleetcode题目链接 题目 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。 示例 1: 输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 思路分析 本题与每日温度如出一辙，不同的是，本题涉及到循环数组 代码详情 123456789101112131415161718192021222324import java.util.Arrays;import java.util.Stack;/** * https://leetcode-cn.com/problems/next-greater-element-ii/ */public class NextGreaterElement2 { public int[] nextGreaterElements(int[] nums) { int len = nums.length; int[] result = new int[len]; Arrays.fill(result, -1); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(0); for (int i = 1; i &lt; len * 2; i++) { while (!stack.isEmpty() &amp;&amp; nums[i % len] &gt; nums[stack.peek()]) { result[stack.peek()] = nums[i % len]; stack.pop(); } stack.push(i % len); } return result; }} 4.接雨水leetcode题目链接 题目 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2： 输入：height = [4,2,0,3,2,5] 输出：9 思路分析 接雨水的思路分析(代码随想录) 代码详情 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.util.Stack;/** * https://leetcode-cn.com/problems/trapping-rain-water/ */public class TrappingRainWater { //方法一：双指针解法 public int trap1(int[] height) { int len = height.length; if (len &lt;= 2) return 0; int sum = 0; for (int i = 1; i &lt; len - 1; i++) { //第一列和最后一列不接雨水 int rHeight = 0; for (int r = i + 1; r &lt; len; r++) { //找右边的最高的那一列 if (height[r] &gt; rHeight) rHeight = height[r]; } int lHeight = 0; for (int l = i - 1; l &gt;= 0; l--) { //找左边最高的那一列 if (height[l] &gt; lHeight) lHeight = height[l]; } int iheight = Math.min(lHeight, rHeight) - height[i]; //当前列的装水量 if (iheight &gt; 0) sum += iheight; } return sum; } //------------------- //方法二：动态规划解法 public int trap2(int[] height) { int len = height.length; if (len &lt;= 2) return 0; int sum = 0; int[] leftMax = new int[len]; int[] rightMax = new int[len]; for (int i = 1; i &lt; len; i++) { //记录左边最高的墙 leftMax[i] = Math.max(leftMax[i - 1], height[i - 1]); } for (int i = len - 2; i &gt;= 0; i--) { //记录右边最高的墙 rightMax[i] = Math.max(rightMax[i + 1], height[i + 1]); } for (int i = 1; i &lt; len - 1; i++) { //第一列和最后一列不记录雨水量 int iHeight = Math.min(leftMax[i], rightMax[i]) - height[i]; if (iHeight &gt; 0) sum += iHeight; } return sum; } //--------- //方法三：单调栈 public int trap(int[] height) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int len = height.length; int sum = 0; stack.push(0); for (int i = 1; i &lt; len; i++) { while (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) { int mid = stack.pop(); if (!stack.isEmpty()) { int h = Math.min(height[i], height[stack.peek()]) - height[mid]; int w = i - stack.peek() - 1; sum += h * w; } } stack.push(i); } return sum; } //---------------------------- public static void main(String[] args) { TrappingRainWater rainWater = new TrappingRainWater(); int trap = rainWater.trap(new int[]{4, 2, 0, 3, 2, 5}); System.out.println(trap); }} 5.柱状图中最大的矩形leetcode题目链接 题目 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 思路分析 参考代码随想录 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Stack;/** * https://leetcode-cn.com/problems/largest-rectangle-in-histogram/ */public class LargestRectangle { //方法一：单调栈 public static int largestRectangleArea(int[] height) { int[] heights = new int[height.length + 2]; int len = heights.length; //将新数组的首尾分别 补位 0 heights[0] = 0; heights[len - 1] = 0; for (int i = 1; i &lt; len - 1; i++) { heights[i] = height[i - 1]; } Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(0); int result = 0; for (int i = 1; i &lt; len; i++) { while (!stack.isEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()]) { int mid = stack.pop(); if (!stack.isEmpty()) { int h = heights[mid]; //注意此处的h = heights[mid],不太好理解!!! int w = i - stack.peek() - 1; result = Math.max(h * w, result); } } stack.push(i); } return result; } //---------------------------------- //方法二：双指针解法(leetcode超时) public int largestRectangleArea1(int[] heights) { int len = heights.length; int result = 0; for (int i = 0; i &lt; len; i++) { int left = i; int right = i; //向左边找，如果heights[left] &gt;= heights[i] ,则保留，直到遇到 i 左边第一个高度小于i的，结束循环 for (; left &gt;= 0; left--) { if (heights[left] &lt; heights[i]) break; } //向右边找，如果heights[left] &gt;= heights[i] ,则保留，直到遇到 i 右边第一个高度小于i的，结束循环 for (; right &lt; len; right++) { if (heights[right] &lt; heights[i]) break; } int h = heights[i]; int w = right - left - 1; result = Math.max(result, h * w); } return result; } //--------------- public static void main(String[] args) { int rectangleArea = largestRectangleArea(new int[]{2, 1, 5, 6, 2, 3}); System.out.println(rectangleArea); }} 思路分析参考：代码随想录，感谢carl哥！！！","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"https://www.colorfo.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"动态规划之子序列系列","slug":"动态规划之子序列系列","date":"2021-09-30T06:46:30.000Z","updated":"2021-09-30T13:48:44.743Z","comments":true,"path":"posts/c863.html","link":"","permalink":"https://www.colorfo.top/posts/c863.html","excerpt":"","text":"1.最长递增子序列leetcode题目链接 题目 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4 示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1 思路分析 1.dp[i]的定义 dp[i]表示i之前包括i的最长上升子序列。 2.状态转移方程 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。 所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1); 注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值。 3.dp[i]的初始化 每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是是1. 4.确定遍历顺序 dp[i] 是有0到i-1各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。 j其实就是0到i-1，遍历i的循环里外层，遍历j则在内层 5.举例推导dp数组 输入：[0,1,0,3,2]，dp数组的变化如下： 代码详情 1234567891011121314151617181920212223import java.util.Arrays;/** * https://leetcode-cn.com/problems/longest-increasing-subsequence/ */public class LongestIncreasingSubsequence { public int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; //dp[i] 表示i之前包括i的最长上升子序列 int result = 0; Arrays.fill(dp, 1); //dp[i] 的初始值为1 for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; i; j++) { if (nums[i] &gt; nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } result = dp[i] &gt; result ? dp[i] : result; //不一定dp[n - 1]就是最长的子序列， // 所以要在遍历的过程中，保存最大值。 } return result; }} 2.最长连续递增序列leetcode题目链接 题目 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。 示例 1： 输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 示例 2： 输入：nums = [2,2,2,2,2] 输出：1 解释：最长连续递增序列是 [2], 长度为1。 思路分析 1.确定dp数组（dp table）以及下标的含义 **dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]**。 注意这里的定义，一定是以下标i为结尾，并不是说一定以下标0为起始位置。 2.确定递推公式 如果 nums[i + 1] &gt; nums[i]，那么以 i+1 为结尾的数组的连续递增的子序列长度 一定等于 以i为结尾的数组的连续递增的子序列长度 + 1 。 即：dp[i + 1] = dp[i] + 1; 3.dp数组如何初始化 以下标i为结尾的数组的连续递增的子序列长度最少也应该是1，即就是nums[i]这一个元素。 所以dp[i]应该初始1; 4.确定遍历顺序 从递推公式上可以看出， dp[i + 1]依赖dp[i]，所以一定是从前向后遍历。 代码详情 1234567891011121314151617181920import java.util.Arrays;/** * https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/ */public class LongestContinueSub { public int findLengthOfLCIS(int[] nums) { int n = nums.length; if (n == 1) return 1; int[] dp = new int[n]; //dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]。 Arrays.fill(dp, 1); int result = 0; for (int i = 1; i &lt; n; i++) { if (nums[i] &gt; nums[i - 1]) dp[i] = dp[i - 1] + 1; result = result &gt; dp[i] ? result : dp[i]; } return result; }} 3.最长重复子数组leetcode题目链接 题目 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。 示例： 输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释： 长度最长的公共子数组是 [3, 2, 1] 。 思路分析 1.确定dp数组（dp table）以及下标的含义 dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。 2.确定递推公式 根据dp[i][j]的定义，dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来。 即当A[i - 1] 和B[j - 1]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1; 根据递推公式可以看出，遍历i 和 j 要从1开始！ 3.dp数组如何初始化 根据dp[i][j]的定义，dp[i][0] 和dp[0][j]其实都是没有意义的！ 但dp[i][0] 和dp[0][j]要初始值，因为 为了方便递归公式dp[i][j] = dp[i - 1][j - 1] + 1; 所以dp[i][0] 和dp[0][j]初始化为0。 举个例子A[0]如果和B[0]相同的话，dp[1][1] = dp[0][0] + 1，只有dp[0][0]初始为0，正好符合递推公式逐步累加起来。 4.确定遍历顺序 外层for循环遍历A，内层for循环遍历B。 5.举例推导dp数组 拿示例1中，A: [1,2,3,2,1]，B: [3,2,1,4,7]为例，画一个dp数组的状态变化，如下： 代码详情 12345678910111213141516171819202122/** * https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/ */public class MaxRepeatedSubarray { public int findLength(int[] nums1, int[] nums2) { int n1 = nums1.length; int n2 = nums2.length; //dp[i][j] ：以下标i - 1为结尾的nums1，和以下标j - 1为结尾的nums2，最长重复子数组长度为dp[i][j]。 int[][] dp = new int[n1 + 1][n2 + 1]; int result = 0; for (int i = 1; i &lt;= n1; i++) { for (int j = 1; j &lt;= n2; j++) { if (nums1[i - 1] == nums2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } result = result &gt; dp[i][j] ? result : dp[i][j]; } } return result; }} 4.最长公共子序列leetcode题目链接 题目 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 示例 1: 输入：text1 = “abcde”, text2 = “ace”输出：3解释：最长公共子序列是 “ace”，它的长度为 3。 示例 2:输入：text1 = “abc”, text2 = “abc”输出：3解释：最长公共子序列是 “abc”，它的长度为 3。 示例 3:输入：text1 = “abc”, text2 = “def”输出：0解释：两个字符串没有公共子序列，返回 0。 思路分析 1.确定dp数组（dp table）以及下标的含义 dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j] 有同学会问：为什么要定义长度为[0, i - 1]的字符串text1，定义为长度为[0, i]的字符串text1不香么？ 这样定义是为了后面代码实现方便，如果非要定义为为长度为[0, i]的字符串text1也可以，大家可以试一试！ 2.确定递推公式 主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同 如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1; 如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。 即：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); 3.dp数组如何初始化 先看看dp[i][0]应该是多少呢？ test1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i][0] = 0; 同理dp[0][j]也是0。 4.确定遍历顺序 从前向后，从上到下来遍历这个矩阵。 5.举例推导dp数组 以输入：text1 = “abcde”, text2 = “ace” 为例，dp状态如图： 代码详情 12345678910111213141516171819202122/** * https://leetcode-cn.com/problems/longest-common-subsequence/ */public class LongestCommonSubsequence { public int longestCommonSubsequence(String text1, String text2) { char[] str1 = text1.toCharArray(); char[] str2 = text2.toCharArray(); //dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j] int[][] dp = new int[str1.length + 1][str2.length + 1]; for (int i = 1; i &lt;= str1.length; i++) { for (int j = 1; j &lt;= str2.length; j++) { if (str1[i - 1] == str2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[str1.length][str2.length]; }} 5.不相交的线leetcode题目链接 题目 我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。 现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。 以这种方法绘制线条，并返回我们可以绘制的最大连线数。 思路分析 本题与4.最长公共子序列其实是一个题目，都是找最长的公共子序列 代码详情 123456789101112131415161718192021/** * https://leetcode-cn.com/problems/uncrossed-lines/ */public class UncrossedLines { public int maxUncrossedLines(int[] nums1, int[] nums2) { int n1 = nums1.length; int n2 = nums2.length; //dp[i][j]：长度为[0, i - 1]的数组nums1 与 长度为[0, j - 1]的数组nums2的最长公共子序列为dp[i][j] int[][] dp = new int[n1 + 1][n2 + 1]; for (int i = 1; i &lt;= n1; i++) { for (int j = 1; j &lt;= n2; j++) { if (nums1[i - 1] == nums2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[n1][n2]; }} 6.最大子序和leetcode题目链接 题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6 思路分析 动规五部曲如下： 1.确定dp数组（dp table）以及下标的含义 **dp[i]：包括下标i之前的最大连续子序列和为dp[i]**。 2.确定递推公式 dp[i]只有两个方向可以推出来： dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和 nums[i]，即：从头开始计算当前连续子序列和 一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i]); 3.dp数组如何初始化 从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。 dp[0]应该是多少呢? 更具dp[i]的定义，很明显dp[0]因为为nums[0]即dp[0] = nums[0]。 4.确定遍历顺序 递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。 5.举例推导dp数组 以示例一为例，输入：nums = [-2,1,-3,4,-1,2,1,-5,4]，对应的dp状态如下： 代码详情 123456789101112131415161718/** * https://leetcode-cn.com/problems/maximum-subarray/ */public class MaximumSubarray { public int maxSubArray(int[] nums) { if (nums.length == 1) return nums[0]; //dp[i] 表示i之前的最大子序列和 int[] dp = new int[nums.length]; dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i &lt; nums.length; i++) { dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); if (dp[i] &gt; result) result = dp[i]; } return result; }} 7. 判断子序列leetcode题目链接 题目 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1： 输入：s = “abc”, t = “ahbgdc” 输出：true 示例 2： 输入：s = “axc”, t = “ahbgdc” 输出：false 思路分析 动态规划五部曲分析如下： 1.确定dp数组（dp table）以及下标的含义 **dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]**。 2.确定递推公式 在确定递推公式的时候，首先要考虑如下两种操作，整理如下： if (s[i - 1] == t[j - 1]) t中找到了一个字符在s中也出现了 if (s[i - 1] != t[j - 1]) 相当于t要删除元素，继续匹配 if (s[i - 1] == t[j - 1])，那么dp[i][j] = dp[i - 1][j - 1] + 1;，因为找到了一个相同的字符，相同子序列长度自然要在dp[i-1][j-1]的基础上加1（**如果不理解，在回看一下dp[i][j]的定义**） if (s[i - 1] != t[j - 1])，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i][j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i][j] = dp[i][j - 1]; 3.dp数组如何初始化 从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，所以dp[0][0]和dp[i][0]是一定要初始化的。 4.确定遍历顺序 同理从从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，那么遍历顺序也应该是从上到下，从左到右 5.举例推导dp数组 以示例一为例，输入：s = “abc”, t = “ahbgdc”，dp状态转移图如下： 代码详情 123456789101112131415161718192021222324252627/** * https://leetcode-cn.com/problems/is-subsequence/ */public class IsSubsequence { public boolean isSubsequence(String s, String t) { if (s.length() == 0) return true; if (t.length() == 0) return false; int n1 = s.length(); int n2 = t.length(); //dp[i][j] 表示 如果长度为i的s 是 长度为j的t的子串 , 则dp[i][j] == s.length int[][] dp = new int[n1 + 1][n2 + 1]; char[] str1 = s.toCharArray(); char[] str2 = t.toCharArray(); for (int i = 1; i &lt;= n1; i++) { for (int j = 1; j &lt;= n2 ; j++) { if (str1[i - 1] == str2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { //此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i][j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i][j] = dp[i][j - 1]; dp[i][j] = dp[i][j - 1]; } } } return dp[n1][n2] == s.length(); }} 8.不同的子序列leetcode题目链接 题目 给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是） 题目数据保证答案符合 32 位带符号整数范围。 思路分析 五部曲分析如下： 1.确定dp数组（dp table）以及下标的含义 dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。 2.确定递推公式 这一类问题，基本是要分析两种情况 s[i - 1] 与 t[j - 1]相等 s[i - 1] 与 t[j - 1] 不相等 当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。 一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。 一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。 这里可能有同学不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。 例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。 当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。 3.dp数组如何初始化 从递推公式dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] = dp[i - 1][j]; 中可以看出dp[i][0] 和dp[0][j]是一定要初始化的。 每次当初始化的时候，先回顾一下dp[i][j]的定义，不要凭感觉初始化。 dp[i][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。 那么dp[i][0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。 再来看，dp[0][j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。 那么dp[0][j]一定都是0，s如论如何也变成不了t。 最后就要看一个特殊位置了，即：dp[0][0] 应该是多少。 dp[0][0]应该是1，空字符串s，可以删除0个元素，变成空字符串t。 4.确定遍历顺序 从递推公式dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] = dp[i - 1][j]; 中可以看出dp[i][j]都是根据左上方和正上方推出来的。 所以遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。 5.举例推导dp数组 以s：”baegg”，t：”bag”为例，推导dp数组状态如下： 代码详情 12345678910111213141516171819202122232425/** * https://leetcode-cn.com/problems/distinct-subsequences/ */public class DifferentSubsequence { public int numDistinct(String s, String t) { //dp[i][j] 表示下标为i-1的s 包含 下标为j-1的t 的个数 int[][] dp = new int[s.length() + 1][t.length() + 1]; //初始化dp数组 for (int i = 0; i &lt;= s.length(); i++) { dp[i][0] = 1; } for (int i = 1; i &lt;= s.length(); i++) { for (int j = 1; j &lt;= t.length(); j++) { if (s.charAt(i - 1) == t.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j]; } } } return dp[s.length()][t.length()]; }} 9.两个字符串的删除操作leetcode题目链接 题目 给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。 示例： 输入: “sea”, “eat”输出: 2 解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea” 思路分析 动规五部曲，分析如下： 1.确定dp数组（dp table）以及下标的含义 dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。 2.确定递推公式 当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1]; 当word1[i - 1] 与 word2[j - 1]不相同的时候，有二种情况： 情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1 情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1 3.dp数组如何初始化 从递推公式中，可以看出来，dp[i][0] 和 dp[0][j]是一定要初始化的。 dp[i][0]：word2为空字符串，以i-1为结尾的字符串word2要删除多少个元素，才能和word1相同呢，很明显dp[i][0] = i。 dp[0][j]的话同理 4.确定遍历顺序 从递推公式 dp[i][j] = min(dp[i - 1][j - 1] + 2, min(dp[i - 1][j], dp[i][j - 1]) + 1); 和dp[i][j] = dp[i - 1][j - 1]可以看出dp[i][j]都是根据左上方、正上方、正左方推出来的。 所以遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。 5.举例推导dp数组 以word1:”sea”，word2:”eat”为例，推导dp数组状态图如下： 代码详情 12345678910111213141516171819202122232425262728/** * https://leetcode-cn.com/problems/delete-operation-for-two-strings/ */public class DeleteTwoStrings { public int minDistance(String word1, String word2) { //dp[i][j] 表示 使得以下标i-1结尾的word1 和 以j-1为结尾的word2 相同，所需要删除字符的最小个数 int[][] dp = new int[word1.length() + 1][word2.length() + 1]; //dp数组初始化 for (int i = 1; i &lt;= word1.length(); i++) { dp[i][0] = i; } for (int j = 1; j &lt;= word2.length(); j++) { dp[0][j] = j; } for (int i = 1; i &lt;= word1.length(); i++) { for (int j = 1; j &lt;= word2.length(); j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1); } } } return dp[word1.length()][word2.length()]; }} 10.编辑距离leetcode题目链接 题目 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 输入：word1 = “horse”, word2 = “ros” 输出：3 解释： horse -&gt; rorse (将 ‘h’ 替换为 ‘r’) rorse -&gt; rose (删除 ‘r’) rose -&gt; ros (删除 ‘e’) 示例 2： 输入：word1 = “intention”, word2 = “execution” 输出：5 解释： intention -&gt; inention (删除 ‘t’) inention -&gt; enention (将 ‘i’ 替换为 ‘e’) enention -&gt; exention (将 ‘n’ 替换为 ‘x’) exention -&gt; exection (将 ‘n’ 替换为 ‘c’) exection -&gt; execution (插入 ‘u’) 思路分析 1.确定dp数组（dp table）以及下标的含义 **dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]**。 2.确定递推公式 1).当匹配上时 1if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1]; 2).当匹配不上时 if (word1[i - 1] != word2[j - 1])，此时就需要编辑了，如何编辑呢？ 操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。 即 dp[i][j] = dp[i - 1][j] + 1; 操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。 即 dp[i][j] = dp[i][j - 1] + 1; 这里有同学发现了，怎么都是删除元素，添加元素去哪了。 word2添加一个元素，相当于word1删除一个元素，例如 word1 = \"ad\" ，word2 = \"a\"，word1删除元素'd' 和 word2添加一个元素'd'，变成word1=\"a\", word2=\"ad\"， 最终的操作数是一样！ 操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增加元素，那么以下标i-2为结尾的word1 与 j-2为结尾的word2的最近编辑距离 加上一个替换元素的操作。 即 dp[i][j] = dp[i - 1][j - 1] + 1; 综上，当 if (word1[i - 1] != word2[j - 1]) 时取最小的，即：dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1; 3.dp数组初始化 1234567891011再回顾一下dp[i][j]的定义：**dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]**。那么dp[i][0] 和 dp[0][j] 表示什么呢？dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i;同理dp[0][j] = j; 4.遍历顺序 在dp矩阵从左到右从上到下去遍历。 5.距离推导dp数组 以示例1为例，输入：word1 = \"horse\", word2 = \"ros\"为例，dp矩阵状态图如下： 代码详情 12345678910111213141516171819202122232425262728/** * https://leetcode-cn.com/problems/edit-distance/ */public class EditDistance { public int minDistance(String word1, String word2) { //dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。 int[][] dp = new int[word1.length() + 1][word2.length() + 1]; //dp数组初始化 for (int i = 1; i &lt;= word1.length(); i++) { dp[i][0] = i; } for (int j = 1; j &lt;= word2.length(); j++) { dp[0][j] = j; } for (int i = 1; i &lt;= word1.length(); i++) { for (int j = 1; j &lt;= word2.length(); j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1; } } } return dp[word1.length()][word2.length()]; }} 11.回文子串leetcode题目链接 题目 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 输入：”abc” 输出：3 解释：三个回文子串: “a”, “b”, “c” 示例 2： 输入：”aaa” 输出：6 解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa” 思路分析 两层for循环，遍历区间起始位置和终止位置，然后判断这个区间是不是回文。 代码详情 1234567891011121314151617181920212223242526/** * https://leetcode-cn.com/problems/palindromic-substrings/ */public class PalindromicSubstrings { //暴力匹配 public int countSubstrings2(String s) { int sum = s.length(); for (int i = 0; i &lt; s.length(); i++) { for (int j = i + 1; j &lt; s.length(); j++) { //如果s的(i,j)这部分是回文子串，则sum+1 if (isPalindromic(i,j,s)) sum += 1; } } return sum; } private boolean isPalindromic(int start, int end, String s) { while (start &lt; end) { if (s.charAt(start) != s.charAt(end)) return false; start++; end--; } return true; }} 12.最长回文子序列leetcode题目链接 题目 给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。 示例 1: 输入: “bbbab” 输出: 4 一个可能的最长回文子序列为 “bbbb”。 示例 2: 输入:”cbbd” 输出: 2 一个可能的最长回文子序列为 “bb”。 思路分析 动规五部曲分析如下： 1.确定dp数组（dp table）以及下标的含义 **dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]**。 2.确定递推公式 在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。 如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2; 如图： 如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子串的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。 加入s[j]的回文子序列长度为dp[i + 1][j]。 加入s[i]的回文子序列长度为dp[i][j - 1]。 那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); 3.dp数组如何初始化 首先要考虑当i 和j 相同的情况，从递推公式：dp[i][j] = dp[i + 1][j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。 所以需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1。 其他情况dp[i][j]初始为0就行，这样递推公式：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); 中dp[i][j]才不会被初始值覆盖。 4.确定遍历顺序 从递推公式dp[i][j] = dp[i + 1][j - 1] + 2 和 dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) 可以看出，dp[i][j]是依赖于dp[i + 1][j - 1] 和 dp[i + 1][j]， 也就是从矩阵的角度来说，dp[i][j] 下一行的数据。 所以遍历i的时候一定要从下到上遍历，这样才能保证，下一行的数据是经过计算的。 递推公式：dp[i][j] = dp[i + 1][j - 1] + 2，dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) 分别对应着下图中的红色箭头方向，如图： 5.举例推导dp数组 输入s:”cbbd” 为例，dp数组状态如图： 红色框即：dp[0][s.size() - 1]; 为最终结果。 代码详情 12345678910111213141516171819202122232425/** * https://leetcode-cn.com/problems/longest-palindromic-subsequence/ */public class LongestPalindromicSubsequence { public int longestPalindromeSubseq(String s) { //dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。 int[][] dp = new int[s.length()][s.length()]; //dp数组初始化 for (int i = 0; i &lt; s.length(); i++) { dp[i][i] = 1; } //注意遍历顺序和递推公式 for (int i = s.length() - 1; i &gt;= 0; i--) { for (int j = i + 1; j &lt; s.length(); j++) { if (s.charAt(i) == s.charAt(j)) { dp[i][j] = dp[i + 1][j - 1] + 2; } else { dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); } } } return dp[0][s.length() - 1]; }} 以上思路分析，参考:代码随想录，题目来自：LeetCode 感谢carl哥!!!","categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://www.colorfo.top/tags/dp/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.colorfo.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"子序列","slug":"子序列","permalink":"https://www.colorfo.top/tags/%E5%AD%90%E5%BA%8F%E5%88%97/"}]},{"title":"动态规划之买卖股票专题","slug":"动态规划之买卖股票专题","date":"2021-09-27T06:50:14.000Z","updated":"2021-09-27T08:42:24.971Z","comments":true,"path":"posts/87d3.html","link":"","permalink":"https://www.colorfo.top/posts/87d3.html","excerpt":"","text":"1.买卖股票的最佳时机leetcode题目链接 题目 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1：输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 思路分析 1.确定dp数组（dp table）以及下标的含义 dp[i][0] 表示第i天持有股票所得最多现金 ，这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？ 其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。 dp[i][1] 表示第i天不持有股票所得最多现金 注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态 很多同学把“持有”和“买入”没分区分清楚。 2.确定递推公式 如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0] 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i] 那么dp[i][0]应该选所得现金最大的，所以dp[i][0] = max(dp[i - 1][0], -prices[i]); 如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1] 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0] 同样dp[i][1]取最大的，dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]); 3.dp数组的初始化 那么dp[0][0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0][0] -= prices[0]; dp[0][1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0][1] = 0; 4.遍历顺序 从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。 5.举例推导dp数组 以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下： 代码详情 123456789101112131415161718192021222324252627282930313233/** * https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ */public class SellStock { //贪心算法 public int maxProfit2(int[] prices) { int low = Integer.MAX_VALUE; int result = 0; for (int i = 0; i &lt; prices.length; i++) { low = Math.min(low, prices[i]); result = Math.max(result, prices[i] - low); } return result; } //动态规划 public int maxProfit(int[] prices) { if (prices.length == 1) return 0; // dp[i][0] 表示第i天持有股票，所剩余的最大金额 // dp[i][1] 表示第i天不持有股票，所剩余的最大金额 int[][] dp = new int[prices.length][2]; dp[0][0] = -prices[0]; for (int i = 1; i &lt; prices.length; i++) { dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]); } return dp[prices.length - 1][1]; }} 2.买卖股票的最佳时机IIleetcode题目链接 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 思路分析 此题与1.买卖股票的最佳时机最大的区别就是可以多次买卖股票 需要修改的关键代码： 1234for (int i = 1; i &lt; prices.length; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);} 代码详情 123456789101112131415161718192021222324252627282930313233/** * https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ */public class SellStock { //贪心算法 public int maxProfit2(int[] prices) { int low = Integer.MAX_VALUE; int result = 0; for (int i = 0; i &lt; prices.length; i++) { low = Math.min(low, prices[i]); result = Math.max(result, prices[i] - low); } return result; } //动态规划 public int maxProfit(int[] prices) { if (prices.length == 1) return 0; // dp[i][0] 表示第i天持有股票，所剩余的最大金额 // dp[i][1] 表示第i天不持有股票，所剩余的最大金额 int[][] dp = new int[prices.length][2]; dp[0][0] = -prices[0]; for (int i = 1; i &lt; prices.length; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]); } return dp[prices.length - 1][1]; }} 3.买卖股票的最佳时机含手续费 题目 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8 解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 思路分析 此题与2.买卖股票的最佳时机II最大的区别就是:在卖股票时，需要收取手续费 所以只需要在卖股票时减去手续费即可 要修改的关键代码： 1234for (int i = 1; i &lt; prices.length; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);} 代码详情 123456789101112131415/** * https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/ */public class SellStockWithFee { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = -prices[0]; for (int i = 1; i &lt; n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee); } return dp[n - 1][1]; }} 4.买卖股票的最佳时机IIIleetcode题目链接 题目 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。 示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为0。 示例 4： 输入：prices = [1] 输出：0 思路分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。接来下我用动态规划五部曲详细分析一下：1.确定dp数组以及下标的含义一天一共就有五个状态， 0. 没有操作1第一次买入2第一次卖出3第二次买入4第二次卖出dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。2.确定递推公式需要注意：dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区。达到dp[i][1]状态，有两个具体操作：操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？一定是选最大的，所以 dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);同理dp[i][2]也有两个操作：操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])同理可推出剩下状态部分：dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);3.dp数组如何初始化第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;第0天做第一次买入的操作，dp[0][1] = -prices[0];第0天做第一次卖出的操作，这个初始值应该是多少呢？首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。所以dp[0][2] = 0;第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。所以第二次买入操作，初始化为：dp[0][3] = -prices[0];同理第二次卖出初始化dp[0][4] = 0;4.确定遍历顺序从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。 5.举例推导dp数组 以输入[1,2,3,4,5]为例 大家可以看到红色框为最后两次卖出的状态。 现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。 所以最终最大利润是dp[4][4] 代码详情 123456789101112131415161718192021/** *https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/ */public class SellStock3 { public int maxProfit(int[] prices) { //dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。 int[][] dp = new int[prices.length][5]; dp[0][1] = -prices[0]; dp[0][3] = -prices[0]; for (int i = 1; i &lt; prices.length; i++) { dp[i][0] = dp[i - 1][0]; dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]); dp[i][2] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][2]); dp[i][3] = Math.max(dp[i - 1][2] - prices[i], dp[i - 1][3]); dp[i][4] = Math.max(dp[i - 1][3] + prices[i], dp[i - 1][4]); } return dp[prices.length - 1][4]; }} 5.买卖股票的最佳时机IVleetcode题目链接 题目 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2。 示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 思路分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374动规五部曲，分析如下：******1.确定dp数组以及下标的含义******在动态规划：4.买卖股票的最佳时机III中，我是定义了一个二维dp数组，本题其实依然可以用一个二维dp数组。使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]j的状态表示为：0 表示不操作1 第一次买入2 第一次卖出3 第二次买入4 第二次卖出.....大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入。题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。******2.确定递推公式******还要强调一下：dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区。达到dp[i][1]状态，有两个具体操作：操作一：第i天买入股票了，那么dp[i][1] = dp[i - 1][0] - prices[i]操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]选最大的，所以 dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][0]);同理dp[i][2]也有两个操作：操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]所以dp[i][2] = max(dp[i - 1][i] + prices[i], dp[i][2])同理可以类比剩下的状态，代码如下：for (int j = 0; j &lt; 2 * k - 1; j += 2) { dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]); dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);}本题和动态规划：123.买卖股票的最佳时机III最大的区别就是这里要类比j为奇数是买，偶数是卖剩的状态。******3.dp数组如何初始化******第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;第0天做第一次买入的操作，dp[0][1] = -prices[0];第0天做第一次卖出的操作，这个初始值应该是多少呢？首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。所以dp[0][2] = 0;第0天第二次买入操作，初始值应该是多少呢？不用管第几次，现在手头上没有现金，只要买入，现金就做相应的减少。第二次买入操作，初始化为：dp[0][3] = -prices[0];所以同理可以推出dp[0][j]当j为奇数的时候都初始化为 -prices[0]代码如下：for (int j = 1; j &lt; 2 * k; j += 2) { dp[0][j] = -prices[0];}在初始化的地方同样要类比j为偶数是卖、奇数是买的状态。******4.确定遍历顺序******从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。 代码详情 123456789101112131415161718192021/** * https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/ */public class SellStock4 { public int maxProfit(int k, int[] prices) { if (prices.length == 0) return 0; int[][] dp = new int[prices.length][2 * k + 1]; for (int j = 1; j &lt; 2 * k; j += 2) { dp[0][j] = -prices[0]; } for (int i = 1; i &lt; prices.length; i++) { for (int j = 0; j &lt; 2 * k - 1; j+= 20) { dp[i][j + 1] = Math.max(dp[i - 1][j] - prices[i], dp[i - 1][j + 1]); dp[i][j + 2] = Math.max(dp[i - 1][j + 1] + prices[i], dp[i - 1][j + 2]); } } return dp[prices.length - 1][2 * k]; }} 6.最佳买卖股票时机含冷冻期leetcode题目链接 题目 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 思路分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071动规五部曲，分析如下：******1.确定dp数组以及下标的含义******dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。其实本题很多同学搞的比较懵，是因为出现冷冻期之后，状态其实是比较复杂度，例如今天买入股票、今天卖出股票、今天是冷冻期，都是不能操作股票的。 具体可以区分出如下四个状态：状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）卖出股票状态，这里就有两种卖出股票状态状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态状态三：今天卖出了股票状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！j的状态为：0：状态一1：状态二2：状态三3：状态四很多题解为什么讲的比较模糊，是因为把这四个状态合并成三个状态了，其实就是把状态二和状态四合并在一起了。从代码上来看确实可以合并，但从逻辑上分析合并之后就很难理解了，所以我下面的讲解是按照这四个状态来的，把每一个状态分析清楚。注意这里的每一个状态，例如状态一，是买入股票状态并不是说今天已经就买入股票，而是说保存买入股票的状态即：可能是前几天买入的，之后一直没操作，所以保持买入股票的状态。******2.确定递推公式******达到买入股票状态（状态一）即：dp[i][0]，有两个具体操作：操作一：前一天就是持有股票状态（状态一），dp[i][0] = dp[i - 1][0]操作二：今天买入了，有两种情况前一天是冷冻期（状态四），dp[i - 1][3] - prices[i]前一天是保持卖出股票状态（状态二），dp[i - 1][1] - prices[i]所以操作二取最大值，即：max(dp[i - 1][3], dp[i - 1][1]) - prices[i]那么dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);达到保持卖出股票状态（状态二）即：dp[i][1]，有两个具体操作：操作一：前一天就是状态二操作二：前一天是冷冻期（状态四）dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作：操作一：昨天一定是买入股票状态（状态一），今天卖出即：dp[i][2] = dp[i - 1][0] + prices[i];达到冷冻期状态（状态四），即：dp[i][3]，只有一个操作：操作一：昨天卖出了股票（状态三）p[i][3] = dp[i - 1][2];综上分析，递推代码如下：dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i];dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);dp[i][2] = dp[i - 1][0] + prices[i];dp[i][3] = dp[i - 1][2];******3.dp数组如何初始化******这里主要讨论一下第0天如何初始化。如果是持有股票状态（状态一）那么：dp[0][0] = -prices[0]，买入股票所省现金为负数。保持卖出股票状态（状态二），第0天没有卖出dp[0][1]初始化为0就行，今天卖出了股票（状态三），同样dp[0][2]初始化为0，因为最少收益就是0，绝不会是负数。同理dp[0][3]也初始为0。******4.确定遍历顺序******从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。 代码详情 1234567891011121314151617181920/** * https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ */public class SellStockWithCooldown { public int maxProfit(int[] prices) { int n = prices.length; if (n &lt; 2) return 0; int[][] dp = new int[n][4]; dp[0][0] = -prices[0]; for (int i = 1; i &lt; n; i++) { dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i])); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]); dp[i][2] = dp[i - 1][0] + prices[i]; dp[i][3] = dp[i - 1][2]; } return Math.max(dp[n - 1][3], Math.max(dp[n - 1][1], dp[n - 1][2])); }}","categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://www.colorfo.top/tags/dp/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.colorfo.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"买卖股票","slug":"买卖股票","permalink":"https://www.colorfo.top/tags/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/"}]},{"title":"动态规划刷题笔记②","slug":"动态规划刷题笔记②","date":"2021-09-25T06:04:16.000Z","updated":"2021-09-27T06:48:07.701Z","comments":true,"path":"posts/91bd.html","link":"","permalink":"https://www.colorfo.top/posts/91bd.html","excerpt":"","text":"完全背包理论有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。 同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理。 在下面的讲解中，我依然举这个例子： 背包最大重量为4。 物品为： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 每件商品都有无限个！ 问背包能背的物品最大价值是多少？ 01背包和完全背包唯一不同就是体现在遍历顺序上 思路分析：完全背包理论基础 代码详情 对于纯完全背包问题，两层for循环的先后循环是可以颠倒的！并且内层for循环采用正序遍历(从小到大) 12345678910111213141516171819202122232425262728import java.util.Arrays;/** * 有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。 * 每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。 * (完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。) */public class CompletePack { public static int testCompletePack(int[] weight, int[] value, int bagWeight) { int n = weight.length; int[] dp = new int[bagWeight + 1]; for (int i = 0; i &lt; n; i++) { for (int j = weight[i]; j &lt;= bagWeight; j++) { dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); } } System.out.println(Arrays.toString(dp)); return dp[bagWeight]; } //------------------- public static void main(String[] args) { int[] weight = {1,3,4}; int[] value = {15,20,30}; testCompletePack(weight,value,4); }} 1.零钱兑换leetcode题目链接 题目 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 示例 1: 输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。 示例 3: 输入: amount = 10, coins = [10] 输出: 1 注意，你可以假设： 0 &lt;= amount (总金额) &lt;= 5000 1 &lt;= coin (硬币面额) &lt;= 5000 硬币种类不超过 500 种 结果符合 32 位符号整数 思路分析 确定dp数组以及下标的含义 dp[j]：凑成总金额j的货币组合数为dp[j] 确定递推公式 dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。 所以递推公式：dp[j] += dp[j - coins[i]]; dp数组如何初始化 首先dp[0]一定要为1，dp[0] = 1是 递归公式的基础。 从dp[i]的含义上来讲就是，凑成总金额0的货币组合数为1。 下标非0的dp[j]初始化为0，这样累计加dp[j - coins[i]]的时候才不会影响真正的dp[j] 确定遍历顺序 因为本题是求组合数，所以先遍历物品，再遍历背包容量 举例推导dp数组 输入: amount = 5, coins = [1, 2, 5] ，dp状态图如下： 代码详情 123456789101112131415161718192021222324252627282930import java.util.Arrays;/** * https://leetcode-cn.com/problems/coin-change-2/ */public class CoinChange { public int change(int amount, int[] coins) { int n = coins.length; int[] dp = new int[amount + 1]; //dp[i] 表示 装满容量为i的背包有多少种方法 dp[0] = 1; for (int i = 0; i &lt; n; i++) { //遍历物品(也就是硬币) for (int j = coins[i]; j &lt;= amount; j++) { //遍历背包 dp[j] += dp[j - coins[i]]; } System.out.println(Arrays.toString(dp)); } return dp[amount]; } //-------------- public static void main(String[] args) { CoinChange change = new CoinChange(); int change1 = change.change(5, new int[]{1, 2, 5}); System.out.println(change1); }} 2. 组合总和 Ⅳleetcode题目链接 题目 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例: nums = [1, 2, 3] target = 4 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 因此输出为 7 思路分析 确定dp数组以及下标的含义 dp[i] 凑成目标正整数为i的排列数为dp[i] dp数组的初始化 dp[0] = 1; 确定遍历顺序 因为是求排列数，所以先遍历背包容量，再遍历物品 递推表达式 dp[j] += dp[j - nums[j]]; 举例推导dp数组 代码详情 1234567891011121314151617181920/** * https://leetcode-cn.com/problems/combination-sum-iv/ */public class CombinationSum4 { public int combinationSum4(int[] nums, int target) { int n = nums.length; int[] dp = new int[target + 1]; //dp[i] 表示 容量为i的背包 一共有多少种排列 //即-dp[i]: 凑成目标正整数为i的排列个数为dp[i] dp[0] = 1; for (int j = 1; j &lt;= target; j++) { //先遍历背包，再遍历物品，求排列 for (int i = 0; i &lt; n; i++) { //背包比物品大，才可放入 if (j &gt;= nums[i]) dp[j] += dp[j - nums[i]]; } } return dp[target]; }} 3.爬楼梯(进阶版) 题目 一步一个台阶，两个台阶，三个台阶，…….，直到 m个台阶。问有多少种不同的方法可以爬到楼顶n呢？ 思路分析 1阶，2阶，…. m阶就是物品，楼顶就是背包。 每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。 问跳到楼顶有几种方法其实就是问装满背包有几种方法。 此时大家应该发现这就是一个完全背包问题了！ 并且这是完全背包里求排列问题，即：1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！ 代码详情 12345678910111213141516171819/** * 改为：一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。 * 问有多少种不同的方法可以爬到楼顶呢？ */public class ClimbingStairs2 { public int climStairs(int n, int m) { //n表示一共有n个台阶，m表示一次最多可以跳m步 int[] dp = new int[n + 1]; dp[0] = 1; //完全背包中的排列问题 for (int j = 1; j &lt;= n; j++) { //先遍历背包 for (int i = 1; i &lt;= m; i++) { //再遍历物品 if (j &gt;= i) dp[j] += dp[j - i]; } } return dp[n]; }} 4.零钱兑换leetcode题目链接 题目 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 你可以认为每种硬币的数量是无限的。 示例 1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2： 输入：coins = [2], amount = 3 输出：-1 示例 3： 输入：coins = [1], amount = 0 输出：0 示例 4： 输入：coins = [1], amount = 1 输出：1 示例 5： 输入：coins = [1], amount = 2 输出：2 思路分析 确定dp数组以及下标的含义 dp[j]：凑足总额为j所需钱币的最少个数为dp[j] 确定递推公式 得到dp[j]（考虑coins[i]），只有一个来源，dp[j - coins[i]]（没有考虑coins[i]）。 凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]） 所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。 递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); dp数组如何初始化 首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0; 其他下标对应的数值呢？ 考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。 所以下标非0的元素都是应该是最大值。 确定遍历顺序 本题求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。。 所以本题并不强调集合是组合还是排列。 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。 所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！ 本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序 综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。 举例推导dp数组 以输入：coins = [1, 2, 5], amount = 5为例 代码详情 1234567891011121314151617181920212223242526import java.util.Arrays;public class CoinChange2 { public int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; coins.length; i++) { for (int j = coins[i]; j &lt;= amount ; j++) { if (dp[j - coins[i]] != Integer.MAX_VALUE) { //如果dp[j - coins[i]]是初始值则跳过 dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1); } } } if (dp[amount] == Integer.MAX_VALUE) return -1; return dp[amount]; } //============ public static void main(String[] args) { CoinChange2 coinChange2 = new CoinChange2(); int i = coinChange2.coinChange(new int[]{1,2,5}, 5); System.out.println(i); }} 5.完全平方数leetcode题目链接 题目 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4 示例 2： 输入：n = 13 输出：2 解释：13 = 4 + 9 提示：1 &lt;= n &lt;= 10^4 思路分析 确定dp数组（dp table）以及下标的含义 dp[i]：和为i的完全平方数的最少数量为dp[i] 确定递推公式 dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。 此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]); dp数组如何初始化 dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。 确定遍历顺序 本题外层for遍历背包，里层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！ 这里给出外层遍历物品，里层遍历背包容量的代码 举例推导dp数组 已输入n为5例，dp状态图如下： 代码详情 123456789101112131415public class PerfectSquares { public int numSquares(int n) { int[] dp = new int[n + 1]; //组成i,所需的完全平方数的最小个数dp[i] Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 1; i * i &lt;= n; i++) { //遍历物品 for (int j = i * i; j &lt;= n; j++) { //遍历背包 dp[j] = Math.min(dp[j], dp[j - i * i] + 1); } } return dp[n]; }} 6.单词拆分leetcode题目链接 题目 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 输入: s = “leetcode”, wordDict = [“leet”, “code”] 输出: true 解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。 示例 2： 输入: s = “applepenapple”, wordDict = [“apple”, “pen”] 输出: true 解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。 注意你可以重复使用字典中的单词。 示例 3： 输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”] 输出: false 思路分析 单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。 拆分时可以重复使用字典中的单词，说明就是一个完全背包！ 确定dp数组以及下标的含义 dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。 确定递推公式 如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。 所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。 dp数组如何初始化 从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。 遍历顺序 遍历背包放在外循环，将遍历物品放在内循环。内循环从前到后 代码详情 12345678910111213141516171819/** * https://leetcode-cn.com/problems/word-break/ */public class WordBreak { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { //dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。 boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for (int i = 1; i &lt;= s.length(); i++) { for (int j = 0; j &lt;= i; j++) { if (wordDict.contains(s.substring(j,i)) &amp;&amp; dp[j]) { dp[i] = true; } } } return dp[s.length()]; }} 7.打家劫舍leetcode题目链接 题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 思路分析 打家劫舍是dp解决的经典问题，动规五部曲分析如下： 确定dp数组（dp table）以及下标的含义 **dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。 确定递推公式 决定dp[i]的因素就是第i房间偷还是不偷。 如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。 如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点） 然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); dp数组如何初始化 从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1] 从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]); 确定遍历顺序 dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！ 举例推导dp数组 代码详情 123456789101112131415161718/** * https://leetcode-cn.com/problems/house-robber/ */public class HouseRobber { public int rob(int[] nums) { if (nums.length == 1) return nums[0]; int[] dp = new int[nums.length]; //dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。 dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; i++) { //决定dp[i] 的因素就是 第i房间 偷还是不偷 dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[nums.length - 1]; }} 8.打家劫舍2leetcode题目链接 题目 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。 示例 1： 输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2： 输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4 。 示例 3： 输入：nums = [0] 输出：0 思路分析 分两种情况考虑，1.考虑抢劫第一家，最后一家放弃，2.考虑抢劫最后一家，第一家放弃 然后利用7.打家劫舍的代码进行判断即可 代码详情 12345678910111213141516171819202122232425262728/** * https://leetcode-cn.com/problems/house-robber-ii/ */public class HouseRobber2 { public int rob(int[] nums) { if (nums.length == 1) return nums[0]; int result1 = robRange(0, nums.length - 2, nums); //考虑抢劫第一家，最后一家放弃 int result2 = robRange(1, nums.length - 1, nums); //考虑抢劫最后一家，第一家放弃 return Math.max(result1, result2); } //普通的打家劫舍逻辑 private int robRange(int start, int end, int[] nums) { if (start == end) return nums[start]; int[] dp = new int[nums.length]; dp[start] = nums[start]; dp[start + 1] = Math.max(nums[start + 1], nums[start]); for (int i = start + 2; i &lt;= end; i++) { dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end]; }} 9.打家劫舍3leetcode题目链接 题目 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 思路分析 1.确定递归函数的参数和返回值 这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。 参数为当前节点，代码如下： 1vector&lt;int&gt; robTree(TreeNode* cur) { 其实这里的返回数组就是dp数组。 所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。 所以本题dp数组就是一个长度为2的数组！ 那么有同学可能疑惑，长度为2的数组怎么标记树中每个节点的状态呢？ 别忘了在递归的过程中，系统栈会保存每一层递归的参数。 如果还不理解的话，就接着往下看，看到代码就理解了哈。 2.确定终止条件 在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回 1if (cur == NULL) return vector&lt;int&gt;{0, 0}; 这也相当于dp数组的初始化 3.确定遍历顺序 首先明确的是使用后序遍历。 因为通过递归函数的返回值来做下一步计算。 通过递归左节点，得到左节点偷与不偷的金钱。 通过递归右节点，得到右节点偷与不偷的金钱。 代码如下： 1234// 下标0：不偷，下标1：偷vector&lt;int&gt; left = robTree(cur-&gt;left); // 左vector&lt;int&gt; right = robTree(cur-&gt;right); // 右// 中 4.确定单层递归的逻辑 如果是偷当前节点，那么左右孩子就不能偷，val1 = cur-&gt;val + left[0] + right[0]; （如果对下标含义不理解就在回顾一下dp数组的含义） 如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 = max(left[0], left[1]) + max(right[0], right[1]); 最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱} 代码如下： 12345678vector&lt;int&gt; left = robTree(cur-&gt;left); // 左vector&lt;int&gt; right = robTree(cur-&gt;right); // 右// 偷curint val1 = cur-&gt;val + left[0] + right[0];// 不偷curint val2 = max(left[0], left[1]) + max(right[0], right[1]);return {val2, val1}; 5.举例推导dp数组 以示例1为例，dp数组状态如下：（注意用后序遍历的方式推导） 最后头结点就是 取下标0 和 下标1的最大值就是偷得的最大金钱。 代码详情 123456789101112131415161718192021222324252627282930/** * https://leetcode-cn.com/problems/house-robber-iii/ */public class HouseRobber3 { public int rob(TreeNode root) { //长度为2的数组，0:不偷当前节点，1:偷当前节点 int[] res = robTree(root); return Math.max(res[0],res[1]); } private int[] robTree(TreeNode root) { if (root == null) return new int[]{0, 0}; //后序递归遍历 左 右 中 int[] left = robTree(root.left); //左 int[] right = robTree(root.right); //右 //如果不偷当前节点，偷取的最大金额 int val0 = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); //如果偷当前节点，偷取的最大金额 int val1 = root.val + left[0] + right[0]; return new int[]{val0, val1}; }} 以上题目参考：LeetCode，思路分析参考：代码随想录","categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://www.colorfo.top/tags/dp/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.colorfo.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"完全背包","slug":"完全背包","permalink":"https://www.colorfo.top/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"}]},{"title":"HTTP基础①","slug":"HTTP基础①","date":"2021-09-24T03:15:00.000Z","updated":"2021-09-24T03:17:10.201Z","comments":true,"path":"posts/942d.html","link":"","permalink":"https://www.colorfo.top/posts/942d.html","excerpt":"","text":"1.什么是cookieCookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态 cookie会根据从服务器端发送的响应报文中的一个叫做Set-Cookie的首部字段信息，通知客户端保存cookie. 当下次客户端再向服务器端发送请求时，客户端会自动在请求报文中加入cookie值后发送出去 服务器端发现客户端发来的cookie后，会检查是哪一个客户端发送过来的连接请求，然后得到之前的状态信息 2.HTTP报文HTTP报文的主体用于传输请求或响应的实体主体 通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异 2.1请求和响应的报文首部请求报文和响应报文的首部内容有以下数据组成： 请求行 包含请求方法，请求URI,http版本 状态行 包含响应结果的状态码，原因短语，http版本 首部字段 包含请求和响应的各种条件，以及属性的各类首部 一般有4中首部，分别是：通用首部，请求首部，响应首部，实体首部 其他 可能包含http的RFC里未定义的首部(cookie等) 3.HTTP状态码 状态码的作用是当客户端向服务器端发送请求时，描述返回的请求结果 3.1状态码的类别 类别 原因短语 1XX information(信息性状态码) 接受的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection(重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器错误状态码) 服务器处理请求出错 3.2常见状态码2XX开头 200 OK 表示从客户端发来的请求在服务器端被正常处理了 204 No Content 一般只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用 206 Partial Content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由 Content-Range指定范围的实体内容 3XX开头 3XX响应结果表示浏览器需要执行某些特殊的处理以正确处理请求 301 Moved Permanently 永久性重定向。该状态码表示请求的资源已经被分配了新的URI,以后应使用资源现在所指的URI 302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的URI,希望用户本次能使用新的URI访问 303 See Other 该状态码表示由于请求对应的资源存在着另一个URI,应使用GET方法定向获取请求资源 4XX开头 4XX的响应结果表明客户端是发生错误的原因所在 400 Bad Request 该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求内容后再次发送请求 401 Unauthorized 该状态码表示发送的请求需要有通过HTTP认证的认证信息。另外，若之前已经进行过1次请求， 则表示用户认证失败 403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了。 未获得文件系统的访问授权，访问权限出现某些问题等，都可能是发生403的原因 404 Not Found 该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明原因时使用 5XX开头 5XX的响应结果表明服务器本身发生错误 500 Internal Server Error 该状态码表明服务器在执行请求过程中发生了错误。也有可能是Web应用存在的bug或某些临时的故障 503 Service Unavailable 该状态码表示服务器暂时处于超负载或停机维护状态，现在无法处理请求。 如果事先得知解除以上状况所需要的时间，最好写入Retry-After首部字段再返回给客户端。","categories":[{"name":"图解HTTP","slug":"图解HTTP","permalink":"https://www.colorfo.top/categories/%E5%9B%BE%E8%A7%A3HTTP/"}],"tags":[{"name":"cookie","slug":"cookie","permalink":"https://www.colorfo.top/tags/cookie/"},{"name":"http报文","slug":"http报文","permalink":"https://www.colorfo.top/tags/http%E6%8A%A5%E6%96%87/"},{"name":"http状态码","slug":"http状态码","permalink":"https://www.colorfo.top/tags/http%E7%8A%B6%E6%80%81%E7%A0%81/"}]},{"title":"动态规划刷题笔记①","slug":"动态规划刷题笔记①","date":"2021-09-22T01:35:03.000Z","updated":"2021-09-25T06:13:45.922Z","comments":true,"path":"posts/517c.html","link":"","permalink":"https://www.colorfo.top/posts/517c.html","excerpt":"","text":"动态规划五部曲 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 1.斐波那契数leetcode题目链接 题目 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。 示例 1： 输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 输入：3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 输入：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 &lt;= n &lt;= 30 思路分析 1.确定dp数组以及下标的含义 dp[i]的定义为：第i个数的斐波那契数值是dp[i] 2.确定递推公式 题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]; 3.dp数组初始化 dp[0] = 0; dp[1] = 1; 4.确定遍历顺序 从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的 5.举例推导dp数组 0 1 1 2 3 5 8 13 21 34 55 代码详情 12345678910111213141516171819202122/** * https://leetcode-cn.com/problems/fibonacci-number/ */public class FibonacciNumber { public int fib(int n) { if (n &lt;= 1) return n; int[] dp = new int[2]; dp[0] = 0; dp[1] = 1; int sum = 0; for (int i = 2; i &lt;= n; i++) { sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return sum; //return dp[1]也可以 }} 2.爬楼梯leetcode题目链接 题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 思路分析 此题与菲波那切数几乎一样，只不过初始条件不一样罢了 代码详情 1234567891011121314public class ClimbingStairs { public int climbStairs(int n) { if (n &lt;= 3) return n; int[] dp = new int[n+1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; }} 3.使用最小花费爬楼梯leetcode题目链接 题目 数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。 每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。 请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。 示例 1： 输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 示例 2： 输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。 提示： cost 的长度范围是 [2, 1000]。 cost[i] 将会是一个整型数据，范围为 [0, 999] 思路分析 确定dp数组以及下标的含义 **dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]**。 确定递推公式 **可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。 那么究竟是选dp[i-1]还是dp[i-2]呢？ 一定是选最小的，所以dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]; 注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值 dp数组的初始化 dp[i]由dp[i-1]，dp[i-2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了 12dp[0] = cost[0];dp[1] = cost[1]; 确定遍历顺序 因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了 举例推导dp数组 代码详情 1234567891011121314151617181920/** * https://leetcode-cn.com/problems/min-cost-climbing-stairs/ */public class MinCostClimbingStairs { public int minCostClimbingStairs(int[] cost) { int[] dp = new int[cost.length]; //1.dp[i] 表示爬上i层楼所需的最小花费 //3.dp数组的初始化 dp[0] = cost[0]; dp[1] = cost[1]; //4.确定遍历顺序 for (int i = 2; i &lt;= dp.length - 1; i++) { dp[i] = Math.min(dp[i - 1],dp[i - 2]) + cost[i]; //2.确定递推公式 } return Math.min(dp[dp.length - 1],dp[dp.length - 2]); }} 4.不同路径leetcode题目链接 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 思路分析 确定dp数组（dp table）以及下标的含义 dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。 确定递推公式 想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。 此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。 那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。 dp数组的初始化 如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。 所以初始化代码为： 12for (int i = 0; i &lt; m; i++) dp[i][0] = 1;for (int j = 0; j &lt; n; j++) dp[0][j] = 1; 确定遍历顺序 这里要看一下递归公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。 这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。 举例推导dp数组 代码详情 123456789101112131415161718192021222324/** * https://leetcode-cn.com/problems/unique-paths/ */public class UniquePaths { public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; //1.确定dp数组，dp[i][j] 表示 (0,0) -&gt; (i,j)一共有多少种路径 //2.dp数组的初始化 for (int i = 0; i &lt; m; i++) dp[i][0] = 1; for (int i = 0; i &lt; n; i++) dp[0][i] = 1; //3.确定遍历顺序 for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { //4.确定递推表达式 dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m-1][n-1]; }} 5. 不同路径 IIleetcode题目链接 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 思路分析 此题与4.不同路径类似，只是多了障碍物，需要注意障碍物的处理 初始化时的障碍物处理： 12for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1; 递推遍历时，对于障碍物的处理： 12if (obstacleGrid[i][j] == 1) continue; //如果遇到障碍物则跳过dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; 代码详情 123456789101112131415161718192021222324/** * https://leetcode-cn.com/problems/unique-paths-ii/ */public class UniquePath2 { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1; for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1; for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { if (obstacleGrid[i][j] == 1) { continue; } dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; }} 6.不同的二叉搜索树leetcode题目链接 题目 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例： 思路分析 确定dp数组（dp table）以及下标的含义 **dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。 也可以理解是i的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。 以下分析如果想不清楚，就来回想一下dp[i]的定义 确定递推公式 在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] j相当于是头结点的元素，从1遍历到i为止。 所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量 dp数组如何初始化 初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。 那么dp[0]应该是多少呢？ 从定义上来讲，空节点也是一颗二叉树，也是一颗二叉搜索树，这是可以说得通的。 从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。 所以初始化dp[0] = 1 确定遍历顺序 首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。 那么遍历i里面每一个数作为头结点的状态，用j来遍历。 代码如下： 12345for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { dp[i] += dp[j - 1] * dp[i - j]; }} 举例推导dp数组 n为5时候的dp数组状态如图： 代码详情 123456789101112131415161718192021222324/** * https://leetcode-cn.com/problems/unique-binary-search-trees/ */public class UniqueBST { public static int numTrees(int n) { int[] dp = new int[n+1]; // 1到i为节点组成的二叉搜索树的个数为dp[i]。 dp[0] = 1; //初始化，空节点也是一颗二叉树 for (int i = 1; i &lt;= n; i++) { //j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量 for (int j = 1; j &lt;= i; j++) { dp[i] += dp[j-1] * dp[i-j]; } } return dp[n]; } //--------------- public static void main(String[] args) { int i = numTrees(3); System.out.println(i); }} 7.0-1背包理论基础(一)参见：代码随想录，使用二维数组实现0-1背包。 8.0-1背包理论基础(二) 一维dp数组(滚动数组) 题目 背包最大重量为4。 物品为： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 问背包能背的物品最大价值是多少？ 思路分析 确定dp数组的定义 在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。 一维dp数组的递推公式 dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？ dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。 dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]） 此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值， 所以递归公式为： 1dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。 一维dp数组如何初始化 关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。 那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？ 看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。 这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。 那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。 一维dp数组遍历顺序 代码如下： 123456for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); }} 举例推导dp数组 一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下： 代码详情 1234567891011121314151617181920212223242526272829303132/** * 01背包问题，使用一维数组实现 */public class Bag01OneArray { public static int test01BagProblem(int[] weight, int[] value, int bagSize) { //定义dp数组，dp[j] 表示容量为j的背包 所放物品的总价值 int[] dp = new int[bagSize + 1]; dp[0] = 0; //初始化dp数组 //确定遍历顺序，以及递归的表达式 for (int i = 0; i &lt; weight.length; i++) { //遍历物品 for (int j = bagSize; j &gt;= weight[i] ; j--) { //遍历背包容量(倒序遍历) dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); } } System.out.println(Arrays.toString(dp)); return dp[weight.length]; } //--------------- public static void main(String[] args) { int[] weight = {1,3,4}; int[] value = {15,20,30}; test01BagProblem(weight,value,4); }} 9.分割等和子集leetcode题目链接 题目 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集. 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 思路分析 动规五部曲分析如下： 确定dp数组以及下标的含义 01背包中，dp[i] 表示： 容量为j的背包，所背的物品价值可以最大为dp[j]。 **套到本题，dp[i]表示 背包总容量是i，最大可以凑成i的子集总和为dp[i]**。 确定递推公式 01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。 所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); dp数组如何初始化 在01背包，一维dp如何初始化，已经讲过， 从dp[j]的定义来看，首先dp[0]一定是0。 如果如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。 这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。 本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。 确定遍历顺序 如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒叙遍历！ 代码如下： 123456// 开始 01背包for(int i = 0; i &lt; nums.size(); i++) { for(int j = target; j &gt;= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历 dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); }} 举例推导dp数组 dp[i]的数值一定是小于等于i的。 如果dp[i] == i 说明，集合中的子集总和正好可以凑成总和i，理解这一点很重要。 用例1，输入[1,5,11,5] 为例，如图： 代码详情 12345678910111213141516171819202122232425262728/** * https://leetcode-cn.com/problems/partition-equal-subset-sum/ */public class EqualSubsetSum { public boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) { sum += num; } if (sum % 2 == 1) return false; //如果是奇数，则不能平分为两个相等的子集 int target = sum / 2; int[] dp = new int[target + 1]; //dp[j] 表示 容量为j 可放入的最大元素和 dp[0] = 0; //初始化dp //确定遍历顺序以及，递归表达式 for (int i = 0; i &lt; nums.length; i++) { for (int j = target; j &gt;= nums[i] ; j--) { dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]); } } return dp[target] == target; }} 10.最后一块石头的重量 IIleetcode题目链接 题目 有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。 示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 思路分析 本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，这样就化解成01背包问题了。 和9. 分割等和子集非常像了。 代码详情 12345678910111213141516171819202122public class LastStone { public int lastStoneWeightII(int[] stones) { int sum = 0; for (int stone : stones) { sum += stone; } int target = sum &gt;&gt; 1; //sum / 2 int[] dp = new int[target + 1]; //dp[j] 表示容量j 可以 装入的最大重量 dp[j] dp[0] = 0; //初始化 //确定遍历顺序以及状态转移方程 for (int i = 0; i &lt; stones.length; i++) { for (int j = target; j &gt;= stones[i]; j--) { dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]); } } return sum - dp[target] - dp[target]; }} 11目标和leetcode题目链接 题目 给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例： 输入：nums: [1, 1, 1, 1, 1], S: 3输出：5 解释：-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3 一共有5种方法让最终目标和为3。 思路分析 如何转化为01背包问题呢。 假设加法的总和为x，那么减法对应的总和就是sum - x。 所以我们要求的是 x - (sum - x) = S x = (S + sum) / 2 此时问题就转化为，装满容量为x背包，有几种方法。 确定dp数组以及下标的含义 dp[j] 表示：填满j（包括j）这么大容积的包，有dp[i]种方法 确定递推公式 不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。 那么只要搞到nums[i]的话，凑成dp[j]就有dp[j - nums[i]] 种方法。 举一个例子,nums[i] = 2： dp[3]，填满背包容量为3的话，有dp[3]种方法。 那么只需要搞到一个2（nums[i]），有dp[3]方法可以凑齐容量为3的背包，相应的就有多少种方法可以凑齐容量为5的背包。 那么需要把 这些方法累加起来就可以了，dp[j] += dp[j - nums[i]] 所以求组合类问题的公式，都是类似这种： 1dp[j] += dp[j - nums[i]] dp数组如何初始化 从递归公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递归结果将都是0。 dp[0] = 1，理论上也很好解释，装满容量为0的背包，有1种方法，就是装0件物品。 dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。 确定遍历顺序 物品放在外循环，背包容量放在内循环，且内循环倒序 举例推导dp数组 输入：nums: [1, 1, 1, 1, 1], S: 3 bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4 dp数组状态变化如下： 代码详情 12345678910111213141516171819202122232425/** * https://leetcode-cn.com/problems/target-sum/ */public class TargetSum { public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int num : nums) { sum += num; } if ((sum + target) % 2 == 1) return 0; if (Math.abs(target) &gt; sum) return 0; int bagSize = (sum + target) / 2; int[] dp = new int[bagSize + 1]; //dp[i] 表示装满容量为i的有多少种组合 dp[0] = 1; for (int i = 0; i &lt; nums.length; i++) { for (int j = bagSize; j &gt;= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize]; }} 以上题目参考：LeetCode，思路分析参考：代码随想录","categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://www.colorfo.top/tags/dp/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.colorfo.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"贪心算法刷题笔记②-贪心解决区间问题","slug":"贪心算法刷题笔记②-贪心解决区间问题","date":"2021-09-12T07:44:54.000Z","updated":"2021-09-12T08:27:43.094Z","comments":true,"path":"posts/c9cc.html","link":"","permalink":"https://www.colorfo.top/posts/c9cc.html","excerpt":"","text":"1.用最少数量的箭引爆气球leetcode题目链接 题目 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。 示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 思路分析 局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。 算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？ 如果真实的模拟射气球的过程，应该射一个，气球数组就remove一个元素，这样最直观，毕竟气球被射了。 但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remove气球，只要记录一下箭的数量就可以了。 以上为思考过程，已经确定下来使用贪心了，那么开始解题。 为了让气球尽可能的重叠，需要对数组进行排序。 如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭。 以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序） 可以看出首先第一组重叠气球，一定是需要一个箭，气球3，的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了. 代码详情 12345678910111213141516171819202122232425262728public class BurstBalloons { public int findMinArrowShots(int[][] points) { if (points.length == 0) return 0; int result = 1; Arrays.sort(points, new Comparator&lt;int[]&gt;() { //按照左边界排序,从小到大排序 @Override public int compare(int[] o1, int[] o2) { if (o1[0] &lt; o2[0]) return -1; else if (o1[0] &gt; o2[0]) return 1; else return 0; } }); for (int i = 1; i &lt; points.length; i++) { if (points[i][0] &gt; points[i - 1][1]) { //两个气球如果不挨着 result++; //需要一支箭 } else { //气球i和i-1挨着 points[i][1] = Math.min(points[i-1][1],points[i][1]); // 更新重叠气球最小右边界 // 即：取两者之中较小的右边界作为气球i的右边界 } } return result; }} 2.无重叠区间leetcode题目链接 题目 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了 思路分析 如果遇到重叠的区间，则将result+1，并且缩减当前区间的右边界(相当于把这个区间移除了) 代码详情 123456789101112131415161718192021222324252627public class NonOverlapping { public int eraseOverlapIntervals(int[][] intervals) { if (intervals.length &lt;= 1) return 0; int result = 0; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { //按照区间左边界排序 @Override public int compare(int[] o1, int[] o2) { if (o1[0] &gt; o2[0]) return 1; else if (o1[0] &lt; o2[0]) return -1; else return 0; } }); for (int i = 1; i &lt; intervals.length; i++) { if (intervals[i][0] &lt; intervals[i - 1][1]) { //如果有重叠部分 result++; //相当于删除一个 intervals[i][1] = Math.min(intervals[i - 1][1],intervals[i][1]); } } return result; }} 3.划分字母区间leetcode题目链接 题目 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。 示例： 输入：S = “ababcbacadefegdehijhklij” 输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。 提示： S的长度在[1, 500]之间。 S只包含小写字母 ‘a’ 到 ‘z’ 。 思路分析 在遍历的过程中相当于是要找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。此时前面出现过所有字母，最远也就到这个边界了。 可以分为如下两步： 统计每一个字符最后出现的位置 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点 如图： 代码详情 12345678910111213141516171819202122232425public class PartitionLabels { public List&lt;Integer&gt; partitionLabels(String s) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); int[] edge = new int[26]; int right = 0; int left = 0; for (int i = 0; i &lt; s.length(); i++) { edge[s.charAt(i) - 'a'] = i; //找到字符出现的最远下标 } for (int i = 0; i &lt; s.length(); i++) { right = Math.max(edge[s.charAt(i) - 'a'],right); if (i == right) { //找到字符出现的最远边界,说明到了划分点 int partition = right - left + 1; left = i + 1; result.add(partition); } } return result; }} 4.合并区间leetcode题目链接 题目 给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: intervals = [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: intervals = [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。 提示： intervals[i][0] &lt;= intervals[i][1] 思路分析 按照左边界从小到大排序之后，先将intervals[0]，加入到result集合中。 如果 intervals[i][0] &lt;= result.getLast()[1] 即intervals[i]左边界 &lt; result.getLast()右边界，则一定有重复 知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？ 其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result集合里就可以了。 如果没有重复区间就把原区间加入到result集合。 代码详情 123456789101112131415161718192021222324public class MergeIntervals { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, (o1, o2) -&gt; Integer.compare(o1[0],o2[0]));//按照左边界排序 LinkedList&lt;int[]&gt; result = new LinkedList&lt;&gt;(); result.add(intervals[0]); for (int i = 1; i &lt; intervals.length; i++) { if (intervals[i][0] &lt;= result.getLast()[1]) { //如果有重叠的部分 int start = result.getLast()[0]; int end = Math.max(result.getLast()[1],intervals[i][1]); result.removeLast(); //先把result集合中的取出来 result.add(new int[]{start,end}); //再加入新的数组进到result集合中 } else { result.add(intervals[i]); } } return result.toArray(new int[result.size()][]); }} 以上题目及思路分析参考：leetcode及代码随想录","categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.colorfo.top/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"贪心算法刷题笔记①","slug":"贪心算法刷题笔记①","date":"2021-09-11T05:16:43.000Z","updated":"2021-09-12T07:48:15.894Z","comments":true,"path":"posts/2a28.html","link":"","permalink":"https://www.colorfo.top/posts/2a28.html","excerpt":"","text":"1.分发饼干leetcode题目链接 题目 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 2: 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. 代码详情 思路：用小饼干先喂小胃口的孩子 12345678910111213141516171819202122232425262728293031import java.util.Arrays;/** * 分发饼干 * https://leetcode-cn.com/problems/assign-cookies/ */public class AssignCookies { /** *小饼干先喂饱小胃口 * @param g 小孩的胃口 * @param s 饼干的尺寸 * @return 饼干能满足小孩的个数 */ public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int index = 0; int result = 0; for (int i = 0; i &lt; s.length; i++) { if (index &lt; g.length &amp;&amp; s[i] &gt;= g[index]){ //如果满足了小孩的胃口 result++; index++; //看下一个小孩的胃口 } } return result; }} 2.摆动序列leetcode题目链接 题目 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例 1: 输入: [1,7,4,9,2,5] 输出: 6 解释: 整个序列均为摆动序列。 示例 2: 输入: [1,17,5,10,13,15,10,5,16,8] 输出: 7 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 思路分析 局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。 整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。 代码详情 12345678910111213141516171819202122public class WiggleSubsequence { public int wiggleMaxLength(int[] nums) { if (nums.length &lt;= 0) return nums.length; int preDiff = 0; int curDiff = 0; int count = 1; for (int i = 0; i &lt; nums.length - 1; i++) { curDiff = nums[i+1] - nums[i]; //如果当前差值和上一个差值为一正一负 //等于0的情况表示初始时的preDiff if ((curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0) || (curDiff &lt; 0 &amp;&amp; preDiff &gt;= 0)){ count++; preDiff = curDiff; } } return count; }} 3.最大子序列和LeetCode题目链接 题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 思路分析 贪心贪的是哪里呢？ 如果 -2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！ 局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。 全局最优：选取最大“连续和” 局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。 从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。 这相当于是暴力解法中的不断调整最大子序和区间的起始位置。 那有同学问了，区间终止位置不用调整么？ 如何才能得到最大“连续和”呢？ 区间的终止位置，其实就是如果count取到最大值了，及时记录下来了。例如如下代码： 1if (count &gt; result) result = count; 这样相当于是用result记录最大子序和区间和（变相的算是调整了终止位置）。 如动画所示: 红色的起始位置就是贪心每次取count为正数的时候，开始一个区间的统计。 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MaxSubarray { /**方法一： * 暴力解法，时间复杂度O(n^2) * @param nums * @return */ public int maxSubArray1(int[] nums) { int result = Integer.MIN_VALUE; int count = 0; for (int i = 0; i &lt; nums.length; i++) { count = 0; for (int j = i; j &lt; nums.length; j++) { count += nums[j]; result = count &gt; result ? count : result; } } return result; } /**方法二： * 贪心算法 * @param nums * @return */ public int maxSubArray(int[] nums){ int result = Integer.MIN_VALUE; int count = 0; for (int i = 0; i &lt; nums.length; i++) { count += nums[i]; // 取区间累计的最大值（相当于不断确定最大子序终止位置） if (count &gt; result) result = count; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和 if (count &lt;= 0) count = 0; } return result; }} 4.买卖股票的最佳时机IIleetcode题目链接 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路分析 计算相邻两天的价格差，若为正，则说明有利润可图，则加入到总利润中 代码详情 1234567891011121314public class SellStock { public int maxProfit(int[] prices) { int result = 0; //遍历数组求两天的价格差，只要是正(说明有利润)，就累加 for (int i = 0; i &lt; prices.length - 1; i++) { int temp = prices[i+1] - prices[i]; if (temp &gt; 0){ result += temp; } } return result; }} 5.跳跃游戏leetcode题目链接 题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 思路分析 刚看到本题一开始可能想：当前位置元素如果是3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？ 其实跳几步无所谓，关键在于可跳的覆盖范围！ 不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。 这个范围内，别管是怎么跳的，反正一定可以跳过来。 那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！ 每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。 贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。 局部最优推出全局最优，找不出反例，试试贪心！ 如图： i每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让i继续移动下去。 而cover每次只取 max(该元素数值补充后的范围, cover本身范围)。 如果cover大于等于了终点下标，直接return true就可以了。 代码详情 1234567891011121314public class JumpGame { public boolean canJump(int[] nums) { int cover = 0; if (nums.length == 1) return true; for (int i = 0; i &lt;= cover; i++){ // 注意这里是小于等于cover cover = Math.max(i + nums[i],cover); if (cover &gt;= nums.length - 1) return true; // 说明可以覆盖到终点了 } return false; }} 6.跳跃游戏IIleetcode题目链接 题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。 思路分析 移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。 想要达到这样的效果，只要让移动下标，最大只能移动到nums.size - 2的地方就可以了。 因为当移动下标指向nums.size - 2时： 1.如果移动下标等于当前覆盖最大距离下标， 需要再走一步（即ans++），因为最后一步一定是可以到的终点。（题目假设总是可以到达数组的最后一个位置），如图： 2.如果移动下标不等于当前覆盖最大距离下标，说明当前覆盖最远距离就可以直接达到终点了，不需要再走一步。如图： 代码详情 123456789101112131415161718192021public class JumpGame2 { public int jump(int[] nums) { if (nums.length == 1) { return 0; } int curDistance = 0; // 当前覆盖的最远距离下标 int ans = 0; // 记录走的最大步数 int nextDistance = 0; // 下一步覆盖的最远距离下标 for (int i = 0; i &lt; nums.length - 1; i++) { // 注意这里是小于nums.size() - 1，这是关键所在 nextDistance = Math.max(nums[i] + i, nextDistance); // 更新下一步覆盖的最远距离下标 if (i == curDistance) { // 遇到当前覆盖的最远距离下标 curDistance = nextDistance; // 更新当前覆盖的最远距离下标 ans++; } } return ans; } } 7.加油站leetcode题目链接 题目 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1: 输入: gas = [1,2,3,4,5] cost = [3,4,5,1,2] 输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 思路分析 首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。 每个加油站的剩余量rest[i]为gas[i] - cost[i]。 i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。 如图： 那么为什么一旦[i，j] 区间和为负数，起始位置就可以是j+1呢，j+1后面就不会出现更大的负数？ 如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了。 而且j之前出现了多少负数，j后面就会出现多少正数，因为耗油总和是大于零的（前提我们已经确定了一定可以跑完全程）。 那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置。 代码详情 12345678910111213141516171819public class GasStation { public int canCompleteCircuit(int[] gas, int[] cost) { int curSum = 0; int totalRest = 0; int start = 0; for (int i = 0; i &lt; gas.length; i++) { curSum += (gas[i] - cost[i]); totalRest += (gas[i] - cost[i]); if (curSum &lt; 0) { // 当前累加gas[i] - cost[i]的和 curSum一旦小于0 start = i + 1; // 起始位置更新为i+1 curSum = 0; // curSum从0开始 } } if (totalRest &lt; 0) return -1; // 说明怎么走都不可能跑一圈了 return start; }} 8.单调递增的数字leetcode题目链接 题目 给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。 （当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。） 示例 1: 输入: N = 10 输出: 9 示例 2: 输入: N = 1234 输出: 1234 示例 3: 输入: N = 332 输出: 299 思路分析 题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。 例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]--，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。 这一点如果想清楚了，这道题就好办了。 局部最优：遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]–，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数。 全局最优：得到小于等于N的最大单调递增的整数。 但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9。 此时是从前向后遍历还是从后向前遍历呢？ 从前向后遍历的话，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。 这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。 所以从前后向遍历会改变已经遍历过的结果！ 那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299 确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。 代码详情 1234567891011121314151617181920212223242526272829303132public class MonotoneIncreasingDigits { public int monotoneIncreasingDigits(int n) { String str = String.valueOf(n); //将n转为String串 char[] s = str.toCharArray(); // flag用来标记赋值9从哪里开始 // 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行 int flag = str.length(); for (int i = s.length - 1; i &gt; 0; i--) { if (s[i - 1] &gt; s[i]) { flag = i; s[i - 1] = (char) (s[i - 1] - 1); //s[i - 1] -&gt; int (转为int类型) } } for (; flag &lt; s.length; flag++) { //将下标flag及其后面的数，全部置为'9' s[flag] = '9'; } String result = String.valueOf(s); return Integer.parseInt(result); } //---------------- public static void main(String[] args) { MonotoneIncreasingDigits num = new MonotoneIncreasingDigits(); int i = num.monotoneIncreasingDigits(318); //322 System.out.println(i); }} 本篇博文参考：代码随想录","categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.colorfo.top/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"回溯算法刷题笔记②","slug":"回溯算法刷题笔记②","date":"2021-09-06T09:04:44.000Z","updated":"2021-09-06T11:52:09.036Z","comments":true,"path":"posts/e46.html","link":"","permalink":"https://www.colorfo.top/posts/e46.html","excerpt":"","text":"1.分割回文串力扣题目链接 题目 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例: 输入: \"aab\" 输出: [ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ] 思路分析 先分析一下切割，其实切割问题类似组合问题。 例如对于字符串abcdef： 组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。 切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。 所以切割问题，也可以抽象为一颗树形结构，如图： 递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.LinkedList;import java.util.List;/** * 题目链接：https://leetcode-cn.com/problems/palindrome-partitioning/ * * 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 * 返回 s 所有可能的分割方案。 * * 示例: 输入: \"aab\" 输出: [ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ] */public class DivisionPalindrome { List&lt;List&lt;String&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;String&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) { if (s == null || s.length() == 0) { return result; } backtracking(s,0); return result; } private void backtracking(String s, int startIndex) { if (startIndex &gt;= s.length()) { result.add(new LinkedList&lt;&gt;(path)); return; } for (int i = startIndex; i &lt; s.length(); i++) { if (isPalindrome(s,startIndex,i)){ //如果s的[startIndex,i]之间是回文串，则加入到path中 String str = s.substring(startIndex,i+1); path.add(str); backtracking(s,i+1); //递归 path.removeLast(); //回溯 }else { //如果不是回文串，进行下一次判断 continue; } } } private boolean isPalindrome(String s, int startIndex, int endIndex) { for (int i = startIndex,j = endIndex; i &lt; j; i++,j--) { if (s.charAt(i) != s.charAt(j)) return false; } return true; } //-------------- public static void main(String[] args) { String str = \"aab\".substring(0,1); //substring(begin,end),[begin,end),左闭右开 System.out.println(str); System.out.println(\"aab\".substring(1)); DivisionPalindrome palindrome = new DivisionPalindrome(); List&lt;List&lt;String&gt;&gt; s = palindrome.partition(\"aab\"); for (List&lt;String&gt; strings : s) { System.out.println(strings); } }} 2.复原IP地址力扣题目链接 题目 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。 例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1“ 是 无效的 IP 地址。 示例 1： 输入：s = “25525511135” 输出：[“255.255.11.135”,”255.255.111.35”] 示例 2： 输入：s = “0000” 输出：[“0.0.0.0”] 示例 3： 输入：s = “1111” 输出：[“1.1.1.1”] 示例 4： 输入：s = “010010” 输出：[“0.10.0.10”,”0.100.1.0”] 示例 5： 输入：s = “101023” 输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”] 提示： 0 &lt;= s.length &lt;= 3000 s 仅由数字组成 思路分析 只要意识到这是切割问题，切割问题就可以使用回溯搜索法把所有可能性搜出来，和刚做过的1.分割回文串就十分类似了。 切割问题可以抽象为树型结构，如图： 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.LinkedList;import java.util.List;/** * 题目地址：https://leetcode-cn.com/problems/restore-ip-addresses/ * * 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 * 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。 * * 例如：\"0.1.2.201\" 和 \"192.168.1.1\" 是 有效的 IP 地址， * 但是 \"0.011.255.245\"、\"192.168.1.312\" 和 \"192.168@1.1\" 是 无效的 IP 地址。 * * 示例 5： 输入：s = \"101023\" 输出：[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"] */public class RestoreIP { List&lt;String&gt; result = new LinkedList&lt;&gt;(); public List&lt;String&gt; restoreIpAddresses(String s) { if (s == null || s.length() == 0 || s.length() &gt; 12) return result; backtracking(s,0,0); return result; } private void backtracking(String s, int startIndex, int pointNum) { if (pointNum == 3){ // 逗点数量为3时，分隔结束 // 判断第四段⼦字符串是否合法，如果合法就放进result中 if (isValid(s,startIndex,s.length()-1)){ result.add(s); } return; } for (int i = startIndex; i &lt; s.length(); i++) { //如果s的[startIndex,i]是合法的整数子串 if (isValid(s,startIndex,i)){ s = s.substring(0,i+1) + \".\" + s.substring(i+1); pointNum++; backtracking(s,i+2,pointNum); //递归 s = s.substring(0,i+1) + s.substring(i+2); pointNum--; }else { break; } } } private boolean isValid(String s, int start, int end) { if (start &gt; end) return false; //如果以0开头，不合法 if (s.charAt(start) == '0' &amp;&amp; start != end) return false; int num = 0; for (int i = start;i &lt;= end;i++){ //判断每一个数字是否合法 if (s.charAt(i) &gt; '9' || s.charAt(i) &lt; '0') return false; //如果[start,end]范围内的整数大于255，不合法 num = num * 10 + (s.charAt(i) - '0'); if (num &gt; 255) return false; } return true; } //------------------ public static void main(String[] args) { RestoreIP ip = new RestoreIP(); List&lt;String&gt; strings = ip.restoreIpAddresses(\"101023\"); for (String s : strings){ System.out.println(s); } }} 3.子集问题力扣题目链接 题目 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 思路分析 如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！ 以示例中nums = [1,2,3]为例把求子集抽象为树型结构，如下： 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.LinkedList;import java.util.List;/** * 题目地址：https://leetcode-cn.com/problems/subsets/ * * 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 * 说明：解集不能包含重复的子集。 * * 示例: 输入: nums = [1,2,3] 输出: [ [3], [1],[2],[1,2,3],[1,3],[2,3],[1,2],[]] * */public class Subsets { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { if (nums.length == 0) return result; backtracking(nums,0); return result; } private void backtracking(int[] nums, int startIndex) { result.add(new LinkedList&lt;&gt;(path)); // 收集子集，要放在终止添加的上面，否则会漏掉自己 if (startIndex &gt;= nums.length) return; for (int i = startIndex; i &lt; nums.length; i++) { path.add(nums[i]); backtracking(nums,i+1); path.removeLast(); } }} 4.子集II力扣题目链接 题目 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 思路分析 此题和3.子集问题很类似，唯一的区别就是，本题需要进行去重操作，因为题目中要求了解集不能包含重复的子集。 而nums数组中可能包含重复元素 去重关键代码： 123if (i &gt; startIndex &amp;&amp; nums[i] == nums[i-1]){ //去重操作(结果节不能有重复元素，要去重) continue;} 代码详情 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Arrays;import java.util.LinkedList;import java.util.List;/** * 题目链接：https://leetcode-cn.com/problems/subsets-ii/ * * 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 * 说明：解集不能包含重复的子集。 * * 示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] * */public class SubsetsNoRepeat { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { Arrays.sort(nums); //先给nums数组排序 backtracking(nums,0); return result; } private void backtracking(int[] nums, int startIndex) { result.add(new LinkedList&lt;&gt;(path)); // 收集子集，要放在终止条件的上面，否则会漏掉自己 if (startIndex &gt;= nums.length) return; //终止条件 for (int i = startIndex; i &lt; nums.length; i++) { if (i &gt; startIndex &amp;&amp; nums[i] == nums[i-1]){ //去重操作(结果节不能有重复元素，要去重) continue; } path.add(nums[i]); backtracking(nums,i+1); //递归 path.removeLast(); //回溯 } }} 5.递增子序列 代码详情 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.LinkedList;import java.util.List;/** * 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。 * 你可以按 任意顺序 返回答案。 * 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。 * * 输入: [4, 6, 7, 7] 输出: * [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] * * 链接：https://leetcode-cn.com/problems/increasing-subsequences */public class IncreasingSubsequences { /** * 备注： * 这种写法，输入[4,6,7,7],可以得到想要的输出， * 但是不能被LeetCode AC,原因不明 */ List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) { backtracking(nums,0); return result; } private void backtracking(int[] nums, int startIndex) { if (path.size() &gt;= 2) result.add(new LinkedList&lt;&gt;(path)); if (startIndex &gt;= nums.length) return; for (int i = startIndex; i &lt; nums.length; i++) { if (i &gt; startIndex &amp;&amp; nums[i] == nums[i-1]) continue; //去重 if (i == 0 || nums[i] &gt;= nums[i-1]){ path.add(nums[i]); backtracking(nums,i+1); path.removeLast(); }else { //break; continue; } } } //---------------- public static void main(String[] args) { IncreasingSubsequences subsequences = new IncreasingSubsequences(); int[] nums = {4,6,7,7}; List&lt;List&lt;Integer&gt;&gt; subsequences1 = subsequences.findSubsequences(nums); for (List&lt;Integer&gt; list : subsequences1) { System.out.println(list); } }} 6.全排列力扣题目链接 题目 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: nums = [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 思路分析 每一次递归都遍历nums数组，然后将nums[i]加入到List&lt;Integer&gt; path中，继续递归，回溯。 如果path已经包含了nums[i],就跳过本次循环，进行下一次循环。 如果path.size() == nums.length，就return. 代码详情 1234567891011121314151617181920212223242526272829303132333435363738/** * 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 * 示例: 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] * * https://leetcode-cn.com/problems/permutations/ */public class Permutations { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { backtracking(nums); return result; } private void backtracking(int[] nums) { if (nums.length == path.size()){ result.add(new LinkedList&lt;&gt;(path)); return; } for (int i = 0; i &lt; nums.length; i++) { //通过判断path中是否存在数字，排除已经选择的数字 if (path.contains(nums[i])){ continue; } path.add(nums[i]); backtracking(nums); path.removeLast(); } }} 7.全排列 II力扣题目链接 题目 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例 1： 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] 示例 2： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 思路分析 要强调的是去重一定要对元素经行排序，这样我们才方便通过相邻的节点来判断是否重复使用了。 以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图： 图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。 一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果。 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Arrays;import java.util.LinkedList;import java.util.List;/** * * 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 * * 示例 1： 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] * 示例 2： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] * * https://leetcode-cn.com/problems/permutations-ii/ */public class PermutationNoRepeat { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); List&lt;Integer&gt; path = new LinkedList&lt;&gt;(); boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { used = new boolean[nums.length]; Arrays.sort(nums); backtracking(nums); return result; } private void backtracking(int[] nums) { if (path.size() == nums.length) { result.add(new LinkedList(path)); return; } for (int i = 0; i &lt; nums.length; i++) { // used[i - 1] == false，说明同一树层nums[i - 1]使用过 // 如果同一树层nums[i - 1]使用过则直接跳过 if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1] == false){ continue; } if (used[i] == false){ path.add(nums[i]); used[i] = true; backtracking(nums); path.remove(path.size() - 1); used[i] = false; } } }}","categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"回溯刷题笔记①","slug":"回溯刷题笔记①","date":"2021-09-03T05:18:35.000Z","updated":"2021-09-03T06:59:17.747Z","comments":true,"path":"posts/cac8.html","link":"","permalink":"https://www.colorfo.top/posts/cac8.html","excerpt":"","text":"回溯算法简介回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯算法模板123456789101112void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 }} 1.组合问题leetcode题目链接 题目 给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例:输入: n = 4, k = 2输出:[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],] 思路分析 把组合问题抽象为如下树形结构： 代码详情 1234567891011121314151617181920212223242526272829import java.util.LinkedList;import java.util.List;/** * 组合问题，返回[1,n]，中所有的k个数的组合 */public class Combine { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { combineHelper(n, k, 1); return result; } private void combineHelper(int n, int k, int startIndex){ //终止条件 if (path.size() == k){ result.add(new LinkedList(path)); return; } for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++){ //剪枝优化 path.add(i); combineHelper(n, k, i + 1); path.removeLast(); //回溯 } }} 2.组合总和IIIleetcode题目链接 题目 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]] 示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 思路分析 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.LinkedList;import java.util.List;/** * 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数， * 并且每种组合中不存在重复的数字。 * * 示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]] * 示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] */public class CombinationSum { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); int sum; public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) { combination(k,n,1); return result; } private void combination(int k, int targetSum, int startIndex) { if (path.size() == k){ if (targetSum == sum){ result.add(new LinkedList&lt;&gt;(path)); } return; //如果path.size() == k 但sum != targetSum 直接返回 } if (sum &gt; targetSum) return; for (int i = startIndex; i &lt;= 9-(k-path.size())+1; i++) { path.add(i); sum += i; combination(k,targetSum,i+1); // 注意i+1调整startIndex path.removeLast(); //回溯 sum -= i; } }} 3.电话号码的字母组合leetcode题目链接 题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：”23” 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序 思路分析 首先定义一个String[]数组，用来做数字和字母的映射 String[] numString = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}; 然后从这个数组中取字符串进行组合即可 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.LinkedList;import java.util.List;/**给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 * * https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/ */public class CombinationOfPhoneNumber { List&lt;String&gt; result = new LinkedList&lt;&gt;(); //用来储存最终的结果 StringBuilder str = new StringBuilder(); //用来储存最终结果的每一个字符串 public List&lt;String&gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0){ return result; } //构造一个String[],下标对应字符串 String[] numString = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}; backtracking(digits,numString,0);//回溯的方法 return result; } private void backtracking(String digits, String[] numString, int num) { if (num == digits.length()){ result.add(str.toString()); return; } //获取digits数字串的第num个数字 int index = digits.charAt(num) - '0'; //数字index对应的字符串 String string = numString[index]; for (int i = 0; i &lt; string.length(); i++) { str.append(string.charAt(i));//处理 backtracking(digits,numString,num + 1); //递归，注意num + 1 str.deleteCharAt(num); //回溯 } }} 4.组合总和leetcode题目链接 题目 1234567891011给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ] 思路分析 本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。 本题搜索的过程抽象成树形结构如下： 注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！ 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.LinkedList;import java.util.List;/** *给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 * candidates 中的数字可以无限制重复被选取。 * *示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [[2,2,2,2],[2,3,3],[3,5]] * * 链接：https://leetcode-cn.com/problems/combination-sum */public class CombinationRepeatedSum { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); int sum; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { if (candidates.length == 0) return result; backtracking(candidates,target,0); return result; } private void backtracking(int[] candidates, int target,int startIndex) { if (sum == target){ result.add(new LinkedList&lt;&gt;(path)); return; }else if (sum &gt; target) return; for (int i = startIndex; i &lt; candidates.length; i++) { if (sum + candidates[i] &gt; target) continue; //剪枝优化 path.add(candidates[i]); sum += candidates[i]; backtracking(candidates,target,i); //回溯 path.removeLast(); sum -= candidates[i]; } } //================= public static void main(String[] args) { CombinationRepeatedSum combination = new CombinationRepeatedSum(); int[] cadidates = {2,3,5}; combination.combinationSum(cadidates,8); }} 5.组合总和IIleetcode题目链接 题目 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] 思路分析 本题的难点在于：集合（数组candidates）有重复元素，但还不能有重复的组合。 所以就要就行去重操作(首先对数组candidates进行排序，才能有效去重) 去重代码: 1234// 要对同一树层使用过的元素进行跳过,是一个去重操作if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-1]){ continue;} 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Arrays;import java.util.LinkedList;import java.util.List;/** * 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 * candidates 中的每个数字在每个组合中只能使用一次。 * * 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: * [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] * * 链接：https://leetcode-cn.com/problems/combination-sum-ii */public class CombinationNoRepeatSum { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); int sum; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); backtracking(candidates,target,0); return result; } private void backtracking(int[] candidates, int target, int startIndex) { if (sum == target){ result.add(new LinkedList&lt;&gt;(path)); return; }else if (sum &gt; target) return; for (int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) {//sum + candidates[i] &lt;= target为剪枝操作 // 要对同一树层使用过的元素进行跳过,是一个去重操作 if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-1]){ continue; } path.add(candidates[i]); sum += candidates[i]; backtracking(candidates,target,i + 1); path.removeLast(); sum -= candidates[i]; } } //------------------------ public static void main(String[] args) { CombinationNoRepeatSum combination = new CombinationNoRepeatSum(); int[] cadidates = {2,5,2,1,2}; combination.combinationSum2(cadidates,5); }}","categories":[{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"二叉搜索树刷题笔记","slug":"二叉搜索树刷题笔记","date":"2021-08-26T11:08:13.000Z","updated":"2021-08-26T14:34:15.601Z","comments":true,"path":"posts/9a06.html","link":"","permalink":"https://www.colorfo.top/posts/9a06.html","excerpt":"","text":"一、求二叉搜索树的属性1.二叉搜索树的搜索leetcode题目链接 题目 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 示例： 思路分析 利用二叉搜索树的性质，如果val &lt; root.val 就向左遍历，root = root.left, 如果val &gt; root.val 就向右遍历，root = root.right,如果val == root.val就返回root节点 代码详情 12345678910111213141516171819202122232425262728293031/** * 方法一：迭代，利用二叉搜索树的特性 */public TreeNode searchBST3(TreeNode root,int val){ if (root == null) return root; while (root != null){ if (val &lt; root.val) root = root.left; else if (val &gt; root.val) root = root.right; else return root; } return null;} /** * 方法二：递归 * @param root * @param val * @return */public TreeNode searchBST2(TreeNode root,int val){ if (root == null || root.val == val) return root; if (val &lt; root.val) return searchBST2(root.left,val); if (val &gt; root.val) return searchBST2(root.right,val); return null;} 2.验证二叉搜索树leetcode题目链接 题目 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 思路分析 利用中序遍历，遍历二叉搜索树，可以得到一个序列，如果这个序列是严格递增的， 则该二叉树是二叉搜索树。 代码详情 提供两个方法： 方法一：利用中序遍历将二叉搜索树变为一个序列，判断这个序列 是否是升序的 &lt;=&gt; 是否是二叉搜索树 方法二：利用双指针判断中序遍历时二叉搜索树 是否是严格递增的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.ArrayList;import java.util.List;public class ValidateBST { /** * 方法一：利用中序遍历将二叉搜索树变为一个序列，判断这个序列 是否是升序的 &lt;=&gt; 是否是二叉搜索树 * @param root * @return */ public boolean isValidBST(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); //中序遍历得到一个序列 infixOrder(root,result); //正常的BST按照中序遍历可以得到一个升序序列，所以可以以此来判断是不是一个BST int size = result.size(); for (int i = 1; i &lt; size; i++) { if (result.get(i) &lt;= result.get(i-1)) return false; } return true; } //中序遍历 private void infixOrder(TreeNode root, List&lt;Integer&gt; result) { if (root == null) return; infixOrder(root.left,result); result.add(root.val); infixOrder(root.right,result); } //---------------------- /**方法二： *利用双指针判断中序遍历时二叉搜索树 是否是严格递增的 */ TreeNode pre; boolean flag; public boolean isValidBST2(TreeNode root){ if (root == null) return false; flag = true; infixOrder2(root); return flag; } private void infixOrder2(TreeNode root) { if (root == null) return; infixOrder2(root.left); //左 if (pre != null) { //中 if (root.val &lt;= pre.val){ flag = false; return; } } pre = root; infixOrder2(root.right); //右 }} 3.二叉搜索树的最小绝对差leetcode题目链接 题目 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 示例： 提示：树中至少有两个节点 思路分析 方法一：转为有序数组 题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。 注意是二叉搜索树，二叉搜索树可是有序的。 遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了 方法二：双指针法 需要用一个pre节点记录一下cur节点的前一个节点。 代码详情 方法一：把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。 方法二：在中序遍历的过程中，利用双指针，即pre指向cur的前一个，然后做差比较，取最小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.ArrayList;import java.util.List;public class MinusTwo { /**方法一： * 把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。 * * @param root * @return */ public int getMinimumDifference(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); infixOrder(root,result); int size = result.size(); int min = Integer.MAX_VALUE; int temp; for (int i = 1; i &lt; size; i++) { temp = result.get(i) - result.get(i-1); min = min &lt; temp ? min : temp; } return min; } private void infixOrder(TreeNode root, List&lt;Integer&gt; result) { if (root == null) { return; } infixOrder(root.left,result); result.add(root.val); infixOrder(root.right,result); } /** * 方法二：在中序遍历的过程中，利用双指针，即pre指向cur的前一个，然后做差比较，取最小 */ TreeNode pre; int result = Integer.MAX_VALUE; public int getMinimumDifference2(TreeNode root){ traversal(root); return result; } private void traversal(TreeNode cur) { if (cur == null) return; traversal(cur.left);//左 if (pre != null){ //中 result = Math.min(result,cur.val - pre.val); } pre = cur; // 记录前一个 traversal(cur.right); //右 }} 4.二叉搜索树中的众数leetcode题目链接 题目 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 示例：给定 BST [1,null,2,2], 返回[2]. 提示：如果众数超过1个，不需考虑输出顺序 思路分析 在二叉树：搜索树的最小绝对差 中我们就使用了pre指针和cur指针的技巧，这次又用上了。 弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。 而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。 代码如下： 12345678if (pre == NULL) { // 第一个节点 count = 1; // 频率为1} else if (pre-&gt;val == cur-&gt;val) { // 与前一个节点数值相同 count++;} else { // 与前一个节点数值不同 count = 1;}pre = cur; // 更新上一个节点 那么如何只遍历一遍就取出所有的众数呢？ 如果 频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中（以下代码为result数组），代码如下： 123if (count == maxCount) { // 如果和最大值相同，放进result中 result.push_back(cur-&gt;val);} 是不是感觉这里有问题，result怎么能轻易就把元素放进去了呢，万一，这个maxCount此时还不是真正最大频率呢。 所以下面要做如下操作： 频率count 大于 maxCount的时候，不仅要更新maxCount，而且要清空结果集（以下代码为result数组），因为结果集之前的元素都失效了。 12345if (count &gt; maxCount) { // 如果计数大于最大值 maxCount = count; // 更新最大频率 result.clear(); // 很关键的一步，不要忘记清空result，之前result里的元素都失效了 result.push_back(cur-&gt;val);} 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.ArrayList;import java.util.List;/** * 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 */public class FindModeInBST { List&lt;Integer&gt; resCount; int count; //用来计数 int maxCount; //出现的最大次数 TreeNode pre; //cur的前一个指针 public int[] findMode(TreeNode root){ resCount = new ArrayList&lt;&gt;(); infix(root); int[] res = new int[resCount.size()]; for (int i = 0; i &lt; resCount.size(); i++) { res[i] = resCount.get(i); } return res; } //中序遍历 private void infix(TreeNode cur) { if (cur == null) return; infix(cur.left); //左 if (pre == null){ //第一个节点 count = 1; }else if (pre.val != cur.val){ //与前一个节点数值不同 count = 1; }else{ //与前一个节点数值相同 count++; } if (count == maxCount){ //如果和出现最多的频率相同 resCount.add(cur.val); } if (count &gt; maxCount){ resCount.clear(); //将resCount清空 maxCount = count; //更新maxCount resCount.add(cur.val); //将节点的值加进去 } pre = cur; //更新上一个指针 infix(cur.right); // 右 }} 5.把二叉搜索树转换为累加树leetcode题目链接 题目 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 思路分析 其实这就是一棵树，大家可能看起来有点别扭，换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]，是不是感觉这就简单了。 为什么变成数组就是感觉简单了呢？ 因为数组大家都知道怎么遍历啊，从后向前，挨个累加就完事了，这换成了二叉搜索树，看起来就别扭了一些是不是。 那么知道如何遍历这个二叉树，也就迎刃而解了，从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历（按照右 中 左） 这个二叉树，然后顺序累加就可以了。 代码详情 依然使用双指针， 利用cur.val += pre.val,来更新当前节点的值 123456789101112131415161718192021222324252627282930313233343536/** * 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree）， * 使每个节点 node的新值等于原树中大于或等于node.val的值之和。 * * 链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree * */public class BSTToGreaterSumTree { TreeNode pre; public TreeNode convertBST(TreeNode root) { if (root == null) return null; Uninfix(root); return root; } //按照右 中 左 的顺序 遍历 累加 ，然后得到一个累加树 private void Uninfix(TreeNode cur) { if (cur == null) { return; } //右 Uninfix(cur.right); //中 if (pre != null) cur.val += pre.val; pre = cur; //左 Uninfix(cur.left); }} 二、树的公共祖先问题1.二叉树的最近公共祖先leetcode题目链接 题目 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 示例： 思路分析 二叉树的最近公共祖先 代码详情 12345678910111213141516171819/**找二叉树的公共祖先，这题不太好理解，最好是背一下 * * 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 */public class ClosestAncestor { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == p || root == q || root == null) return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if (left != null &amp;&amp; right != null) return root; if (left == null &amp;&amp; right == null) return null; return left != null ? left : right; }} 2.二叉搜索树的最近公共祖先leetcode题目链接 题目 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 示例： 思路分析 本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。 在有序树里，如果判断一个节点的左子树里有p，右子树里有q呢？ 其实只要从上到下遍历的时候，cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了。 理解这一点，本题就很好解了。 和二叉树：公共祖先问题不同，普通二叉树求最近公共祖先需要使用回溯，从底向上来查找，二叉搜索树就不用了，因为搜索树有序（相当于自带方向），那么只要从上向下遍历就可以了。 那么我们可以采用前序遍历（其实这里没有中节点的处理逻辑，遍历顺序无所谓了）。 如图所示：p为节点3，q为节点5 可以看出直接按照指定的方向，就可以找到节点4，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！ 代码详情 1234567891011121314151617181920212223242526272829303132333435363738/** * 二叉搜索树的公共祖先 */public class ClosestAncestorBST { //方法一，递归 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q){ if (root == null) return null; //root.val的值不在[p,q](假设p.val &lt; q.val),则递归查找 if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) { return lowestCommonAncestor(root.right,p,q); }else if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) { return lowestCommonAncestor(root.left,p,q); }else { //root.val的值在区间内，直接返回 return root; } } //方法二：迭代法 public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) { if (root == null) return null; while (root != null){ if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) root = root.left; else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) root = root.right; else return root; } return null; }} 三、二叉搜索树的修改与构造1.二叉搜索树中的插入操作leetcode题目链接 题目 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。 提示： 给定的树上的节点数介于 0 和 10^4 之间 每个节点都有一个唯一整数值，取值范围从 0 到 10^8 -10^8 &lt;= val &lt;= 10^8 新值和原始二叉搜索树中的任意节点值都不同 思路分析 利用二叉搜索树的性质，遍历，然后找到空节点插入即可，插入时注意插入的位置(左边还是右边) 代码详情 提供两种方法，详情看代码以及注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 * 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/insert-into-a-binary-search-tree */public class InsertIntoBST { /**方法一：迭代 * 利用两个指针，当cur指针为空时，说明找到合适的位置， * 如果是val &lt; cur.val 的条件使得cur 指向 cur.left，后为空，则让pre.left = new TreeNode(val); * 如果是val &gt; cur.val 的条件使得cur 指向 cur.right，后为空，则让pre.right = new TreeNode(val); * * @param root * @param val * @return */ public TreeNode insertIntoBST2(TreeNode root, int val) { if (root == null) return new TreeNode(val); TreeNode pre = null; TreeNode cur = root; while (true) { pre = cur; if (val &lt; cur.val) { cur = cur.left; if (cur == null) { pre.left = new TreeNode(val); break; } } else if (val &gt; cur.val) { cur = cur.right; if (cur == null) { pre.right = new TreeNode(val); break; } } } return root; } /** * 方法二：递归 * @param root * @param val * @return */ public TreeNode insertIntoBST(TreeNode root,int val){ if (root == null) { return new TreeNode(val); } if (root.val &lt; val) root.right = insertIntoBST(root.right,val); else if (root.val &gt; val) root.left = insertIntoBST(root.left,val); return root; }} 2.删除二叉搜索树中的节点leetcode题目链接 题目 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 O(h)，h 为树的高度。 示例: 思路分析 删除二叉搜索树中的节点 代码详情 1234567891011121314151617181920212223242526272829303132333435363738public class DeleteNodeInBST { public TreeNode deleteNode(TreeNode root, int val) { if (root == null) return null; //没找到要删除的节点，直接返回null if (root.val == val){ //第一种情况，root节点的左右孩子都为空，说明要删除的是叶子节点，直接返回null if (root.left == null &amp;&amp; root.right == null) { return null; //第二种情况，左孩子为空，返回右孩子 } else if (root.left == null) { return root.right; //第三种情况，右孩子为空，返回左孩子 }else if (root.right == null){ return root.left; //第四种情况，左右孩子都不为空，把，左孩子添加到以右孩子为头节点的树的最左边 }else { TreeNode cur = root.right; while (cur.left != null){ //一直往左遍历，找到root节点的右孩子的最左边 cur = cur.left; } cur.left = root.left; return root.right; } } //这里相当于把新的节点返回给上一层，上一层就要用 root-&gt;left 或者 root-&gt;right接住 if (val &lt; root.val) root.left = deleteNode(root.left,val); if (val &gt; root.val) root.right = deleteNode(root.right,val); return root; }} 3.修剪二叉搜索树leetcode题目链接 题目 给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。 思路分析 修剪二叉搜索树 代码详情 123456789101112131415161718192021222324252627282930313233/**这题不太好理解，最好是背住代码！！！ * * 题目： * 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树， * 使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构 * （即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。 * 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 * * 链接：https://leetcode-cn.com/problems/trim-a-binary-search-tree */public class TrimBST { public TreeNode trimBST(TreeNode root,int low,int high){ if (root == null) { return null; } if (root.val &lt; low){ // 寻找符合区间[low, high]的节点 return trimBST(root.right,low,high); } if (root.val &gt; high){ // 寻找符合区间[low, high]的节点 return trimBST(root.left,low,high); } //代码走到这里，说明root.val的值，在[low,high]区间内 root.left = trimBST(root.left,low,high); // root-&gt;left接入符合条件的左孩子 root.right = trimBST(root.right,low,high); // root-&gt;right接入符合条件的右孩子 return root; }} 总结在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl给大家大体分分类。 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。 注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序， 二叉树：找所有路径也用了前序，这是为了方便让父节点指向子节点。 所以求普通二叉树的属性还是要具体问题具体分析。 参考：以上题目解答来自：代码随想录，感谢carl哥！！！","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"BST","slug":"BST","permalink":"https://www.colorfo.top/tags/BST/"}]},{"title":"二叉树刷题笔记②","slug":"二叉树刷题笔记②","date":"2021-08-24T05:40:11.000Z","updated":"2021-08-26T14:24:13.351Z","comments":true,"path":"posts/abcb.html","link":"","permalink":"https://www.colorfo.top/posts/abcb.html","excerpt":"","text":"1.左叶子之和leetcode题目链接 题目 计算给定二叉树的所有左叶子之和。 思路分析 首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。 因为题目中其实没有说清楚左叶子究竟是什么节点，那么我来给出左叶子的明确定义：如果左节点不为空，且左节点没有左右孩子，那么这个节点就是左叶子 如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下： 123if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null){ //处理逻辑} 代码实现 分别使用递归法和迭代法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 计算给定二叉树的所有左叶子之和。 */public class SumOfLeftLeaves { /** * 递归法求二叉树的所有左叶子节点之和 * @param root * @return */ public int sumOfLeftLeaves(TreeNode root){ if (root == null) return 0; //递归终止条件 int mid = 0; //左叶子节点的条件 if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null){ mid = root.left.val; } //递归root节点的左子树和右子树 int left = sumOfLeftLeaves(root.left); int right = sumOfLeftLeaves(root.right); //把所有找到的左叶子节点求和 int sum = mid + left + right; return sum; } //迭代法，使用栈 public int sumOfLeftLeaves2(TreeNode root){ if (root == null) return 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); int sum = 0; while (!stack.isEmpty()){ root = stack.pop(); //左叶子节点的条件 if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null){ sum += root.left.val; } if (root.right != null) stack.push(root.right); if (root.left != null) stack.push(root.left); } return sum; }} 2.找树左下角的值leetcode题目链接 题目 给定一个二叉树，在树的最后一行找到最左边的值。 思路分析 直接利用层序遍历，找到每一层最左边的节点即可 代码详情 123456789101112131415161718192021222324public class BottomLeftValue { public int findBottomLeftValue(TreeNode root) { if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int result = 0; while (!queue.isEmpty()){ int size = queue.size(); for (int i = 0; i &lt; size; i++) { TreeNode cur = queue.poll(); if (i == 0) result = cur.val; if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return result; }} 3.最大二叉树leetcode题目链接 题目 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。 示例 ： 思路分析 最大二叉树的构建过程如下： 构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。 代码详情 1234567891011121314151617181920212223242526272829303132public class ConstructMaximumBinaryTree { public TreeNode constructMaximumBinaryTree(int[] nums) { return traversal(nums,0,nums.length); } private TreeNode traversal(int[] nums, int left, int right) { //递归的参数和返回值 //递归终止条件 if (left &gt;= right){ return null; } //分割点下标,因为下面比较要用到，所以要赋初始值 int maxValueIndex = left; //寻找分割点 for (int i = left; i &lt; right; i++) { if (nums[i] &gt; nums[maxValueIndex]) maxValueIndex = i; } TreeNode root = new TreeNode(nums[maxValueIndex]); // 左闭右开：[left, maxValueIndex) root.left = traversal(nums,left,maxValueIndex); // 左闭右开：[maxValueIndex + 1, right) root.right = traversal(nums,maxValueIndex+1,right); return root; }} 4.将有序数组转为二叉搜索树leetcode题目链接 题目 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例： 思路分析 如果根据数组构造一颗二叉树。 本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间。 本题其实要比第三题 ：最大二叉树简单一些，因为有序数组构造二叉搜索树，寻找分割点就比较容易了。 分割点就是数组中间位置的节点。 那么为问题来了，如果数组长度为偶数，中间节点有两个，取哪一个？ 取哪一个都可以，只不过构成了不同的平衡二叉搜索树。 例如：输入：[-10,-3,0,5,9] 如下两棵树，都是这个数组的平衡二叉搜索树： 如果要分割的数组长度为偶数的时候，中间元素为两个，是取左边元素 就是树1，取右边元素就是树2。 代码详情 123456789101112131415161718192021222324252627282930313233343536373839404142/**题目： * 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 * 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。 * 链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree * * 本题可以不用考虑是不是高度平衡的 * 另外，此题和 最大二叉树 有点类似 * * 最大二叉树题目： * 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： * 二叉树的根是数组中的最大元素。 * 左子树是通过数组中最大值左边部分构造出的最大二叉树。 * 右子树是通过数组中最大值右边部分构造出的最大二叉树。 * 通过给定的数组构建最大二叉树，并且输出这个树的根节点。 * 题目地址：https://leetcode-cn.com/problems/maximum-binary-tree/ */public class ConvertSortedArrayToBST { public TreeNode sortedArrayToBST(int[] nums) { if (nums.length == 0) return null; TreeNode root = traversal(nums,0,nums.length - 1); return root; } private TreeNode traversal(int[] nums, int left, int right) { if (left &gt; right) return null; int mid = (left + right) / 2; TreeNode root = new TreeNode(nums[mid]); //左闭右闭 root.left = traversal(nums,left,mid-1); root.right = traversal(nums,mid+1,right); return root; }} 5.合并二叉树leetcode题目链接 题目 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例： 思路分析 以Tree1为要返回的树，如果对应的节点中，有其中一个为空，就返回另一个，如果两个都不为空，则把节点的值相加 然后递归两棵树对应的左孩子和右孩子，最后返回Tree1的头节点 代码详情 123456789101112131415public class MergeTrees { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) return root2; if (root2 == null) return root1; root1.val += root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; }} 总结 1.前序、中序和后序遍历考虑使用栈 2.层序遍历考虑使用队列 3.其它情况先考虑队列，再考虑使用栈 参考：代码随想录，感谢carl哥！！！","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"二叉树刷题笔记①","slug":"二叉树刷题笔记①","date":"2021-08-23T01:40:28.000Z","updated":"2021-08-24T06:05:33.621Z","comments":true,"path":"posts/6b0a.html","link":"","permalink":"https://www.colorfo.top/posts/6b0a.html","excerpt":"","text":"1.反转二叉树leetcode题目链接 题目 反转一颗二叉树 代码详情 1.DFS递归，可以使用前序和后序遍历，交换当前节点的左右孩子 2.BFS，利用层序遍历，交换当前节点的左右孩子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class InvertBinaryTree { /**DFS递归 * * 这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不行， * 因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了 */ public TreeNode invertTree(TreeNode root){ if (root == null){ return root; } invert(root); return root; } private void invert(TreeNode root) { if (root == null){ return; } TreeNode temp = null; temp = root.left; root.left = root.right; root.right = temp; invert(root.left); invert(root.right); } //------------------------------------ /**BFS层序遍历 *利用层序遍历，交换当前节点的左右孩子 */ public TreeNode invertTreeBFS(TreeNode root){ if (root == null){ return root; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()){ int size = queue.size(); //交换当前层的节点的左右孩子 TreeNode cur = null; TreeNode temp = null; for (int i = 0; i &lt; size; i++) { cur = queue.poll(); temp = cur.left; cur.left = cur.right; cur.right = temp; if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return root; }} 2.对称二叉树leetcode题目链接 题目:给定一个二叉树，检查它是否是镜像对称的。 方法一：递归 思路分析 首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！ 对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也是要同时遍历两棵树。 那么如果比较呢？ 比较的是两个子树的里侧和外侧的元素是否相等。如图所示： 那么遍历的顺序应该是什么样的呢？ 本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。 正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。 但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。 代码详情 1234567891011121314151617181920212223242526/** * 方法一：递归法 */ public boolean isSymmetric(TreeNode root){ if (root == null){ return true; } return compare(root.left,root.right); } private boolean compare(TreeNode left, TreeNode right) { //首先判断节点为空的情况 if (left == null &amp;&amp; right == null) return true; else if (left == null &amp;&amp; right != null) return false; else if (left != null &amp;&amp; right == null) return false; // 排除了空节点，再排除数值不相同的情况 else if (left.val != right.val) return false; // 此时就是：左右节点都不为空，且数值相同的情况 // 此时才做递归，做下一层的判断 boolean outside = compare(left.left,right.right); // 比较左节点的左孩子 和 右节点的右孩子 boolean inside = compare(left.right,right.left); // 比较左节点的右孩子 和 右节点的左孩子 boolean isSame = outside &amp;&amp; inside; // 左子树：中、 右子树：中 （逻辑处理） return isSame; } 方法二：迭代法 思路分析 通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示： 代码详情 123456789101112131415161718192021222324252627282930/** * 方法二：迭代法(使用一个队列实现) */ public boolean isSymmetric2(TreeNode root){ if (root == null) return true; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root.left); // 将左子树头结点加入队列 queue.offer(root.right); // 将右子树头结点加入队列 while (!queue.isEmpty()){ // 接下来就要判断这这两个树是否相互翻转 TreeNode leftNode = queue.poll(); TreeNode rightNode = queue.poll(); if (leftNode == null &amp;&amp; rightNode == null){ // 左节点为空、右节点为空，此时说明是对称的 continue; } // 左右一个节点不为空，或者都不为空但数值不相同，返回false if (leftNode == null || rightNode == null || leftNode.val != rightNode.val){ return false; } queue.offer(leftNode.left); // 加入左节点左孩子 queue.offer(rightNode.right); // 加入右节点右孩子 queue.offer(leftNode.right); // 加入左节点右孩子 queue.offer(rightNode.left); // 加入右节点左孩子 } return true; } 3.完全二叉树的节点个数leetcode题目链接 题目 给出一个完全二叉树，求出该树的节点个数。 方法一：层序遍历 思路分析 遍历模板稍稍修改一下，记录遍历的节点数量就可以了。 代码详情 123456789101112131415161718192021222324252627282930/**方法一 * 利用层序遍历的模板，统计二叉树的节点个数 * @param root * @return */ public int countNodes(TreeNode root) { if (root == null) { return 0; } //LinkedList可以作为Queue的实现类 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入队列 int count = 0; while (!queue.isEmpty()) { int size = queue.size(); //取出当前队列的大小 TreeNode cur = null; //将队列中的元素依次取出，然后让其左右子树(如果不为空的话)入队列 for (int i = 0; i &lt; size; i++) { count++; //记录当前二叉树的节点个数 cur = queue.poll(); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return count; } 方法二：递归 思路分析 1.确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。 代码如下： 1int getNodesNum(TreeNode root) { } 2.确定终止条件：如果为空节点的话，就返回0，表示节点数为0。 代码如下： 1if (root == null) return 0; 3.确定单层递归的逻辑：先求它的左子树的节点数量，再求的右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。 代码如下： 1234int leftNum = getNodesNum(root.left); //左int rightNum = getNodesNum(root.right); //右int treeNum = leftNum + rightNum + 1; //中return treeNum; java整体代码如下： 12345678910111213141516/**方法二 * 利用递归统计二叉树的节点个数 */ public int countNode(TreeNode root){ return getNodesNum(root); } private int getNodesNum(TreeNode root) { if (root == null) { return 0; } int leftNum = getNodesNum(root.left); //左 int rightNum = getNodesNum(root.right); //右 int treeNum = leftNum + rightNum + 1; //中 return treeNum; } 4.平衡二叉树leetcode题目链接 题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 二叉树的高度与深度 ​ 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。 ​ 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。 代码详情 下面的方法通过层序遍历获得当前节点距离叶子节点的高度 1234567891011121314151617181920//此方法可以获取当前root节点距离叶子节点的高度 private int levelOrder(TreeNode root) { if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int high = 0; while (!queue.isEmpty()){ int size = queue.size(); TreeNode cur; high++; for (int i = 0; i &lt; size; i++) { cur = queue.poll(); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return high; } 然后再用栈来模拟前序遍历，遍历每一个节点的时候，再去判断左右孩子的高度是否符合，代码如下： 1234567891011121314151617181920212223242526272829/**:迭代法，使用层序遍历 * * 用栈来模拟前序遍历，遍历每一个节点的时候， * 再去判断左右孩子的高度是否符合，代码如下 * @param root * @return */ public boolean isBalanced(TreeNode root){ if (root == null){ return true; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); TreeNode cur = null; while (!stack.isEmpty()){ cur = stack.pop(); if (Math.abs(levelOrder(cur.left) - levelOrder(cur.right)) &gt; 1){ return false; } if (cur.left != null) stack.push(cur.left); if (cur.right != null) stack.push(cur.right); } return true; } 5. 二叉树的所有路径leetcode题目链接 题目 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 思路分析 这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。 在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。 前序遍历以及回溯的过程如图： 我们先使用递归的方式，来做前序遍历。要知道递归和回溯就是一家的，本题也需要回溯。 递归三部曲 1.递归函数函数参数以及返回值 要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下 1private void traversal(TreeNode root, LinkedList&lt;Integer&gt; path, List&lt;String&gt; result) 2.递归终止条件 当 root不为空，其左右孩子都为空的时候，就找到叶子节点。 所以本题的终止条件是： 123456789101112//遍历到了叶子节点//将path保存的节点值，全部转为字符串sPath,这样就得到了路径，最后放入result集合中 if (root.left == null &amp;&amp; root.right == null){ int size = path.size(); String sPath = \"\"; for (int i = 0; i &lt; size - 1; i++) { sPath += path.get(i); sPath += \"-&gt;\"; } sPath += path.get(size - 1); //这里记录最后一个节点(叶子节点)，因为输出格式需要 result.add(sPath); } if花括号里面的是，终止的处理逻辑 3.单层递归逻辑 因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。 1path.add(root.val); //将当前节点值加入到path集合中 然后是递归和回溯的过程，上面说过没有判断root是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了(所以说能进递归函数的root节点一定是不为空的)。 所以递归前要加上判断语句，下面要递归的节点是否为空，如下 123456789if (root.left != null){ traversal(root.left,path,result); //递归 path.removeLast(); //回溯}if (root.right != null){ traversal(root.right,path,result); //递归 path.removeLast(); //回溯} 整体代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package top.colorfor.tree;import java.util.LinkedList;import java.util.List;public class PathsOfTree { public List&lt;String&gt; treePaths(TreeNode root) { List&lt;String&gt; result = new LinkedList&lt;&gt;(); //result集合作为最后的结果 if (root == null) return result; LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); //path集合保存递归过程中的节点的值 traversal(root,path,result); return result; } private void traversal(TreeNode root, LinkedList&lt;Integer&gt; path, List&lt;String&gt; result) { path.add(root.val); //将当前节点值加入到path集合中 //遍历到了叶子节点 //将path保存的节点值，全部转为字符串sPath,这样就得到了路径，最后放入result集合中 if (root.left == null &amp;&amp; root.right == null){ int size = path.size(); String sPath = \"\"; for (int i = 0; i &lt; size - 1; i++) { sPath += path.get(i); sPath += \"-&gt;\"; } sPath += path.get(size - 1); result.add(sPath); } if (root.left != null){ traversal(root.left,path,result); //递归 path.removeLast(); //回溯 } if (root.right != null){ traversal(root.right,path,result); //递归 path.removeLast(); //回溯 } } //-----------main---------------- /* public static void main(String[] args) { PathsOfTree tree = new PathsOfTree(); TreeNode root = new TreeNode(1); TreeNode node2 = new TreeNode(2); TreeNode node3 = new TreeNode(3); root.left = node2; root.right = node3; node2.left = new TreeNode(4); List&lt;String&gt; strings = tree.treePaths(root); for (String string : strings) { System.out.println(string); } }*/} 6.路径总和leetcode题目链接 题目 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 代码详情 此题可在第5题代码的基础上稍加修改得到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class PathSum { public boolean hasPathSum(TreeNode root,int targetSum){ if (root == null) return false; LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); traversal(root,path,result,targetSum); return result.contains(targetSum); } private void traversal(TreeNode root, LinkedList&lt;Integer&gt; path, List&lt;Integer&gt; result,int targetSum) { path.add(root.val); if (root.left == null &amp;&amp; root.right == null){ int size = path.size(); int sum = 0; for (int i = 0; i &lt; size; i++) { sum += path.get(i); } result.add(sum); if (sum == targetSum) { return; } } if (root.left != null){ traversal(root.left,path,result,targetSum); path.removeLast(); } if (root.right != null){ traversal(root.right,path,result,targetSum); path.removeLast(); } } //-----------main---------------- public static void main(String[] args) { PathSum tree = new PathSum(); TreeNode root = new TreeNode(1); TreeNode node2 = new TreeNode(2); TreeNode node3 = new TreeNode(3); root.left = node2; root.right = node3; node2.left = new TreeNode(4); boolean b = tree.hasPathSum(root, 4); System.out.println(b); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"二叉树的层序遍历","slug":"二叉树的层序遍历","date":"2021-08-21T12:16:58.000Z","updated":"2021-08-21T13:13:07.591Z","comments":true,"path":"posts/bd66.html","link":"","permalink":"https://www.colorfo.top/posts/bd66.html","excerpt":"","text":"1.二叉树的层序遍历 leetcode题目链接 题目 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点） 思路分析 需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。 而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。 使用队列实现二叉树广度优先遍历，动画如下： 代码详情 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; }}*///二叉树的层序遍历public class LevelOrder { /** * * @param root 二叉树的根节点 * @return 返回层序遍历的结果 */ public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root){ List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if (root == null){ return result; } //LinkedList可以作为Queue的实现类 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入队列 while (!queue.isEmpty()){ int size = queue.size(); //取出当前队列的大小 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); TreeNode cur = null; //将队列中的元素依次取出，然后让其左右子树(如果不为空的话)入队列 for (int i = 0; i &lt; size; i++) { cur = queue.poll(); list.add(cur.val); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } //将每层遍历的结果放入result集合中 result.add(list); } return result; }} 这份代码也可以作为二叉树层序遍历的模板,十分重要，一定要会 2.二叉树的层次遍历 IIleetcode题目链接 题目 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 代码详情 此题跟第一题差不多，可以使用Collections.reverse()方法，或者使用栈把第一题的结果反转一下即可， 直接给出代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//层序遍历，自底向上输出public class LevelOrder2 { /** * * @param root 二叉树的根节点 * @return 返回层序遍历的结果 */ public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root){ List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); Stack&lt;List&lt;Integer&gt;&gt; stack = new Stack&lt;&gt;(); if (root == null){ return result; } //LinkedList可以作为Queue的实现类 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入队列 while (!queue.isEmpty()){ int size = queue.size(); //取出当前队列的大小 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); TreeNode cur = null; //将队列中的元素依次取出，然后让其左右子树(如果不为空的话)入队列 for (int i = 0; i &lt; size; i++) { cur = queue.poll(); list.add(cur.val); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } //将每层遍历的结果先放入stack stack.push(list); } //将栈中保存的每层的遍历结果，依次弹出，然后加入到result集合中 //这样就实现了二叉树自底向上的层序遍历 while (!stack.isEmpty()){ result.add(stack.pop()); } return result; }} 3.二叉树的右视图leetcode题目链接 题目 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 思路分析 层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 给定一个二叉树的 根节点 root，想象自己站在它的右侧， * 按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 */public class RightSideView { /** * * @param root 二叉树的根节点 * @return 返回层序遍历的结果 */ public List&lt;Integer&gt; levelOrder(TreeNode root){ List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null){ return result; } //LinkedList可以作为Queue的实现类 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入队列 while (!queue.isEmpty()){ int size = queue.size(); //取出当前队列的大小 LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); TreeNode cur = null; //将队列中的头元素取出，然后让其左右子树(如果不为空的话)入队列 for (int i = 0; i &lt; size; i++) { cur = queue.poll(); //如果是最后一个，就加入result集合 if (i == size-1) result.add(cur.val); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return result; }} 4.二叉树的层平均值leetcode题目链接 题目 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 代码详情 本题就是层序遍历的时候把一层求个总和在取一个均值。 123456789101112131415161718192021222324252627282930313233343536/** * 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 */public class AverageOfLevels { public List&lt;Double&gt; averageOfLevels(TreeNode root){ List&lt;Double&gt; result = new LinkedList&lt;&gt;(); if (root == null){ return result; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //根节点入队列 while (!queue.isEmpty()){ int size = queue.size(); // 获取队列的大小 double average = 0.0; double sum = 0.0; TreeNode cur = null; for (int i = 0; i &lt; size; i++) { cur = queue.poll(); sum = sum + cur.val; // sum累加，把每层的节点值相加 if (i == size-1){ // 遇到每层的最后一个节点，求该层的平均值 average = sum / size; } //让左右子树(如果不为空的话)入队列 if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } result.add(average); } return result; }} 5.N叉树的层序遍历leetcode题目链接 题目 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。 例如，给定一个 3叉树 : 返回其层序遍历: [ [1], [3,2,4], [5,6] ] 代码详情 这道题依旧是模板题，只不过一个节点有多个孩子了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*public class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; }}*//** * 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。 */public class NTreeLevelOrder { public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root){ List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if (root == null) { return result; } Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入队列 while (!queue.isEmpty()){ int size = queue.size(); Node cur = null; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) { //队列的头节点出队列，并将节点的值加入该层list集合 cur = queue.poll(); list.add(cur.val); //如果该节点的子节点不为空，则全部加入队列中 if (cur.children != null){ List&lt;Node&gt; children = cur.children; int len = children.size(); int index = 0; while (index &lt; len){ queue.offer(children.get(index++)); } } } //将当前层的节点值集合list加入到result集合中 result.add(list); } return result; }} 6.在每个树行中找最大值leetcode题目链接 题目 您需要在二叉树的每一行中找到最大的值。 代码详情 层序遍历，取每一层的最大值 12345678910111213141516171819202122232425262728293031323334public class FindLargestInTreeRow { public List&lt;Integer&gt; largestValues(TreeNode root){ LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null){ return result; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入到队列中 while (!queue.isEmpty()){ int size = queue.size(); TreeNode cur = null; int maxRow = Integer.MIN_VALUE; int temp = 0; //将遍历当前层的节点，找出最大值，保存在maxRow中 for (int i = 0; i &lt; size; i++) { cur = queue.poll(); temp = cur.val; maxRow = temp &gt; maxRow ? temp : maxRow; //如果当前节点的左右子树不为空，则加入队列 if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } result.add(maxRow); } return result; }} 7.填充每个节点的下一个右侧节点指针leetcode题目链接 题目 给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 12345678910111213141516171819202122/*// Definition for a Node.class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; }};*/ 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 思路分析 本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点， 然后在遍历的时候让当前节点的next域指向下一个节点（next）就可以了 代码详情 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。 * 如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 */public class NextConnectRight { public Node connect(Node root){ if (root == null) { return null; } Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); //将根节点加入队列 while (!queue.isEmpty()){ int size = queue.size(); //获取队列的大小 Node cur = null; if (!queue.isEmpty()){ cur = queue.poll(); //使用cur指针，指向本层的第一个节点 //如果当前节点的左右子节点不为空，将左右子节点加入队列 if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } Node next = null; for (int i = 1; i &lt; size; i++) { //由于本层的第一个节点已经出队列，所以i从1开始 next = queue.poll(); //让cur右边的节点出队列 cur.next = next; //cur的next域指向cur右边的节点 //如果当前节点的左右子节点不为空，将左右子节点加入队列 if (next.left != null) queue.offer(next.left); if (next.right != null) queue.offer(next.right); //让cur往右边移动一位，为下一次循环做准备 cur = next; } } return root; }} 关联题目:填充每个节点的下一个右侧节点指针II 8.二叉树的最大深度leetcode题目链接 题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 返回它的最大深度 3 。 代码详情 本题依旧使用层序遍历，每遍历一层，二叉树的深度就加1 1234567891011121314151617181920212223242526272829public class MaxDepthOfTree { public int maxDepth(TreeNode root){ if (root == null) { return 0; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int depth = 0; while (!queue.isEmpty()){ int size = queue.size(); TreeNode cur = null; for (int i = 0; i &lt; size; i++) { cur = queue.poll(); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } depth++; } return depth; }} 9.二叉树的最小深度leetcode题目链接 题目 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 代码详情 相对于 104.二叉树的最大深度 ，本题还也可以使用层序遍历的方式来解决，思路是一样的。 需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点 1234567891011121314151617181920212223242526272829303132public class MinDepthOfTree { public int minDepth(TreeNode root){ if (root == null) { return 0; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int depth = 0; while (!queue.isEmpty()){ int size = queue.size(); depth++; TreeNode cur = null; for (int i = 0; i &lt; size; i++) { cur = queue.poll(); //如果当前节点的左右孩子都为空，直接返回最小深度 if (cur.left == null &amp;&amp; cur.right == null){ return depth; } if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return depth; }} 以上题目参考:代码随想录 感谢哈工大师兄Carl！！！","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://www.colorfo.top/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}]},{"title":"用递归和非递归的方式实现二叉树的遍历","slug":"用递归和非递归的方式实现二叉树的遍历","date":"2021-08-20T07:55:12.000Z","updated":"2021-08-20T08:13:23.224Z","comments":true,"path":"posts/a2eb.html","link":"","permalink":"https://www.colorfo.top/posts/a2eb.html","excerpt":"","text":"1.用递归的方式实现二叉树的前序、中序和后序遍历 递归三要素 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 代码实现 1234567891011121314//TreeNode节点类public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; } } 123456789101112131415161718192021222324252627282930313233343536373839404142public class RecursionTree { public void preOrderRecur(TreeNode root){ System.out.println(\"前序遍历二叉树(递归)\"); if (root == null){ return; } //中 左 右 System.out.println(root.val); preOrderRecur(root.left); preOrderRecur(root.right); } //中序遍历二叉树，递归 public void inOrderRecur(TreeNode root){ if (root == null){ return; } //前 中 右 inOrderRecur(root.left); System.out.println(root.val); inOrderRecur(root.right); } //后序遍历二叉树，递归 public void postOrderRecur(TreeNode root){ if (root == null){ return; } //左 右 中 postOrderRecur(root.left); postOrderRecur(root.right); System.out.println(root.val); }} 2.用非递归的方式实现二叉树的前序、中序和后序遍历2.1前序遍历 思路分析 前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。 为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839/**前序遍历，非递归 * * 思路分析: * * 1.申请一个新的栈，即为stack,然后将root节点压入栈中 * * * * 2.从stack中弹出栈顶节点，记为root,然后将root节点的值放入result集合， * * 再将root节点的右子节点(不为空的话)先压入栈中， * * 最后将root节点的左子节点(不为空的话)压入栈中 * * * * 3.不断重复步骤2,直到stack为空，全部过程结束 * * @param root */ public List&lt;Integer&gt; preOrderUnRecur(TreeNode root){ List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root != null){ //如果根节点不为空，将其压入栈中 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()){ //从栈中弹出栈顶元素，并打印其节点的值 root = stack.pop(); result.add(root.val); //如果当前节点的右子节点不为空，将右子节点压入栈中 if (root.right != null){ stack.push(root.right); } //如果当前节点的左子节点不为空，将左子节点压入栈中 if (root.left != null){ stack.push(root.left); } } } return result; } 2.2中序遍历 思路分析 分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。 那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。 那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。 代码实现 12345678910111213141516171819202122232425262728293031323334/**中序遍历二叉树(非递归) * * 思路分析： * 1.中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问， * 直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result集合中）， * 这就造成了处理顺序和访问顺序是不一致的。 * 2.在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。 * * @param root 二叉树的根节点 * @return 返回一个list集合，保存中序遍历的结果 */ public List&lt;Integer&gt; inOrderUnRecur(TreeNode root){ List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null){ return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()){ if (cur != null){ //指针来访问节点，访问到最底层 stack.push(cur); // 将访问的节点放进栈 cur = cur.left; //左 }else { cur = stack.pop(); //从栈里面弹出的数据就是要处理的数据 result.add(cur.val); //放进result集合中 cur = cur.right; } } return result; } 2.3 后序遍历 思路分析 再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图： 代码实现 123456789101112131415161718192021222324252627282930313233343536/**后序遍历二叉树(非递归) * * 思路分析: * 先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序， * 就变成中右左的遍历顺序，然后在反转result集合，输出的结果顺序就是左右中了 * * @param root 二叉树的根节点 * @return 返回一个list集合，保存中序遍历的结果 */ public List&lt;Integer&gt; postOrderUnRecur(TreeNode root){ List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null){ return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()){ root = stack.pop(); result.add(root.val); if (root.left != null){ stack.push(root.left); } if (root.right != null){ stack.push(root.right); } } Collections.reverse(result); return result; } 参考：代码随想录","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"二叉树的遍历","slug":"二叉树的遍历","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"}]},{"title":"KMP算法匹配字符串","slug":"KMP算法匹配字符串","date":"2021-08-15T08:13:07.000Z","updated":"2021-08-15T11:21:33.706Z","comments":true,"path":"posts/c86b.html","link":"","permalink":"https://www.colorfo.top/posts/c86b.html","excerpt":"","text":"一、KMP算法匹配字符串1.题目leetcode-链接 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 12输入：haystack = \"aabaabaaf\", needle = \"aabaaf\"输出：3 2.解答方法一：朴素解法 思路分析 直观的解法的是：枚举原串 ss 中的每个字符作为「发起点」，每次从原串的「发起点」和匹配串的「首位」开始尝试匹配： 匹配成功：返回本次匹配的原串「发起点」。匹配失败：枚举原串的下一个「发起点」，重新尝试匹配。 参考：宫水三叶 代码详情 12345678910111213141516171819class Solution { public int strStr(String ss, String pp) { int n = ss.length(), m = pp.length(); char[] s = ss.toCharArray(), p = pp.toCharArray(); // 枚举原串的「发起点」 for (int i = 0; i &lt;= n - m; i++) { // 从原串的「发起点」和匹配串的「首位」开始，尝试匹配 int a = i, b = 0; while (b &lt; m &amp;&amp; s[a] == p[b]) { a++; b++; } // 如果能够完全匹配，返回原串的「发起点」下标 if (b == m) return i; } return -1; }} 方法二:KMP算法参考：代码随想录 一、构造next数组构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步： 初始化 处理前后缀不相同的情况 处理前后缀相同的情况 1.初始化： 定义两个指针i和j，j指向前缀起始位置，i指向后缀起始位置。 然后还要对next数组进行初始化赋值，如下： 12int j = -1;next[0] = j; j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。 next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j） 所以初始化next[0] = j 。 2.处理前后缀不相同的情况 因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。 所以遍历模式串s的循环下标i 要从 1开始，代码如下： 1for(int i = 1; i &lt; s.size(); i++) { 如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。 怎么回退呢？ next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。 那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。 所以，处理前后缀不相同的情况代码如下： 1234while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退} 3.处理前后缀相同的情况 如果s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。 代码如下： 1234if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++;}next[i] = j; 最后整体构建next数组的函数代码如下： 12345678910111213void getNext(int* next, const string&amp; s){ int j = -1; next[0] = j; for(int i = 1; i &lt; s.size(); i++) { // 注意i从1开始 while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; // 将j（前缀的长度）赋给next[i] }} 代码构造next数组的逻辑流程动画如下： 二、使用next数组来做匹配在文本串s里 找是否出现过模式串t。 定义两个下标j 指向模式串起始位置，i指向文本串起始位置。 那么j初始值依然为-1，为什么呢？ 依然因为next数组里记录的起始位置为-1。 i就从0开始，遍历文本串，代码如下： 1for (int i = 0; i &lt; s.size(); i++) 接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。 如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。 代码如下： 123while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) { j = next[j];} 如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下： 123if (s[i] == t[j + 1]) { j++; // i的增加在for循环里} 如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。 本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。 代码如下： 123if (j == (t.size() - 1) ) { return (i - t.size() + 1);} 那么使用next数组，用模式串匹配文本串的整体代码如下： 123456789101112int j = -1; // 因为next数组里记录的起始位置为-1for (int i = 0; i &lt; s.size(); i++) { // 注意i就从0开始 while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) { // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动 j++; // i的增加在for循环里 } if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t return (i - t.size() + 1); }} 此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class KMPStr { public int[] getNext(String pattern){ char[] s = pattern.toCharArray(); int[] next = new int[s.length]; //初始化一个next数组 int j = -1; //j+1指向前缀起始位置 next[0] = j; for (int i = 1; i &lt; s.length; i++) { //i指向后缀起始位置,从1 开始 while(j &gt;= 0 &amp;&amp; s[i] != s[j+1]){// 前后缀不相同了 j = next[j]; //让j+1向前回退 } if(s[i] == s[j+1]){// 找到相同的前后缀 j++; //j+1后移一位 } next[i] = j; //将j（前缀的长度）赋给next[i] } return next; } public int strStr(String haystack,String needle){ if (needle.length() == 0){ return 0; } char[] s = haystack.toCharArray(); char[] t = needle.toCharArray(); int j = -1; // 因为next数组里记录的起始位置为-1 int[] next = getNext(needle); //获取next数组 for (int i = 0; i &lt; s.length; i++) { // 注意i就从0开始 while (j &gt;= 0 &amp;&amp; s[i] != t[j+1]){ // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (s[i] == t[j+1]){ // 匹配，j和i同时向后移动,i的增加在for循环里 j++; } if (j == t.length-1){ // 文本串s里出现了模式串t return i - t.length + 1; } } return -1; } //------------main------------ public static void main(String[] args) { KMPStr kmp = new KMPStr(); int[] next = kmp.getNext(\"aabaaf\"); System.out.println(Arrays.toString(next)); int i = kmp.strStr(\"aabaabaaf\", \"aabaaf\"); System.out.println(i); }} 二、重复的子字符串leetcode题目链接 题目 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 12345678910111213示例 1:输入: \"abab\"输出: True解释: 可由子字符串 \"ab\" 重复两次构成。示例 2:输入: \"aba\"输出: False示例 3:输入: \"abcabcabcabc\"输出: True解释: 可由子字符串 \"abc\" 重复四次构成。 (或者子字符串 \"abcabc\" 重复两次构成。) 思路分析 参考：代码随想录 此题依旧需要用到KMP算法的next数组。 next 数组记录的就是最长相同前后缀( 字符串：KMP算法精讲 这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。 最长相等前后缀的长度为：next[len - 1] + 1。 数组长度为：len 如果len % (len - (next[len - 1] + 1)) == 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被 数组的长度整除，说明有该字符串有重复的子字符串。 数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法 如图： next[len - 1] = 7，next[len - 1] + 1 = 8，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。 (len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf） 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class RepeatedSubstringKMP { public int[] getNext(String pattern){ char[] s = pattern.toCharArray(); int[] next = new int[s.length]; int j = -1; next[0] = j; for (int i = 1; i &lt; s.length; i++) { while (j &gt;= 0 &amp;&amp; s[i] != s[j+1]){ j = next[j]; //当前缀和后缀不相等时，j+1前移 } if (s[i] == s[j+1]){ //当前缀和后缀相等时，i,j+1分别后移 j++; } next[i] = j; } return next; } public boolean isRepeated(String pattern){ if (pattern.length() == 0){ return false; } int[] next = getNext(pattern); int len = next.length; //利用next数组判断，一个字符串是否可以由它的一个子串重复多次构成 if (next[len-1] != -1 &amp;&amp; len%(len-(next[len-1]+1)) == 0){//核心代码 return true; } return false; } //------------main--------------- public static void main(String[] args) { RepeatedSubstringKMP kmp = new RepeatedSubstringKMP(); int[] next = kmp.getNext(\"aabaaf\"); System.out.println(Arrays.toString(next)); System.out.println(kmp.isRepeated(\"aabaab\")); }}","categories":[],"tags":[{"name":"KMP算法","slug":"KMP算法","permalink":"https://www.colorfo.top/tags/KMP%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://www.colorfo.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"数组刷题笔记","slug":"数组刷题笔记","date":"2021-08-11T12:46:27.000Z","updated":"2021-08-12T12:56:04.736Z","comments":true,"path":"posts/7dec.html","link":"","permalink":"https://www.colorfo.top/posts/7dec.html","excerpt":"","text":"1.数组的二分查找 题目 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1 123输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 代码实现 12345678910111213141516171819202122232425262728293031323334353637public class BinarySearch { //二分查找 public int binarySearch(int[] nums,int target){ //先判断要查找的值是否在数组的范围内 if(target &lt; nums[0] || target &gt; nums[nums.length-1]){ return -1; } int left = 0; int right = nums.length-1; while (left &lt;= right){ int middle = (left+right)/2; if (nums[middle] == target){ return middle; }else if (target &lt; nums[middle]){ //如果要查找的值在左边 right = middle - 1; }else { //如果要查找的值在右边 left = middle+1; } } return -1; } //----------main------------- public static void main(String[] args) { BinarySearch binarySearch = new BinarySearch(); int[] arr = {-1,0,3,5,9,12}; int target = 4; int res = binarySearch.binarySearch(arr,target); System.out.println(res); }} 参考：代码随想录 2.移除数组中的元素题目链接 题目 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。 元素的顺序可以改变，你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 ​ 你不需要考虑数组中超出新长度后面的元素。 方法一：暴力求解 思路分析 这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。 代码实现 123456789101112131415161718192021222324252627282930313233343536public class RemoveElement { /**暴力移除数组的元素 * * @param arr 输入的数组 * @param val 要移除的元素 * @return 返回新的数组的长度 */ public int removeElement(int[] arr,int val){ int size = arr.length; for (int i = 0; i &lt; arr.length; i++) { //如果找到要删除的值,就利用一个for循环,将下标i后面的值统统后移 if (arr[i] == val){ for (int j = i+1; j &lt; arr.length; j++) { arr[j-1] = arr[j]; } i--; // 因为此时i后面的值后移了，i位置上是新的值，所以i要减去1 //这样下一次循环时(i++)，i上的值相当于原先i位置上的下一个 size--; } } return size; } //--------main------------ public static void main(String[] args) { RemoveElement remove = new RemoveElement(); int[] arr = {1,2,3,4,6,6}; int length = remove.removeElement(arr, 2); for (int i = 0; i &lt; length; i++) { System.out.println(arr[i]); } }} 方法二：双指针法 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 代码实现 12345678910111213141516171819202122public class RemoveElement2 { public int removeElement(int[] nums,int val){ int slowIndex = 0; for (int fastIndex = 0; fastIndex &lt; nums.length; fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } public static void main(String[] args) { RemoveElement2 remove = new RemoveElement2(); int[] arr = {0,1,2,3,3,0,4,2}; int length = remove.removeElement(arr, 2); for (int i = 0; i &lt; length; i++) { System.out.println(arr[i]); } }} 3.有序数组的平方 题目 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 思路：双指针法 数组其实是有序的， 只不过负数平方之后可能成为最大数了。 那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。 此时可以考虑双指针法了，i指向起始位置，j指向终止位置。 定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。 如果A[i] * A[i] &lt; A[j] * A[j] 那么result[k--] = A[j] * A[j]; 如果A[i] * A[i] &gt;= A[j] * A[j] 那么result[k--] = A[i] * A[i]; 代码详情 1234567891011121314151617181920212223242526272829303132public class SquareOfSortArray { public int[] sortedSquare(int[] arr){ int[] res = new int[arr.length]; int k = arr.length-1; int left = 0; int right = arr.length-1; while (left &lt;= right){ if (arr[right]*arr[right] &gt; arr[left]*arr[left]){ res[k--] = arr[right]*arr[right]; right--; }else { res[k--] = arr[left]*arr[left]; left++; } } return res; } //--------main------ public static void main(String[] args) { SquareOfSortArray sortArray = new SquareOfSortArray(); int[] arr = {-4,-1,2,3,10}; int[] square = sortArray.sortedSquare(arr); for (int i : square) { System.out.println(i); } }} 参考：代码随想录 4.长度最小的子数组题目链接 题目 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 示例： 输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 方法一：暴力解法 代码详情 这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2) 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 长度最小的子数组 */public class MinSubArrayLen { /** 暴力求解，利用两个for循环 * * @param nums 输入的数组 * @param s 要求子数组的和 &gt;= s * @return 返回子数组的长度 */ public int minSubArrayLen(int[] nums,int s){ int result = Integer.MAX_VALUE; // 要返回的子数组的长度 int subLen = 0; // 子数组的长度，中间变量，用于比较各个子数组 int sum = 0; //用于计算子数组的和 for (int i = 0; i &lt; nums.length; i++) { //遍历数组 sum = 0; for (int j = i; j &lt; nums.length ; j++) { //j从i的位置往后累加 sum += nums[j]; if(sum &gt;= s){ subLen = j-i+1; //当累加结果sum大于等于s时，保留此时的子数组长度 result = subLen &lt; result ? subLen : result; //更新result的值 break; //跳出循环，进行下一轮 } } } return result == Integer.MAX_VALUE ? 0 : result; //如果result的值不变， // 说明为找到符合条件的子数组，则返回0 } //--------------main--------------- public static void main(String[] args) { MinSubArrayLen subArrayLen = new MinSubArrayLen(); int[] nums = {2,3,1,2,4,3}; int len = subArrayLen.minSubArrayLen(nums, 7); System.out.println(len); }} 方法二：滑动窗口 思路分析 接下来就开始介绍数组操作中另一个重要的方法：滑动窗口。 所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。 这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程： 最后找到 4，3 是最短距离。 其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。 在本题中实现滑动窗口，主要确定如下三点： 窗口内是什么？ 如何移动窗口的起始位置？ 如何移动窗口的结束位置？ 窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。 窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。 窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。 解题的关键在于 窗口的起始位置如何移动，如图所示： 可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。 为什么时间复杂度是O(n): 不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是$O(n)$。 代码实现 12345678910111213141516171819202122232425262728/** 滑动窗口，也可以理解为双指针 * * @param nums 输入的数组 * @param s 要求子数组的和 &gt;= s * @return 返回子数组的长度 */ public int minSubArrayLengthWindow(int[] nums,int s){ int result = Integer.MAX_VALUE; // 要返回的子数组的长度 int subLen = 0; // 子数组的长度，中间变量，用于比较各个子数组 int sum = 0; //用于计算子数组的和 int i = 0; //滑动窗口的起始位置 for (int j = 0; j &lt; nums.length; j++) { //j表示滑动窗口的终止位置 sum += nums[j]; //sum滑动窗口内保存的值 //滑动窗口的精髓 while(sum &gt;= s){ //当滑动窗口内的值大于等于s时，滑动窗口的起始位置移动 subLen = j-i+1; result = result &lt; subLen ? result : subLen; //更新result的值 sum = sum - nums[i++]; //滑动窗口内的值减去nums[i],同时，滑动窗口的起始位置右移 } } return result == Integer.MAX_VALUE ? 0 : result; //如果result的值不变， // 说明为找到符合条件的子数组，则返回0 } 转载自：代码随想录，向大佬表示感谢。 5.螺旋矩阵 题目 题目地址：https://leetcode-cn.com/problems/spiral-matrix-ii/ 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例: 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 思路分析 求解本题依然是要坚持循环不变量原则。 模拟顺时针画矩阵的过程: 填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 由外向内一圈一圈这么画下去。 这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开又闭的原则，这样这一圈才能按照统一的规则画下来。 那么我按照左闭右开的原则，来画一圈，大家看一下： 这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。 这也是坚持了每条边左闭右开的原则。 一些同学做这道题目之所以一直写不好，代码越写越乱。 就是因为在画每一条边的时候，一会左开又闭，一会左闭右闭，一会又来左闭右开，岂能不乱。 代码详情 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SpiralMatrix { public static int[][] generateMatrix(int n) { int[][] res = new int[n][n]; // 定义一个二维数组 int startx = 0, starty = 0; // 定义每循环一个圈的起始位置 int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理 int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2) int count = 1; // 用来给矩阵中每一个空格赋值 int offset = 1; // 每一圈循环，需要控制每一条边遍历的长度 int i,j; while ( loop &gt; 0 ) { i = startx; j = starty; // 下面开始的四个for就是模拟转了一圈 // 模拟填充上行从左到右(左闭右开) for (j = starty; j &lt; starty + n - offset; j++) { res[i][j] = count++; } // 模拟填充右列从上到下(左闭右开) for (i = startx; i &lt; startx + n - offset; i++) { res[i][j] = count++; } // 模拟填充下行从右到左(左闭右开) for (; j &gt; starty; j--) { res[i][j] = count++; } // 模拟填充左列从下到上(左闭右开) for (; i &gt; startx; i--) { res[i][j] = count++; } loop--; // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1) startx++; starty++; // offset 控制每一圈里每一条边遍历的长度 offset += 2; } // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值 if (n % 2 == 1) { res[mid][mid] = count; } return res; } //---------------main------------- public static void main(String[] args) { int[][] ints = generateMatrix(5); for (int[] anInt : ints) { for (int i : anInt) { System.out.print(i+\"\\t\"); } System.out.println(\" \"); } }} 转载自：代码随想录，向大佬表示感谢。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://www.colorfo.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指offer题解之链表","slug":"剑指offer题解之链表","date":"2021-08-10T04:35:34.000Z","updated":"2021-08-13T05:05:25.624Z","comments":true,"path":"posts/ae99.html","link":"","permalink":"https://www.colorfo.top/posts/ae99.html","excerpt":"","text":"1.返回链表中倒数最后k个结点牛客网-JZ14 题目：输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。 如果该链表长度小于k，请返回一个长度为 0 的链表。 思路分析 设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K +1个节点处，该位置就是倒数第 K 个节点。 代码实现 123456789101112131415161718//Node节点类public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 返回链表中倒数最后k个结点 * * 注意：此题中链表的头节点即为第一个有效的节点 */public class FindKthToTail { public void add(Node head,Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list(Node head) { if (head == null){ System.out.println(\"链表为空！！！\"); return; } Node cur = head; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } /**输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。 * 如果该链表长度小于k，请返回一个长度为 0 的链表。 * * @param head 输入链表的头节点 * @param k 倒数第k个 * @return 倒数第k个结点至尾节点的全部节点 的 头节点 */ public Node findKthToTail(Node head,int k){ if (head == null){ return null; } Node p1 = head; Node p2 = head; while (p1 != null &amp;&amp; k &gt; 0){ p1 = p1.next; k--; } if (k &gt; 0){ return null; } while (p1 != null){ p1 = p1.next; p2 = p2.next; } return p2; } //---------------main----------------- public static void main(String[] args) { FindKthToTail list = new FindKthToTail(); Node head = new Node(1); list.add(head,new Node(2)); list.add(head,new Node(3)); list.add(head,new Node(4)); list.add(head,new Node(5)); list.list(head); System.out.println(\"--------findKthToTail---------\"); Node newHead = list.findKthToTail(head, 3); list.list(newHead); }} 2.两个链表的第一个公共结点牛客网-JZ36 题目：输入两个无环的单链表，找出它们的第一个公共结点。 解题思路 设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。 当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。 核心代码 12345678public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) { ListNode l1 = pHead1, l2 = pHead2; while (l1 != l2) { l1 = (l1 == null) ? pHead2 : l1.next; l2 = (l2 == null) ? pHead1 : l2.next; } return l1;} 本题转载自：CyC2018 3.环形链表II 题目 https://leetcode-cn.com/problems/linked-list-cycle-ii/ 题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 思路分析 代码详情 123456789101112131415161718192021public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) {// 有环 ListNode index1 = fast; ListNode index2 = head; // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口 while (index1 != index2) { index1 = index1.next; index2 = index2.next; } return index1; } } return null; }} 转载自：代码随想录","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.colorfo.top/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"链表刷题日记","slug":"链表刷题日记","date":"2021-08-08T08:27:43.000Z","updated":"2021-08-09T14:06:39.161Z","comments":true,"path":"posts/3568.html","link":"","permalink":"https://www.colorfo.top/posts/3568.html","excerpt":"","text":"1.在单链表中删除倒数第K个节点 题目 给定一个单链表，要求删除倒数第K个节点，并返回该节点 解答 代码详情 Node节点类 123456789101112131415161718public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 单链表类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class SingleLinkedList { private Node head = new Node(-1); public void add(Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list() { if (head.next == null) { System.out.println(\"链表为空！！！\"); return; } Node cur = head.next; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } /**在单链表中删除倒数第k个节点 * * @param lastKth 倒数第k个 * @return 删除的倒数第k个节点 */ public Node removeLastKthNode(int lastKth){ Node cur = head; if (head.next == null || lastKth &lt; 1){ System.out.println(\"链表为空或者参数输入有误！！！\"); return cur; } //遍历链表，每移动一次，lathKth的值就减去1 while (cur.next != null){ cur = cur.next; lastKth--; } Node res = null; if (lastKth &gt; 0){ //lastKth的值大于链表的长度，直接返回 return cur; }else if(lastKth == 0){ // 此时，lastKth就是第一个节点 this.head = this.head.next; return this.head; }else { //如果lastKth &lt; 0 cur = this.head; while (lastKth != 0){ cur = cur.next; lastKth++; } res = cur.next; //将要删除的节点赋值给res,用来返回 cur.next = cur.next.next; } return res; } //------------------------------main----------------- public static void main(String[] args) { SingleLinkedList linkedList = new SingleLinkedList(); linkedList.add(new Node(1)); linkedList.add(new Node(2)); linkedList.add(new Node(3)); linkedList.add(new Node(4)); linkedList.add(new Node(5)); Node node = linkedList.removeLastKthNode(3); linkedList.list(); System.out.println(\"-------------\"); System.out.println(node); }} 2.单链表的反转 题目 给定一个单链表，实现单链表的反转 思路分析 代码实现 Node节点类 12345678910111213141516171819public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 反转链表类ReverseList 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ReverseList { private Node head = new Node(-1); public void add(Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list() { if (head.next == null) { System.out.println(\"链表为空！！！\"); return; } Node cur = head.next; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } /** * 反转单链表的方法 */ public void reverseList(){ if(head.next == null || head.next.next == null ){ System.out.println(\"不用反转该链表\"); return; } Node cur = head.next; Node next = null; Node newHead = new Node(-2); while(cur != null){ //遍历链表，cur为遍历到的当前节点 next = cur.next; //next 指向当前节点[cur]的下一个节点 cur.next = newHead.next; //当前节点[cur]的next域指向新的头节点的下一个节点 newHead.next = cur; //newHead的next域指向当前节点[cur] cur = next; //cur后移一位 } head.next = newHead.next; } //--------------main-------------------- public static void main(String[] args) { ReverseList reverseList = new ReverseList(); reverseList.add(new Node(1)); reverseList.add(new Node(3)); reverseList.add(new Node(2)); reverseList.add(new Node(4)); reverseList.list(); System.out.println(\"---反转后的链表---\"); reverseList.reverseList(); reverseList.list(); }} 3.判断一个链表是否为回文结构 题目 给定一个链表，请判断该链表是否为回文结构 例如： 1-&gt;2-&gt;1,返回true 1-&gt;2-&gt;2-&gt;1,返回true 1-&gt;2-&gt;3,返回false 思路分析 1.遍历链表，将链表的节点依次压入一个栈中 2.依次弹出栈中的节点，与链表中的节点作比较，如果每次比较的节点的值都相等，则为回文结构 代码实现 1234567891011121314151617//Node节点类public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 判断链表是否是回文结构 */public class IsPalindrome { private Node head = new Node(-1); public void add(Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public boolean isPalindrome(){ if (head.next == null){ System.out.println(\"链表为空！！！\"); return false; } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node cur = head.next; while (cur != null){ stack.push(cur); cur = cur.next; } cur = head.next; Node popNode = null; boolean flag = true; while (!stack.isEmpty() &amp;&amp; cur != null){ popNode = stack.pop(); if (popNode.val != cur.val){ flag = false; } cur = cur.next; } return flag; } //--------------main---------------- public static void main(String[] args) { IsPalindrome palindrome = new IsPalindrome(); palindrome.add(new Node(1)); palindrome.add(new Node(2)); palindrome.add(new Node(2)); palindrome.add(new Node(1)); boolean palindrome1 = palindrome.isPalindrome(); System.out.println(palindrome1); }} 4.删除无序链表中值重复出现的节点 题目(难度一星) 给定一个无序单链表，删除其中值重复出现的节点 例如:1-&gt;2-&gt;2-&gt;4-&gt;5-&gt;4-&gt;null,删除值重复之后的链表为：1-&gt;2-&gt;4-&gt;5-&gt;null 思路分析 1.遍历当前链表，创建Node节点cur指向当前节点，pre指向cur的前一个节点 2.生成一个哈希表，如果cur的值已经存在于哈希表中，就将当前节点删除(pre.next = cur.next) ​ 如果cur的值不存在哈希表中，将其加入到哈希表中，同时令pre = cur(为下一次遍历做准备) 代码实现 123456789101112131415161718public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 删除链表中的重复节点 */public class RemoveRepeat { private Node head = new Node(-1); public void add(Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list() { if (head.next == null) { System.out.println(\"链表为空！！！\"); return; } Node cur = head.next; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } public void removeRepeat(){ if (head.next == null){ System.out.println(\"链表为空！！！\"); return; } Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Node cur = head.next; //cur指向当前节点 Node pre = head; //cur指向当前节点的前一个节点 while (cur != null){ if (set.contains(cur.val)){ //如果哈希表中包含当前节点cur的值，就删除cur节点 pre.next = cur.next; }else { //如果不包含，则将cur节点的值加入到哈希表中 set.add(cur.val); pre = cur; //pre后移一位 } cur = cur.next; } } //-------------------main--------------------- public static void main(String[] args) { RemoveRepeat remove = new RemoveRepeat(); remove.add(new Node(1)); remove.add(new Node(2)); remove.add(new Node(2)); remove.add(new Node(4)); remove.add(new Node(5)); remove.add(new Node(4)); remove.removeRepeat(); remove.list(); }} 5.合并两个有序的单链表 题目(难度一星) 给定两个有序单链表的头节点head1,head2,请合并两个有序链表，合并后的链表依然有序，并返回合并后链表的头节点 例如： 0-&gt;2-&gt;3-&gt;7-&gt;null 1-&gt;3-&gt;5-&gt;7-&gt;9-&gt;null 合并后的链表：0-&gt;1-&gt;2-&gt;3-&gt;3-&gt;5-&gt;7-&gt;7-&gt;9-&gt;null 思路分析 1.当两个链表都不为空时，遍历两个链表，并比较链表中节点值的大小，将较小的节点加入到 新的以newHead为头节点的链表中，如果相等，则依次加入两个相等的节点。 2.若两个链表中其中一个遍历到了末尾，则把另一个链表中的节点加入到新的链表中 代码实现 12345678910111213141516171819//Node节点类public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * 合并两个有序的单链表 */public class MergeLinkedList { public void add(Node head,Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list(Node head) { if (head.next == null){ System.out.println(\"链表为空！！！\"); return; } Node cur = head.next; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } /** * 合并两个单链表 * @param head1 第一个链表的头节点 * @param head2 第二个链表的头节点 * @return 返回新的链表的头节点 */ public Node merge(Node head1,Node head2){ if (head1.next == null &amp;&amp; head2.next == null){ System.out.println(\"两个链表为空！！！\"); return null; } Node newHead = new Node(-1); Node cur = newHead; head1 = head1.next; head2 = head2.next; while (head1 != null &amp;&amp; head2 != null){ if (head1.val &lt; head2.val){ cur.next = head1; cur = cur.next; head1 = head1.next; }else if (head2.val &lt; head1.val){ cur.next = head2; cur = cur.next; head2 = head2.next; }else { cur.next = head1; cur = cur.next; head1 = head1.next; cur.next = head2; cur = cur.next; head2 = head2.next; } } while (head1 != null){ cur.next = head1; cur = cur.next; head1 = head1.next; } while (head2 != null){ cur.next = head2; cur = cur.next; head2 = head2.next; } return newHead; } //----------------main-------------- public static void main(String[] args) { MergeLinkedList merge = new MergeLinkedList(); Node head1 = new Node(-1); Node head2 = new Node(-1); merge.add(head1,new Node(0)); merge.add(head1,new Node(2)); merge.add(head1,new Node(3)); merge.add(head1,new Node(7)); merge.add(head2,new Node(1)); merge.add(head2,new Node(3)); merge.add(head2,new Node(5)); merge.add(head2,new Node(7)); merge.add(head2,new Node(9)); Node merge1 = merge.merge(head1, head2); merge.list(merge1); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.colorfo.top/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单向环形链表之约瑟夫环","slug":"单向环形链表之约瑟夫环","date":"2021-08-07T08:38:52.000Z","updated":"2021-08-08T14:30:13.745Z","comments":true,"path":"posts/d2de.html","link":"","permalink":"https://www.colorfo.top/posts/d2de.html","excerpt":"","text":"Josephus问题: 约瑟夫问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 例如： n = 5 , 即有5个人 k = 1, 从第一个人开始报数 m = 2, 数2下 出圈的顺序 2-&gt;4-&gt;1-&gt;5-&gt;3 思路图解 构建单向环形链表 节点出圈的思路图解 代码详情 Node节点类 123456789101112131415//小孩节点类public class Boy { int no; Boy next; public Boy(int no) { this.no = no; } public Boy() { }} 下面是单向环形链表类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//单向环形链表-约瑟夫环public class SingleCircle { private Boy first; /** * 将小孩加入约瑟夫环的方法 * @param num 表示环中结点的个数 */ public void add(int num){ first = null; Boy curBoy = null; //辅助变量，用来帮助小孩进圈 for (int i = 1; i &lt;= num; i++) { Boy boy = new Boy(i); //当加入第一个小孩时，让其自己成环 if (i == 1){ first = boy; //first始终指向第一个小孩 first.next = first; curBoy = first; } //新的小孩结点的进圈操作 curBoy.next = boy; curBoy = curBoy.next; curBoy.next = first; } } //遍历圈中的小孩结点 public void list(){ if (first == null){ System.out.println(\"圈中没有小孩结点\"); return; } Boy cur = first; while (true){ System.out.printf(\"当前的小孩编号:%d \\n\",cur.no); if (cur.next == first){ break; } cur = cur.next; } } /** * 小孩出圈的方法 * @param startNo 从第几个小孩开始数 * @param count 数几次 * @param num 圈中小孩的个数 */ public void remove(int startNo,int count,int num){ if (first == null || startNo &lt; 1 || startNo &gt; num){ System.out.println(\"参数输入有误！！！\"); return; } Boy helper = first;//创建一个辅助指针，让其始终位于first指针的前一个 //先让first移动到startNo处，即开始报数的位置 for (int i = 1; i &lt;= startNo-1; i++) { first = first.next; } //再让helper 移动到first的前一位 while (helper.next != first){ helper = helper.next; } while (helper != first){ //开始报数，让helper和first移动到指定位置 for (int i = 1; i &lt;= count-1; i++) { helper = helper.next; first = first.next; } //此时first指向要移除的小孩结点 System.out.printf(\"出圈小孩的编号：%d \\n\",first.no); first = first.next; helper.next = first; } System.out.printf(\"最后出圈小孩的编号：%d \\n\",first.no); } //***************写个main方法测试一下******************* public static void main(String[] args) { SingleCircle singleCircle = new SingleCircle(); singleCircle.add(5); singleCircle.remove(1,2,5); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"约瑟夫环","slug":"约瑟夫环","permalink":"https://www.colorfo.top/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"}]},{"title":"单链表的增删改查和插入","slug":"单链表的增删改查和插入","date":"2021-08-05T07:07:50.000Z","updated":"2021-08-05T07:13:27.881Z","comments":true,"path":"posts/64b9.html","link":"","permalink":"https://www.colorfo.top/posts/64b9.html","excerpt":"","text":"本篇博文属于单链表的入门案例，包含单链表的一些基础操作:增删改查、插入 1.首先创建一个Node结点类 1234567891011121314151617181920212223public class Node { Integer id; String name; Node next; public Node() { } public Node(Integer id, String name) { this.id = id; this.name = name; } @Override public String toString() { return \"Node{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; }} 2.然后创建一个单链表类(包含了单链表的增删改查等方法) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public class SingleList { //头结点 private Node head = new Node(); //为当前单向链表添加一个结点 public void add(Node node){ //定义一个临时结点指向头结点 Node temp = head; //一直遍历链表，直到temp.next == null while (temp.next != null){ temp = temp.next; } //temp.next == null,说明找到了链表的尾部，将node加入链表中 temp.next = node; } //按照id修改链表的name public void update(Node node){ if (head.next == null){ return; } Node temp = head.next; while (temp != null){ if (temp.id == node.id){ temp.name = node.name; break; } temp = temp.next; } } //根据id删除节点 public void delete(int id){ if (head.next == null){ return; } Node temp = head; while (temp.next != null){ if (temp.next.id == id){ temp.next = temp.next.next; break; } temp = temp.next; } } //遍历链表 public void list(){ if (head.next == null){ return; } Node temp = head.next; while (temp != null){ System.out.println(temp); temp = temp.next; } } /** * 按照id编号的大小顺序插入，从小到大 * @param node */ public void insertById(Node node){ Node temp = head; boolean flag = false; while (true){ //如果temp结点的下一个为空，直接跳出循环,从这里跳出循环flag=false; if(temp.next == null){ break; } //程序走到这里，说明，temp.next != null if (node.id == temp.next.id){ flag = true; //从这里跳出循环flag = true break; }else if(node.id &lt; temp.next.id){ break; //从这里跳出循环flag = false; } //这里不用写出node.id &gt; temp.next.id的情况， //因为这种情况会一直遍历到链表的末尾，满足temp.next == null条件后，跳出循环，最后在链表末尾加上node temp = temp.next; //temp 向后移动一位，用来遍历单链表 } if (flag){ System.out.println(\"编号已经存在\"); }else { //在此处执行结点的插入操作(适用于在head结点后加结点(即temp.next == null)，以及node.id 小于 temp.next.id的情况) node.next = temp.next; temp.next = node; } } public static void main(String[] args) { SingleList list = new SingleList(); /*list.add(new Node(1,\"张三\")); list.add(new Node(2,\"lisi\")); list.update(new Node(2,\"李四\")); list.add(new Node(3,\"王五\")); list.add(new Node(4,\"赵六\")); list.delete(1); list.delete(4); list.list();*/ //*****************上面是增删改查的测试************ //*****************下面是按顺序插入的测试************ list.insertById(new Node(3,\"王3\")); list.insertById(new Node(2,\"王2\")); list.insertById(new Node(1,\"王1\")); list.insertById(new Node(5,\"王5\")); list.insertById(new Node(4,\"王4\")); list.insertById(new Node(6,\"王6\")); list.list(); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"https://www.colorfo.top/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"}]},{"title":"栈和队列刷题笔记","slug":"栈和队列刷题笔记","date":"2021-08-04T07:36:20.000Z","updated":"2021-08-16T11:28:53.485Z","comments":true,"path":"posts/f354.html","link":"","permalink":"https://www.colorfo.top/posts/f354.html","excerpt":"","text":"1.用一个栈实现另一个栈的排序 题目： ​ 一个栈中的类型为整型，现在想将该栈从顶到底按照从大到小的顺序排序，只允许申请一个栈，除此之外，可以申请新的变量，如何排序？ 思路分析： ​ 将要排序的栈记为stack,申请的辅助栈记为help，在stack上执行pop操作，弹出的元素记为cur 如果cur小于或等于help的栈顶元素，直接将cur压入help 如果cur大于help的栈顶元素，则将help中的元素逐次弹出，然后压入stack中，直到cur小于或等于help的栈顶元素，再将cur压入help栈中； 如果在help栈的弹栈过程中，help已经空了，则说明cur是当前的最大元素，则直接将cur压入help中 最后，help中的数，从栈顶到栈底为从小到大的顺序，将help中的数依次弹出压入stack中，则stack从栈顶到栈底为从大到小的顺序 难度：一星 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 用一个栈实现另一个栈的排序 */public class SortStackByStack { public static Stack sortStack(Stack&lt;Integer&gt; stack){ Stack&lt;Integer&gt; help = new Stack&lt;&gt;(); while (!stack.isEmpty()){ int cur = stack.pop(); while(!help.isEmpty() &amp;&amp; cur &gt; help.peek()){ stack.push(help.pop()); } help.push(cur); } while (!help.isEmpty()){ stack.push(help.pop()); } return stack; } public static void main(String[] args) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(2); stack.push(1); stack.push(8); stack.push(7); stack.push(3); stack.push(4); stack.push(4); stack = sortStack(stack); int size = stack.size(); for (int i = 0; i &lt; size; i++) { System.out.println(stack.pop()); } }} 2.数组中元素与下一个比它大的元素之间的距离力扣（Medium） 12Input: [73, 74, 75, 71, 69, 72, 76, 73]Output: [1, 1, 4, 2, 1, 1, 0, 0] 说明：对于此题，提供两种解法，详情见下面代码 方法一：暴力求解,时间复杂度O(N^2) 12345678910111213141516171819202122232425262728293031323334/** * 时间复杂度为O(N^2),每个位置向右遍历一下即可 */public class DailyTemperature2 { public static int[] rightWay(int arr[]){ int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) { int cur = i+1; int rightMoreIndex = 0; while (cur &lt; arr.length){ if (arr[cur] &gt; arr[i]){ res[i] = cur - i; break; } cur++; } } return res; } //写个main方法测试一下 public static void main(String[] args) { int[] arr = {73,74,75,71,69,72,76,73}; int[] res = rightWay(arr); for (int re : res) { System.out.println(re); } }} 方法二：遍历数组时，使用栈把数组的下标存起来,时间复杂度O(N) 思路分析： 123456789/** * 1.用dist数组存放距离当前位置的距离，用stack存放原始数组temperature的下标 * 2.用cur指向temperature数组的下标，pre指向stack栈的栈顶元素 * * 3.如果stack不为空，并且当前遍历的数temperature[cur] 大于 栈顶对应的数temperature[stack.peek()]， * 就将stack的栈顶元素弹出，存到pre变量中，cur - pre即为与pre的距离dist[pre].之后再将cur压入stack中。 * 4.如果stack为空，直接将cur压入stack中。 * */ 1234567891011121314151617181920212223242526272829public class DailyTemperatures { public static void main(String[] args) { int[] temperature = {73, 74, 75, 71, 69, 72, 76, 73}; int[] dist = dailyTemperatures(temperature); for (int i : dist) { System.out.print(i+\" \"); } } public static int[] dailyTemperatures(int[] temperatures) { int[] dist = new int[temperatures.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int cur = 0; cur &lt; temperatures.length; cur++) { int pre = 0; while (!stack.isEmpty() &amp;&amp; temperatures[cur] &gt; temperatures[stack.peek()]){ pre = stack.pop(); dist[pre] = cur - pre; } stack.push(cur); } return dist; }} 3.返回数组的最近邻位置（利用单调栈） 题目： 给定一个不含重复值的数组arr,找到每一个位置i左边和右边离i位置最近且值比arr[i]小的位置，返回左右位置的相应信息 举例： 123456789101112intput: arr = {3,4,1,5,6,2,7}output: { {-1,2}, {0,2}, {-1,-1}, {2,5}, {3,5}, {2,-1}, {5,-1}, } 解答：方法一 本题实现复杂度为O(N^2)的解释非常容易的，每个位置向左和向右遍历一下，总可以确定，见以下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MonotoneStack { public static int[][] rightWay(int[] arr){ int[][] res = new int[arr.length][2]; for (int i = 0; i &lt; arr.length; i++) { int leftLessIndex = -1; int rightLessIndex = -1; int cur = i-1; while (cur &gt;= 0){ if (arr[cur] &lt; arr[i]){ leftLessIndex = cur; break; } cur--; } cur = i+1; while (cur &lt; arr.length){ if (arr[cur] &lt; arr[i]){ rightLessIndex = cur; break; } cur++; } res[i][0] = leftLessIndex; res[i][1] = rightLessIndex; } return res; } public static void printArr2(int[][] arr){ for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[0].length; j++) { System.out.print(arr[i][j]+\" \"); } System.out.println(\"\"); } } public static void main(String[] args) { int[] arr = {3,4,1,5,6,2,7}; int[][] res = rightWay(arr); printArr2(res); }} 方法二：利用单调栈结构，时间复杂度为O(N) 思路分析： 12345678910111213141516171819202122232425/** * 单调栈——返回最近邻的位置 * * 准备一个栈，记为Stack&lt;integer&gt;,栈中存放的元素是数组的位置，开始stack为空，如果找到每一个位置i左边 * 和右边离i位置最近且值比arr[i]小的位置，那么需要让stack从栈顶到栈底的位置所代表的值是递减的(也就是从大到小)； * 如果找到每一个位置i左边和右边离i位置最近且值比arr[i]大的位置，那么需要让stack从栈顶到栈底的位置所代表的值是递增的。 * 本题需要解决是前者。 * 下面举例展示单调栈的使用和求解流程，以arr = {3,4,1,5,6,2,7}为例。 * 1.初始时，arr = {3,4,1,5,6,2,7},stack为空。 * 2.遍历arr数组，遍历到arr[0] = 3时，stack为空，直接将0压入stack中，此时，stack中从栈顶到栈底为{0(值为3)} * 3.遍历到arr[1]=4时，`arr[1] &gt; arr[stack.peek()]`，将1压入到stack中，此时，stack从栈顶到栈底为 * {1(值为4)，0(值为3)} * 4.遍历到arr[2] = 1时，如果将下标2压入stack中，会破坏stack从栈顶到栈底所代表的的值是递减的规律， * 那么，此时将stack的栈顶元素\"1\"弹出，位置1左边比它代表的值小的下标即为此时stack栈的栈顶元素\"0\"， * 位置1右边比它代表的值小的下标，即为当前遍历的下标\"2\"，那么res[1] = {0,2}。此时，stack从栈顶到栈底为{0(值为3)}， * 如果将下标2压入stack中，依旧会破坏stack从栈顶到栈底的元素所代表的值是递减的规律，此时将stack的栈顶元素\"0\"弹出，stack栈已经空了， * 位置0左边不存在比它小的数，默认取-1，位置0右边比它代表的值小的下标，即为当前遍历的下标\"2\"，那么res[0] = {-1,2}。 * 这时，stack为空，将\"2\"压入stack中，stack从栈顶到栈底的元素为{2(值为1)} * 5.按照此规律继续遍历下去...... * 6.遍历阶段结束后，stack从栈顶到栈底的元素为{6(值为7),5(值为2),2(值为1)}。 * 下面清算stack中剩下的元素，将stack的栈顶元素\"6\"弹出，栈中它的下面位置是5，而由于6位置是清算阶段弹出的，所以res[6] = {5,-1}; * 弹出5位置，栈中它的下面位置是2,5位置是清算阶段弹出的，所以res[5] = {2,-1}; * 弹出2位置，栈中它的下面没有位置了,2位置是清算阶段弹出的，所以res[2] = {-1,-1}; * */ 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 单调栈——返回最近邻的位置 */public class MonotoneStack2 { public static int[][] getNearLessNoRepeat(int[] arr){ int[][] res = new int[arr.length][2]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); //遍历阶段 for (int i = 0; i &lt; arr.length; i++) { while (!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[stack.peek()]){ int popIndex = stack.pop(); int leftLessIndex = stack.isEmpty() ? -1 : stack.peek(); res[popIndex][0] = leftLessIndex; res[popIndex][1] = i; } stack.push(i); } //开始清算阶段 while(!stack.isEmpty()){ int popIndex = stack.pop(); int leftLessIndex = stack.isEmpty() ? -1 : stack.peek(); res[popIndex][0] = leftLessIndex; res[popIndex][1] = -1; } return res; } public static void printArr2(int[][] arr){ for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[0].length; j++) { System.out.print(arr[i][j]+\" \"); } System.out.println(\"\"); } } public static void main(String[] args) { int[] arr = {3,4,1,5,6,2,7}; int[][] res = getNearLessNoRepeat(arr); printArr2(res); }} 4.滑动窗口最大值LeetCode题目链接 题目 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 思路分析 参考：程序员代码面试指南第2版（18-20），左程云著 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.Arrays;import java.util.LinkedList;/** * 获取滑动窗口的最大值，使用双端队列 */public class MaxWindow { public int[] getMaxWindow(int[] arr,int w){ int[] res = new int[arr.length-w+1]; // res数组用来放每个滑动窗口的最大值 LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;&gt;(); //qmax 可以理解为一个双向的队列结构，用来放arr的下标 //qmax从队列头到队列尾应该是单调递减的 //qmax的队列头始终保存当前滑动窗口的最大值 int index = 0; //res数组的下标 for (int i = 0; i &lt; arr.length; i++) { //当双向递减队列不为空，并且当前的arr[i] 大于等于 arr[队列尾部(下标)] //就将队列尾部元素弹出 while (!qmax.isEmpty() &amp;&amp; arr[i] &gt;= arr[qmax.peekLast()]){ qmax.pollLast(); } //程序走到此处，说明队列为空，或者，arr[i] &lt; arr[qmax.peekLast()] //此时将下标i加到队列尾部 qmax.addLast(i); if (qmax.peekFirst() == i-w){ //说明qmax的队列头已经过期了，或者说滑动窗口已经滑动到下一个位置了，必须更新队列头 qmax.pollFirst(); } if (i &gt;= w-1){ //当i==2,到达第一个滑动窗口，更新res[] res[index++] = arr[qmax.peekFirst()]; } } return res; } //------------main----------- public static void main(String[] args) { MaxWindow window = new MaxWindow(); int[] arr = {4,3,5,4,3,3,6,7}; int[] maxWindow = window.getMaxWindow(arr, 3); System.out.println(Arrays.toString(maxWindow)); }} 5.前 K 个高频元素LeetCode题目链接 题目 12345678910111213141516给定一个非空的整数数组，返回其中出现频率前 k 高的元素。示例 1:输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]示例 2:输入: nums = [1], k = 1输出: [1]提示：你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。你可以按任意顺序返回答案。 思路分析 题目最终需要返回的是前 k 个频率最大的元素，可以想到借助堆这种数据结构，对于 k 频率之后的元素不用再去处理， 进一步优化时间复杂度。 具体操作为： 借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率维护一个元素数目为 k 的最小堆每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中最终，堆中的 k个元素即为前 k 个高频元素 参考：程序员吴师兄 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;public class TopKFrequent { public int[] topK(int[] nums,int k){ HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) { if (map.containsKey(num)){ //如果包含num map.put(num,map.get(num)+1); //将value的值+1 }else { map.put(num,1); } } //上面循环结束，统计到了每个num出现的次数，key=num,value=frequency // 遍历map，用最小堆保存出现频率最大的前k个元素 PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return map.get(o1)-map.get(o2); } }); Set&lt;Integer&gt; keySet = map.keySet(); for (Integer key : keySet) { if (priorityQueue.size() &lt; k){ priorityQueue.add(key); }else if (map.get(key) &gt; map.get(priorityQueue.peek())){ priorityQueue.remove(); priorityQueue.add(key); } } int[] res = new int[k]; int index = res.length-1; while (!priorityQueue.isEmpty()){ res[index--] = priorityQueue.remove(); } return res; } //-----------main--------- public static void main(String[] args) { TopKFrequent topK = new TopKFrequent(); int[] nums = {1,1,1,2,2,3}; int[] res = topK.topK(nums,2); System.out.println(Arrays.toString(res)); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"}]},{"title":"Leetcode题解-栈和队列","slug":"Leetcode题解-栈和队列","date":"2021-08-02T07:38:51.000Z","updated":"2021-08-16T08:28:27.508Z","comments":true,"path":"posts/b04a.html","link":"","permalink":"https://www.colorfo.top/posts/b04a.html","excerpt":"","text":"1.用栈实现队列栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class StackForQueue { //首先准备两个栈 private Stack&lt;Integer&gt; in = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; out = new Stack&lt;&gt;(); //首先将元素压入第一个栈 public void push(Integer val){ in.push(val); } //将入栈的数据弹出，压入出栈中 //在这个过程中，必须保证出栈为空 public void in2out(){ if (out.isEmpty()){ //如果出栈为空，才操作 while(!in.isEmpty()){ out.push(in.pop()); } } } //相当于一个出队列的操作 public int pop(){ //先将 入栈 中的数据 压入到出栈中，这样，经过栈的两次“先进后出”，就实现了队列的“先进先出” in2out(); return out.pop(); } //查看当前的队列的头 public int peek(){ in2out(); return out.peek(); } //判断队列是否为空 public boolean isEmpty(){ return in.isEmpty() &amp;&amp; out.isEmpty(); } //编写一个main方法测试一下结果 *********************************************** public static void main(String[] args) { StackForQueue queue = new StackForQueue(); for (int i = 1; i &lt;= 8; i++) { queue.push(i); } for (int i = 0; i &lt; 8; i++) { System.out.println(queue.pop()); } }} 2.用队列实现栈在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 在队列这种数据结构中，最先插入的元素将是最先被删除的元素； * 反之最后插入的元素将是最后被删除的元素，因此队列又称为“先进先出”（FIFO—first in first out）的线性表。 * * Queue用法小结： * Queue使用时要尽量避免Collection的add()和remove()方法， * 而是要使用offer()来加入元素，使用poll()来获取并移出元素。 * 它们的优点是通过返回值可以判断成功与否。 * 而add()和remove()方法在失败的时候会抛出异常。 * 如果要使用前端而不移出该元素，使用element()或者peek()方法。 */public class QueueForStack { private Queue&lt;Integer&gt; queue; public QueueForStack(){ //LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用 queue = new LinkedList&lt;&gt;(); } public void push(int val){ //首先将val加入到队列中，此时，val位于队列的最后一位 queue.offer(val); //获取队列的大小 int count = queue.size(); while (count &gt; 1){ //将当前队列的除val之外的所有元素，先取出队列，再放入队列 //此时，val就位于队列的首位，那么，就实现了栈的“后进先出” queue.offer(queue.poll()); count--; } } public int pop(){ return queue.poll(); } public int peek(){ //查看当前的队列头 return queue.peek(); } public boolean isEmpty(){ return queue.isEmpty(); } //编写一个main方法，测试一下 ***************************************** public static void main(String[] args) { QueueForStack queue = new QueueForStack(); for (int i = 1; i &lt;= 8; i++) { queue.push(i); } for (int i = 0; i &lt; 8; i++) { System.out.println(queue.pop()); } }} 3.最小值栈：设计一个有getMin功能的栈 题目：实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作 要求： 1.pop,push,getMin操作的时间复杂度都是O(1) 设计的栈类型可以使用现成的栈结构 思路分析：在设计时，使用两个栈，一个栈用来保存所有的元素，其功能和一个正常的栈没有区别，这个栈记为dataStack. 另一个用来保存每一步的最小值，这个栈的栈针始终指向当前放入栈中元素的最小值，这个栈记为minStack. 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MyMinStack { private Stack&lt;Integer&gt; dataStack; private Stack&lt;Integer&gt; minStack; public MyMinStack(){ dataStack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); } public void push(int data){ dataStack.push(data); //当minStack为空时，放入data if (minStack.isEmpty()){ minStack.push(data); }else { //当minStack不为空时,如果minStack的栈顶元素大于data时， // 将data放入minStack,此时就能保证,minStack的栈顶元素为dataStack的最小值 if(minStack.peek() &gt; data){ minStack.push(data); } } } public int pop(){ if (dataStack.isEmpty()){ throw new RuntimeException(\"Your Stack is empty!!!\"); } return dataStack.pop(); } public int getMin(){ if (minStack.isEmpty()){ throw new RuntimeException(\"Your Stack is empty!\"); } return minStack.peek(); } public boolean isEmpty(){ return dataStack.isEmpty(); } //编写一个main测试一下****************************************** public static void main(String[] args) { MyMinStack stack = new MyMinStack(); stack.push(1); stack.push(3); stack.push(5); stack.push(2); stack.push(2); stack.push(4); stack.push(1); stack.push(8); stack.push(2); System.out.println(stack.getMin()); //1 }} ​ 对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。 4. 用栈实现括号的匹配（Easy）力扣 12345678910case1:Input:\"()[]{}\"Output : true case2:Input:\"({})\"Output : true 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 用栈实现括号的匹配 * * Input:\"()[]{}\" * * Output : true */public class ValidParentheses { private Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); public boolean isValid(String s){ for (char c : s.toCharArray()){ if (c == '(' || c == '{' || c == '['){ //当满足\"左括号\"的条件时，压入栈中 stack.push(c); }else{ //如果此时栈中还为空，则不满足条件 if (stack.isEmpty()){ return false; } //走到这一步，说明栈中不为空，此时\"c\"，满足为括号的右半部分 //此时弹栈拿出括号的坐半部分left char left = stack.pop(); //以下三个条件说明，在弹栈得到的left时,括号右半部分匹配不上，就返回false; boolean b1 = left == '(' &amp;&amp; c != ')'; boolean b2 = left == '{' &amp;&amp; c != '}'; boolean b3 = left == '[' &amp;&amp; c != ']'; if (b1 || b2 || b3){ return false; } } } return stack.isEmpty(); } //测试 ******************************* public static void main(String[] args) { ValidParentheses vp = new ValidParentheses(); System.out.println(vp.isValid(\"()\")); //true System.out.println(vp.isValid(\"()[]{}\")); //true System.out.println(vp.isValid(\"{[]}\")); //true System.out.println(vp.isValid(\"(]\")); //false System.out.println(vp.isValid(\"([)]\")); //false }} 5.逆波兰表达式求值leetcode题目链接 题目 12345678910111213141516171819202122根据 逆波兰表示法，求表达式的值。有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。说明：整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。示例 1：输入: [\"2\", \"1\", \"+\", \"3\", \" * \"]输出: 9解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9示例 2：输入: [\"4\", \"13\", \"5\", \"/\", \"+\"]输出: 6解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6示例 3：输入: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \" * \", \"/\", \" * \", \"17\", \"+\", \"5\", \"+\"]输出: 22 思路分析 遍历String[] tokens ,如果tokens[i] 是数字，则直接压入栈中， 如果是“+”，“-”，“*”，“/”运算符，则从栈中弹出两个数字，然后再把计算结果压入栈中 最后返回栈中的数字，即为最后的运算结果 注意：1.如果是运算符是“-”，“/”,注意计算的顺序 2.String的比较要用equals()方法 3.char类型的比较可以使用“==” 代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 逆波兰表达式求值 */public class EvaluateReversePolishNotation { public int evalRPN(String[] tokens){ Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; tokens.length; i++) { // 遍历tokens数组 if(tokens[i].equals(\"+\") || tokens[i].equals(\"-\") || tokens[i].equals(\"*\") || tokens[i].equals(\"/\")){//如果是加减乘除字符 //如果是操作符，直接弹出两个数字，准备进行运算 int num1 = stack.pop(); int num2 = stack.pop(); if (tokens[i].equals(\"+\")){ stack.push(num1+num2); }else if (tokens[i].equals(\"-\")){ stack.push(num2-num1); }else if (tokens[i].equals(\"*\")){ stack.push(num1*num2); }else{ stack.push(num2 / num1); } }else{ //如果是数字的话，直接压入 stack.push(stoi(tokens[i])); } } return stack.pop(); } private Integer stoi(String token) { // 将String转为Integer return Integer.valueOf(token); } //--------------main----------- public static void main(String[] args) { EvaluateReversePolishNotation RPN = new EvaluateReversePolishNotation(); /** * 该算式转化为常见的中缀算术表达式为： * ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 * = ((10 * (6 / (12 * -11))) + 17) + 5 * = ((10 * (6 / -132)) + 17) + 5 * = ((10 * 0) + 17) + 5 * = (0 + 17) + 5 * = 17 + 5 * = 22 */ int i = RPN.evalRPN(new String[]{\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"}); System.out.println(i); //转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 int i1 = RPN.evalRPN(new String[]{\"4\", \"13\", \"5\", \"/\", \"+\"}); System.out.println(i1); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://www.colorfo.top/tags/%E9%98%9F%E5%88%97/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.colorfo.top/tags/LeetCode/"}]},{"title":"利用数组实现栈","slug":"利用数组实现栈","date":"2021-08-01T13:20:26.000Z","updated":"2021-08-01T14:51:43.284Z","comments":true,"path":"posts/c93a.html","link":"","permalink":"https://www.colorfo.top/posts/c93a.html","excerpt":"","text":"本例子利用数组实现”栈”这种数据结构，算一个栈的入门案例 栈的特点：先进后出，后进先出 在实现栈的弹栈，压栈的操作之前，要判断栈是否为空栈或满栈 数组的长度即为栈的容量 写一个ArrayForStack类，在这个类中，实现栈的弹栈、压栈等方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ArrayForStack { private int maxSize; private int[] array; //栈针 private int top = -1; public ArrayForStack(){ } //有参构造方法，利用构造方法给属性赋值 public ArrayForStack(int maxSize){ this.maxSize = maxSize; this.array = new int[maxSize]; } public boolean isEmpty(){ return top == -1; } public boolean isFull(){ return top == maxSize-1; } public void push(int num) throws Exception { if (isFull()){ throw new Exception(\"栈已经满了，不能继续压栈了\"); } array[++top] = num; } public int pop() throws Exception { if (isEmpty()){ throw new Exception(\"栈已经空了，不能弹栈\"); } int temp; temp = array[top--]; return temp; }} 编写一个测试类，测试栈的方法 12345678910111213141516171819public class StackTest { public static void main(String[] args) throws Exception { //栈的容量 int maxSize = 6; ArrayForStack stack = new ArrayForStack(maxSize); //压栈 for (int i = 0; i &lt; maxSize; i++) { stack.push(i); //依次压入0 1 2 3 4 5 } //弹栈 for (int i = 0; i &lt; maxSize; i++) { System.out.println(stack.pop()); //依次弹出5 4 3 2 1 0 } }} 接下来利用上面编写的ArrayForStack类，再实现一个回文字符串判断的例子 所谓的回文字符串即为：从左往右 与 从右往左 读这个字符串，结果是一样的 比如：”aba”就是一个回文串，而:”hello”,从右往左为”olleh”,则”hello”不是一个回文串 1234567891011121314151617181920212223242526272829303132public class TestPalindrome { public static void main(String[] args) throws Exception { System.out.println(detection(\"abcdedcba\")); //true } public static boolean detection(String str) throws Exception { int length = str.length(); ArrayForStack stack = new ArrayForStack(length); for (int i = 0; i &lt; length; i++) { stack.push(str.charAt(i)); } String newStr = \"\"; for (int i = 0; i &lt; length; i++) { if (!stack.isEmpty()){ char s = (char)stack.pop(); newStr += s; } } if (str.equals(newStr)){ return true; } return false; }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"},{"name":"数组","slug":"数组","permalink":"https://www.colorfo.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"回文","slug":"回文","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%96%87/"}]},{"title":"github高效搜索项目","slug":"github高效搜索项目","date":"2021-07-31T08:56:16.000Z","updated":"2021-07-31T09:18:54.323Z","comments":true,"path":"posts/2a1b.html","link":"","permalink":"https://www.colorfo.top/posts/2a1b.html","excerpt":"","text":"利用项目名(仓库名) 例如in:name spring boot 利用项目名+stars in:name spring boot stars:&gt;1000 利用项目名+stars+forks in:name spring boot stars:&gt;1000 forks:&gt;100 利用readme in:readme springboot 利用readme+stars in:readme springboot stars:&gt;1000 利用description in:description 微服务 利用description + language in:description 微服务 language:java 利用description + language+日期 in:description 微服务 language:java pushed:&gt;2019-9-9 点进去查看项目的：描述利用了那些技术，代码结构、最新push日期、火热程度等，查看项目的readme文档 把github用起来，多去github看开源项目","categories":[],"tags":[{"name":"github搜索","slug":"github搜索","permalink":"https://www.colorfo.top/tags/github%E6%90%9C%E7%B4%A2/"}]},{"title":"git和github的使用","slug":"git和github的使用","date":"2021-07-30T08:42:22.000Z","updated":"2021-07-31T06:57:42.597Z","comments":true,"path":"posts/ec43.html","link":"","permalink":"https://www.colorfo.top/posts/ec43.html","excerpt":"","text":"[toc] git1.Git常用命令 2.分支的操作 3.远程仓库操作 4.IDEA集成git、github 1.确保idea已经集成了git和github 2.回到idea主界面，创建一个git repository 3.将代码加入暂存区 代码加入暂存区后，文件名由红色变为蓝色 4.将代码提交至本地库 代码提交至本地库后，文件名由蓝色变为正常的白色 5.查看git的log和master信息 切换version 创建分支 6.合并分支 在hot_fix分支下，加一行代码，并提交至本地库 注意：master分支想要合并hot_fix分支，必须在master分支下merge 已经切换至master 开始合并 成功合并 备注：以上演示的为无冲突合并，如果遇到冲突合并(简单理解为：对代码做了不同的修改)，需要进行手动选择代码，然后合并 7.将代码推送至远程github仓库 7.1 使用ssh免密登陆 进入C:/Users/Administrator/.ssh文件夹，右键选择“Git Bash Here ” 在命令行输入ssh-keygen -t rsa -C 邮箱 ，连续三次回车(其中有一次问你，要不要覆盖文件) 然后输入cat id_rsa.pub ,得到其文件内容，如下图 复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys →New SSH key 新建一个SSH key 7.2新建一个远程github仓库，用来储存来自本地仓库的代码，如下图 方式二，新建github仓库 7.3push代码到github仓库 push代码的重要提示 注意： push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说， 要想 push 成功，一定要保证本地库的版本要比远程库的版本高！ 因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送！ 8 pull 拉取远程库到本地库 首先更新一下github仓库的代码，以示本地和远程的区别 9.克隆代码到本地，并利用idea打开","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.colorfo.top/tags/git/"},{"name":"github","slug":"github","permalink":"https://www.colorfo.top/tags/github/"}]},{"title":"springboot集成mybatis-plus","slug":"springboot集成mybatis-plus","date":"2021-07-28T05:05:31.000Z","updated":"2021-07-28T11:29:26.531Z","comments":true,"path":"posts/667f.html","link":"","permalink":"https://www.colorfo.top/posts/667f.html","excerpt":"","text":"本博客基于springboot-web项目，集成thymeleaf，和mybatis-plus可以实现数据的CRUD和分页显示数据功能 案例一：实现数据的CRUD 依赖及配置 1.新建一个springboot-web项目，并选中thymeleaf模板引擎 2.加入依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 3.配置mysql的账号密码 1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=mysql密码 代码详情 1.控制层代码 1234567891011121314151617181920@Controllerpublic class MybatisController { //自动注入业务层的StudentService @Autowired private StudentService studentService; @RequestMapping(\"/queryAll\") //请求路径 public String queryAll(Model model){ //调用业务层的方法，查询所有学生 List&lt;Student&gt; students = studentService.list(); model.addAttribute(\"students\",students); //将查询结果放入request作用域，并返回到视图层 return \"mybatis-plus\"; }} 2.业务层代码(包括一个接口和实现类) 1234public interface StudentService extends IService&lt;Student&gt; { //IService&lt;T&gt; 中的 T 是实体} IService为mybatis-plus提供的接口，里面提供了CRUD的基本方法,我们的业务层接口需要实现IService这个接口 3.业务接口实现类 12345@Servicepublic class StudentServiceImpl extends ServiceImpl&lt;StudentMapper, Student&gt; implements StudentService { //ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; 中的泛型：M 是 mapper 对象，T 是实体} StudentServiceImpl 继承了ServiceImpl，而ServiceImpl是IService 实现类，它提供了IService中方法的具体实现。我们写的业务接口实现类需要继承ServiceImpl这个类，并且要实现我们自己写的StudentService这个接口 下面给出ServiceImpl类的部分代码 12//IService 实现类（ 泛型：M 是 mapper 对象，T 是实体 ）public class ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; implements IService&lt;T&gt; {} 4.持久层代码 1234@Mapperpublic interface StudentMapper extends BaseMapper&lt;Student&gt; {} StudentMapper继承了 BaseMapper这一接口，当我们编写的Mapper接口 继承该接口后，无需编写 mapper.xml 文件，即可获得CRUD功能 说明：除了在该类的上面添加@Mapper,注明这是一个持久层之外，还可以在程序的主入口添加@MapperScan注解(两个注解选择一个使用即可) 5.实体类 1234567891011121314151617@TableName(\"t_student\")public class Student { @TableField(exist = false) private String email; private Integer id; private String name; private Integer age; setter and getter toString } @TableName(“t_student”)由mybatis-plus提供，作用使该实体类与对应的数据库中的表名对应，例如类Student&lt;===&gt;表t_student @TableField(exist = false)由mybatis-plus提供,作用是标注出，数据库中的表不存在该字段 5.视图层的代码(由控制层转到视图层mybatis-plus.html) 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;查询所有学生&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div &gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"student:${students}\"&gt; &lt;!--thymeleaf循环一个list--&gt; &lt;td&gt;[[${student.id}]]&lt;/td&gt; &lt;!--thymeleaf的行内写法，取出相应的变量--&gt; &lt;td&gt;[[${student.name}]]&lt;/td&gt; &lt;td&gt;[[${student.age}]]&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6查询结果 与数据库中的数据一致 案例二：实现分页数据的展示 数据的分页展示，在案例一的基础上修改而来 分页功能具体实现 1.新建一个配置类，用来加载分页插件 123456789101112@Configuration//@Deprecatedpublic class MyBatisPlusConfig { @Bean public PaginationInterceptor paginationInterceptor() { System.out.println(\"加载分页插件\"); return new PaginationInterceptor(); }} 2.修改控制层代码 12345678910111213141516171819202122232425@Controller@Slf4jpublic class MybatisController { @Autowired private StudentService studentService; @RequestMapping(\"/queryAll\") public String queryAll(@RequestParam(value = \"pn\",defaultValue = \"1\") Integer pn, Model model){ //分页查询，pn表示当前页，6表示每页几条数据 Page&lt;Student&gt; studentPage = new Page&lt;&gt;(pn,6); //分页查询结果 Page&lt;Student&gt; page = studentService.page(studentPage, null); page.getCurrent(); //获取当前页 page.getPages(); //获取总的页数 page.getTotal(); //获取总记录数 model.addAttribute(\"page\",page); return \"mybatis-plus\"; }} 访问路径为“/queryAll”,请求参数为pn,表示当前页，默认为1 调用studentService.page(),即可得到Page对象，其内部属性，就是我们想要的与分页功能相关的数据 将page放入request作用域 3.修改视图显示的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;查询所有学生&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div &gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"student:${page.records}\"&gt; &lt;!--thymeleaf循环一个list--&gt; &lt;td&gt;[[${student.id}]]&lt;/td&gt; &lt;!--thymeleaf的行内写法，取出相应的变量--&gt; &lt;td&gt;[[${student.name}]]&lt;/td&gt; &lt;td&gt;[[${student.age}]]&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;br&gt; &lt;!--上方展示的student详情的list集合，必须从page.records中取--&gt; &lt;!--#########################以下内容与分页功能相关###############################--&gt; &lt;!--[[${page.current}]]为thymeleaf的写法，可以取出request域的变量--&gt; &lt;!--page.current、page.pages、page.total都是放在request作用域中的变量page的属性}--&gt; &lt;div&gt;当前第 [[${page.current}]] 页 总计 [[${page.pages}]] 页 共 [[${page.total}]] 条记录&lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;!--#numbers.sequence(1,page.pages)，该表达式是thymeleaf的写法。 表示可以生成一个从\"1\"到\"page.pages\"的序列,然后用thymeleaf的foreach循环，就可以得到页码num了--&gt; &lt;li th:each=\"num:${#numbers.sequence(1,page.pages)}\" &gt; &lt;!--下面的写法为thymeleaf的超链接写法 [[${num}]]用来显示页码数 @{/queryAll(pn=${num})}表示超链接的链接地址,(pn=${num})表示请求参数 @{/queryAll(pn=${num})}等价于@{/queryAll?pn=num} --&gt; &lt;a th:href=\"@{/queryAll(pn=${num})}\"&gt;[[${num}]]&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 前端分页功能代码的说明见注释 结果展示","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/tags/springboot/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://www.colorfo.top/tags/mybatis-plus/"},{"name":"分页","slug":"分页","permalink":"https://www.colorfo.top/tags/%E5%88%86%E9%A1%B5/"}]},{"title":"springboot定制化组件的方式","slug":"springboot定制化组件的方式","date":"2021-07-27T11:58:08.000Z","updated":"2021-07-27T12:17:50.877Z","comments":true,"path":"posts/4e7c.html","link":"","permalink":"https://www.colorfo.top/posts/4e7c.html","excerpt":"","text":"定制化组件的常见方式 修改配置文件； xxxxxCustomizer； 编写自定义的配置类 xxxConfiguration；+ @Bean替换、增加容器中默认组件；视图解析器 Web应用 编写一个配置类实现 WebMvcConfigurer 即可定制化web功能；(+ @Bean给容器中再扩展一些组件,可选的) 12@Configurationpublic class AdminWebConfig implements WebMvcConfigurer{} @EnableWebMvc + WebMvcConfigurer —— @Bean 可以全面接管SpringMVC，所有规则全部自己重新配置； 实现定制和扩展功能 原理 1、WebMvcAutoConfiguration 默认的SpringMVC的自动配置功能类。静态资源、欢迎页….. 2、一旦使用 @EnableWebMvc 会 @Import(DelegatingWebMvcConfiguration.class) 3、DelegatingWebMvcConfiguration 的 作用，只保证SpringMVC最基本的使用 把所有系统中的 WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer 合起来一起生效 自动配置了一些非常底层的组件。RequestMappingHandlerMapping、这些组件依赖的组件都是从容器中获取 public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport 4、WebMvcAutoConfiguration 里面的配置要能生效 必须 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 5、@EnableWebMvc 导致了 WebMvcAutoConfiguration 没有生效。","categories":[],"tags":[{"name":"springboot定制化组件","slug":"springboot定制化组件","permalink":"https://www.colorfo.top/tags/springboot%E5%AE%9A%E5%88%B6%E5%8C%96%E7%BB%84%E4%BB%B6/"}]},{"title":"SpringBoot文件上传","slug":"SpringBoot文件上传","date":"2021-07-27T07:56:20.000Z","updated":"2021-08-01T08:31:15.837Z","comments":true,"path":"posts/c59d.html","link":"","permalink":"https://www.colorfo.top/posts/c59d.html","excerpt":"","text":"[toc] 简介 springboot中文件上传，可以将上传的文件保存到本地，或者保存到文件服务器，OSS 下面通过一个springboot-thymeleaf项目，演示这一过程 项目流程 1.浏览器地址栏访问：http:localhost:8080/,跳转到templates/file_form.html 2.在file_form.html页面，选择需要上传的文件(支持单个、多个文件上传，文件的最大值在配置文件中指定)，提交后转到控制层的upload方法 3.在upload方法中，上传的文件被保存到本地 代码演示 项目文件结构 控制层代码 123456789101112131415161718192021222324252627282930313233@Controllerpublic class MyController { @RequestMapping(\"/\") public String upload(){ return \"file_form\"; } @PostMapping(\"/upload\") @ResponseBody public String upload(@RequestPart(\"picture\") MultipartFile picture, @RequestPart(\"photos\") MultipartFile[] photos) throws IOException { if(!picture.isEmpty()){ String originalFilename = picture.getOriginalFilename(); //保存文件到本地 picture.transferTo(new File(\"E:\\\\test\\\\\"+originalFilename)); } if (photos.length &gt; 0){ for (MultipartFile photo : photos) { if (!photo.isEmpty()){ String originalFilename = photo.getOriginalFilename(); //保存文件到本地 photo.transferTo(new File(\"E:\\\\test\\\\\"+originalFilename)); } } } return \"文件上传成功\"; }} 前端的file_form.html页面 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"post\" th:action=\"@{/upload}\" enctype=\"multipart/form-data\" &gt; 单个文件:&lt;input type=\"file\" name=\"picture\"&gt;&lt;br&gt; 多个文件:&lt;input type=\"file\" name=\"photos\" multiple&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 项目的配置文件 1234# 上传总文件的最大值spring.servlet.multipart.max-request-size=100MB# 单个文件的最大值spring.servlet.multipart.max-file-size=10MB 启动程序 123456789@SpringBootApplicationpublic class SpringbootFileUploadApplication { public static void main(String[] args) { SpringApplication.run(SpringbootFileUploadApplication.class, args); }}","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://www.colorfo.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"Interceptor拦截器的使用","slug":"Interceptor拦截器的使用","date":"2021-07-26T13:43:47.000Z","updated":"2021-07-26T14:37:16.414Z","comments":true,"path":"posts/ce45.html","link":"","permalink":"https://www.colorfo.top/posts/ce45.html","excerpt":"","text":"springboot项目中拦截器的使用 1.编写一个拦截器实现HandlerInterceptor接口 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors） 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】 1.实现HandlerInterceptor接口123456789101112131415161718192021222324252627282930313233@Slf4jpublic class MyInterceptor implements HandlerInterceptor { //目标方法执行之前，进行拦截 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(\"preHandle方法执行了{}\",request.getRequestURI()); String userName = (String) request.getSession().getAttribute(\"userName\"); if(userName != null){ return true; } request.getRequestDispatcher(\"/\").forward(request,response); return false; } //目标方法执行完成之后 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.info(\"postHandle方法执行了{}\",modelAndView); } //页面渲染之后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { log.info(\"afterCompletion方法执行了\"); }} 2.拦截器注册到容器中 实现WebMvcConfigurer的addInterceptors 1234567891011@Configurationpublic class MyConfiguration implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()) .addPathPatterns(\"/**\") //需要拦截的资源 .excludePathPatterns(\"/\",\"/login\"); //需要放行的资源 }} 3.拦截器原理1、根据当前请求，找到HandlerExecutionChain【可以处理请求的handler以及handler的所有 拦截器】 2、先来顺序执行 所有拦截器的 preHandle方法 1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle 2、如果当前拦截器返回为false。直接 倒序执行所有已经执行了的拦截器的 afterCompletion； 3、如果任何一个拦截器返回false。直接跳出不执行目标方法 4、所有拦截器的prehandler都返回true，才执行目标方法 5、倒序执行所有拦截器的postHandle方法。 6、前面的步骤有任何异常都会直接倒序触发 afterCompletion 7、页面成功渲染完成以后，也会倒序触发 afterCompletion","categories":[],"tags":[{"name":"Interceptor","slug":"Interceptor","permalink":"https://www.colorfo.top/tags/Interceptor/"}]},{"title":"springboot集成websocket实现聊天室的index.jsp代码","slug":"springboot集成websocket实现聊天室的index-jsp代码","date":"2021-07-25T06:54:58.000Z","updated":"2021-07-25T13:30:24.709Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://www.colorfo.top/posts/undefined.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"${pageContext.request.contextPath}/js/jquery.min.js\"&gt;&lt;/script&gt; &lt;title&gt;SpringBoot+WebSocket+JSP&lt;/title&gt;&lt;/head&gt;&lt;body style=\"margin: 45px;\"&gt; &lt;h4&gt;在线聊天室&lt;/h4&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"content\"&gt;&lt;/label&gt; &lt;textarea id=\"content\" readonly=\"readonly\" cols=\"80\" rows=\"15\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"form-group\" style=\"margin-top: 8px\"&gt; &lt;textarea id=\"message\" cols=\"80\" rows=\"5\" placeholder=\"请输入消息\"&gt;&lt;/textarea&gt; &lt;div style=\"margin-top: 10px\"&gt; &lt;button id=\"toSend\" class=\"btn btn-info\"&gt;发送&lt;/button&gt; &lt;button id=\"user_exit\" class=\"btn btn-danger\"&gt;离开&lt;/button&gt; &lt;input id=\"username\" value=\"${username}\" style=\"display: none\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; $(function () { var ws; if (\"WebSocket\" in window) { var baseUrl = 'ws://localhost:8080/websocket/'; var userName = $('#username').val(); ws = new WebSocket(baseUrl + userName); // 连通之后的回调事件，建立连接 ws.onopen = function () { console.log(\"建立 websocket 连接...\"); }; // 接收后台服务端的消息 ws.onmessage = function (event) { $('#content').append(event.data + '\\n\\n'); console.log(\"接收到服务端发送的消息...\" + event.data + '\\n'); }; ws.onerror = function (event) { console.log(\"websocket发生错误...\" + event + '\\n'); } // 连接关闭的回调事件 ws.onclose = function () { $('#content').append('[' + userName + '] 已离开!'); console.log(\"关闭 websocket 连接...\"); }; } else { // 浏览器不支持 WebSocket alert(\"您的浏览器不支持WebSocket!\"); } // 客户端发送消息到服务器 $('#toSend').click(function () { sendMsg(); }); $(document).keyup(function (event) { // 回车键事件 if (event.keyCode == 13) { sendMsg(); } }); // 发送消息 function sendMsg() { //websocket发送消息 ws.send($('#message').val()); $('#message').val(\"\"); } // 退出 $('#user_exit').click(function () { if (ws) { ws.close(); } }); }); &lt;/script&gt;&lt;/body&gt;&lt;%--此页面的源代码即为index.jsp的代码--%&gt;&lt;%--点击右键即可查看网页源代码--%&gt;&lt;/html&gt;","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"}]},{"title":"springboot集成websocket实现聊天室","slug":"springboot集成websocket实现聊天室","date":"2021-07-25T04:04:39.000Z","updated":"2021-07-25T13:30:26.881Z","comments":true,"path":"posts/3a35.html","link":"","permalink":"https://www.colorfo.top/posts/3a35.html","excerpt":"","text":"1.websocket简介WebSocket协议WebSocket协议是由HTML5定义的，基于TCP协议实现的一种网络协议，通过该协议服务器可以主动向客户端发送信息； WebSocket 协议在2008年诞生，2011年成为W3C国际标准；我们已经有了 HTTP 协议，为什么出现一个websocket协议？ http协议是短连接，因为请求之后，都会关闭连接，下次重新请求数据，需要再次打开链接；WebSocket协议是一种长连接，只需要通过一次请求来初始化连接，然后所有的请求和响应都是通过这个TCP连接进行通讯； 所以HTTP协议通信只能是客户端向服务器发出请求，服务器返回响应结果，HTTP 协议做不到服务器主动向客户端推送信息，而websocket能实现服务器和客户端全双工通信； 何谓全双工 信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工，信息能够同时双向传送则称为全双工； 基本实现原理 WebSocket协议基于TCP协议实现，客户端和服务器只需要做一个握手的动作之后，形成了一条基于客户端和服务器之间的快速通道，之后客户端与服务端之间便可以进行多次数据帧双向传输；这样实现的目的是客户端和服务器进行频繁双向通信时，可以使服务器避免频繁创建HTTP连接，节约资源，提高工作效率和资源利用率。 传统Web推送实现​ 在没有WebSocket协议之前，服务器如何向浏览器端推送消息？通常的实现方式是在页面通过Ajax定时轮询，比如每隔1秒中向服务器发送一次HTTP请求，询问服务器是否有新消息，服务器返回结果；这种形式缺点很明显，浏览器需要不断的向服务器发出HTTP请求，而HTTP请求包含较长的头部，有效信息相对较少，反复的无效请求占用了大量的带宽和 CPU 资源，造成很大的浪费，所以，WebSocket 应运而生；HTML5定义的WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯； WebSocket协议本质上是一个基于TCP的协议，因此与HTTP协议没有什么关系； WebSocket的特点全双工通信，客户端和服务器可以双向平等通信； 建立在TCP协议之上，服务器端的实现比较容易； 数据格式比较轻量，性能开销小，通信高效； 可以发送文本，也可以发送二进制数据； 通信具有更强的实时性； 协议标识符是ws，服务器地址就是：ws://www.abc.com/some/path http协议： http:// websocket的业务场景WebSocket聊天室； 股票实时价格显示等应用； 即时通讯、游戏、可视化大屏展示等领域； 企业内部管理通讯等功能，主要通讯协议websocket； web网页聊天、客服系统实现； 系统提醒、用户上下线提醒、客户端同步，实时数据更新，多屏幕同步，用户在线状态，消息通知，扫描二维码登录/二维码支付，弹幕、各类信息提醒，在线选座，实时监控大屏等等； Java中的WebSocket API在Java EE 7中Java语言开始支持websocket协议，Java EE 7中定义了一套Websocket API规范，也就是一系列接口，没有实现，位于包javax.websocket下，包含客户端API和服务端API，WebSocket的Java API 只是规范，具体实现需要web容器（比如tomcat就实现了Java websocket api）、Java EE服务器或者框架提供； 在java中服务端的实现 1、Tomcat：java中的websocket实现，需要tomcat 7.0.47+以上才支持， Java EE7的支持； 2、Spring的websocket，需要Spring 4.x，所以springboot也可以用； 2.Websocket开发相关注解及API方法websocket注解 @ServerEndpoint(“/websocket/{uid}”) 申明这是一个websocket服务； 需要指定访问该服务的地址，在地址中可以指定参数，需要通过{}进行占位； @OnOpen 用法：public void onOpen(Session session, @PathParam(\"uid\") String uid) throws IOException{} 该方法将在建立连接后执行，会传入session对象，就是客户端与服务端建立的长连接通道，通过@PathParam获取url中声明的参数； @OnClose 用法：public void onClose() {} 该方法是在连接关闭后执行； @OnMessage 用法：public void onMessage(String message, Session session) throws IOException {} 该方法用于接收客户端发送的消息； message：发来的消息数据； session：会话对象（也是长连接通道）； 发送消息到客户端； 用法：session.getBasicRemote().sendText(\"hello,websocket.\"); 通过session进行消息发送； 前端技术对websocket的支持Websocket是html5规范，主流浏览器都支持；（某些老浏览器不支持） jQuery、vueJS、React JS、angularjs等都可以支持webscoket对象； 底层是javascript支持的一个webscoket的js对象，通过这个对象可以建立websocket的连接：ws://localhost:8080/websocket/12345 WebSocket有很多优点，弥补了http协议的不足，但是如果服务端维护很多长连接也是很耗费资源的，服务器集群带来了复杂性以及存在老版本浏览器兼容性问题，各大厂目前大多数还是基于轮询的方式实现的，比如：扫码登录、支付成功通知、秒杀成功通知等； 在秒杀场景中，用轮询即可，前端轮询一般不可能穿透到后端数据库查询，一般是采用高性能的缓存标记来判定秒杀是否成功，相对于websocket长连接以及其不确定因素，轮询依然是相对比较合适的方案； Websocket各浏览器的支持情况： https://caniuse.com/#search=websocket 3.springboot集成WebSocket实现多人聊天室 项目代码结构分布 pom文件依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;!--此项目的GAV坐标--&gt; &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt; &lt;artifactId&gt;041-springboot-websocket&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--springboot web项目的起步依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--spring-boot-starter-websocket--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok,需要在IDEA中安装lombok插件才能使用该依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入Spring Boot内嵌的Tomcat对JSP的解析包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署插件(该依赖不是必选项)--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;!--src/main/java下的.xml配置文件编译到target下去--&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!--src/main/resources下的配置文件编译到target下去--&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!--src/main/webapp下的jsp页面编译到META-INF/resources下才能访问--&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 前端代码 项目的主配置文件application.properties 123#设置jsp文件的前缀和后缀spring.mvc.view.prefix=/spring.mvc.view.suffix=.jsp index.jsp文件详情 1234hexo博客不能正常显示jsp格式的代码代码详情见本站的博文：\"springboot集成websocket实现聊天室的index-jsp代码\"，进入该博文页面后，点击右键即可查看index.jsp的源代码 还需要一个jquery.min.js文件，可以去网上下载 后端代码 后端代码结构 首先是endpoint包下的chatServerEndpoint.java 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.bjpowernode.endpoint;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import javax.websocket.*;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;import java.io.IOException;/** * 说明： * 1、@ServerEndpoint注解中指定WebSocket协议的地址； * 2、@OnOpen、@OnMessage、@OnClose、@OnError注解与WebSocket中监听事件对应 * **/@Slf4j //lombok jar包，帮我们自动生成一些代码：@Data@Component@ServerEndpoint(\"/websocket/{username}\")public class ChatServerEndpoint { /** * 连接建立时触发 */ @OnOpen public void openSession(@PathParam(\"username\") String username, Session session) { log.info(\"用户{}登录\", username); String message = \"用户[\" + username + \"] 已进入聊天室！\"; // 发送登录消息给其他人 WebSocketUtils.sendMessageAll(message); // 获取当前在线人数，发给自己 String onlineInfo = WebSocketUtils.getOnlineInfo(); //发送消息 WebSocketUtils.sendMessage(session, onlineInfo); // 添加自己到map中 WebSocketUtils.CLIENTS.put(username, session); } /** * 客户端接收服务端数据时触发 */ @OnMessage public void onMessage(@PathParam(\"username\") String username, String message) { log.info(\"发送消息：{}, {}\", username, message); //广播，把消息同步给其他客户端 WebSocketUtils.sendMessageAll(\"[\" + username + \"] : \" + message); } /** * 连接关闭时触发 */ @OnClose public void onClose(@PathParam(\"username\") String username, Session session) { // 当前的Session移除某个用户 WebSocketUtils.CLIENTS.remove(username); // 离开消息通知所有人 WebSocketUtils.sendMessageAll(\"[\" + username + \"] 已离开！\"); try { //关闭WebSocket Session会话 session.close(); log.info(\"{} 已退出, onclose\", username); } catch (IOException e) { e.printStackTrace(); log.error(\"onClose error\", e); } } /** * 通信发生错误时触发 */ @OnError public void onError(Session session, Throwable throwable) { try { //关闭WebSocket Session会话 session.close(); } catch (IOException e) { e.printStackTrace(); log.error(\"onError Exception\", e); } log.info(\"Throwable msg \" + throwable.getMessage()); }} endpoint包下的WebSocketUtils.java 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.bjpowernode.endpoint;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.websocket.RemoteEndpoint;import javax.websocket.Session;import java.io.IOException;import java.util.Map;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;public final class WebSocketUtils { private static final Logger logger = LoggerFactory.getLogger(WebSocketUtils.class); /** * 存储WebSocket session * &lt;p&gt; * 用户名为key，WebSocket Session对象为value */ public static final Map&lt;String, Session&gt; CLIENTS = new ConcurrentHashMap&lt;&gt;(); /** * 使用连接发送数据 * * @param session 用户session * @param message 发送内容 */ public static void sendMessage(Session session, String message) { if (session == null) { return; } final RemoteEndpoint.Basic basic = session.getBasicRemote(); if (basic == null) { return; } try { //发送 basic.sendText(message); } catch (IOException e) { e.printStackTrace(); logger.error(\"sendMessage IOException \", e); } } /** * 发送消息给其他所有人 * * @param message */ public static void sendMessageAll(String message) { CLIENTS.forEach((sessionId, session) -&gt; sendMessage(session, message)); } /** * 获取所有在线用户 */ public static String getOnlineInfo() { Set&lt;String&gt; userNames = CLIENTS.keySet(); if (userNames.size() == 0) { return \"当前无人在线...\"; } return CLIENTS.keySet().toString() + \"在线\"; }} 接着是controller包下的ChatController.java文件 1234567891011121314151617181920package com.bjpowernode.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.concurrent.atomic.AtomicInteger;@Controllerpublic class ChatController { private AtomicInteger idProducer = new AtomicInteger(); @RequestMapping(\"/\") public String index(Model model) { model.addAttribute(\"username\",\"user\" + idProducer.getAndIncrement()); return \"index\"; }} 项目启动后，访问根路径，转发到index.jsp 最后是config包下的WebSocketConfig.java文件 123456789101112131415161718192021package com.bjpowernode.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.config.annotation.EnableWebSocket;import org.springframework.web.socket.server.standard.ServerEndpointExporter;@EnableWebSocket //启用WebSocket支持@Configuration //表示配置类public class WebSocketConfig { /** * 配置ServerEndpointExporter的bean * * 该Bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint */ @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); }} 最后的最后，是程序的主入口Application.java，用来启动整个项目 123456789101112package com.bjpowernode;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 项目启动运行 在浏览器地址栏输入http://localhost:8080/ 示例如下 在另一个浏览器地址栏(或者相同浏览器新建一个窗口)输入http://localhost:8080/，即可实现多人聊天","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"}]},{"title":"springboot之-MatrixVariable注解使用","slug":"springboot之-MatrixVariable注解使用","date":"2021-07-24T14:51:43.000Z","updated":"2021-08-26T11:13:51.255Z","comments":true,"path":"posts/80aa.html","link":"","permalink":"https://www.colorfo.top/posts/80aa.html","excerpt":"","text":"简介​ 根据 URI 规范 RFC 3986 中 URL 的定义，路径片段中可以可以包含键值对。规范中没对对应的术语。一般 “URL 路径参数” 可以被应用，尽管更加独特的 “矩阵 URI” 也经常被使用并且相当有名。在 Spring MVC 它被称为矩阵变量。 矩阵变量可以出现在任何路径片段中，每一个矩阵变量都用分号（;）隔开。比如 /cars;color=red;year=2012。多个值可以用逗号隔开，比如color=red,green,blue，或者分开写 color=red;color=green;color=blue。 如果你希望一个 URL 包含矩阵变量，那么请求映射模式必须用 URI 模板来表示这些矩阵变量。这样的话，不管矩阵变量顺序如何，都能够保证请求可以正确的匹配。 Springboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。 下面用一个springboot项目演示 @MatrixVariable的具体使用方法 1.前端代码部分 项目的结构分布 前端index.html的代码如下 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;springboot注解之@MatrixVariable&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;springboot注解之@MatrixVariable&lt;/h1&gt;&lt;br/&gt;&lt;a href=\"/car/sell;num=10;brand=BYD,AuDi\"&gt;@MatrixVariable（矩阵变量）/car/{sell}&lt;/a&gt;&lt;br/&gt;&lt;a href=\"/boss/1;age=20/2;age=30\"&gt;@MatrixVariable（矩阵变量）/boss/{bossId}/{empId}&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; ​ 1.在/car/sell路径下访问，请求参数为num和brand 2.在/boss/{bossId}/{empId}路径下访问.请求参数age=20表示/boss/bossId?age=20. 而请求参数age=30则表示访问路径/boss/bossId/empId?age=30 2.后端代码部分2.1 配置类MyConfig.javaSpringboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。 12345678910111213141516171819package com.bjpowernode.springboot.conf;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.PathMatchConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.util.UrlPathHelper;@Configuration(proxyBeanMethods = false)public class MyConfig implements WebMvcConfigurer{ @Override public void configurePathMatch(PathMatchConfigurer configurer) { UrlPathHelper urlPathHelper = new UrlPathHelper(); urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); }} 2.2 控制器AnnotationController.java123456789101112131415161718192021222324252627282930313233343536373839package com.bjpowernode.springboot.web;import org.springframework.web.bind.annotation.*;import java.util.HashMap;import java.util.List;import java.util.Map;@RestControllerpublic class AnnotationController { @RequestMapping(\"/car/{path}\") public Map getCar(@MatrixVariable(\"num\") Integer num, @MatrixVariable(\"brand\") List&lt;String&gt; brand, @PathVariable(\"path\") String path){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"num\",num); map.put(\"brand\",brand); map.put(\"path\",path); return map; } @GetMapping(\"/boss/{bossId}/{empId}\") public Map getAge(@PathVariable(\"bossId\") Integer bossId, @PathVariable(\"empId\") Integer empId, @MatrixVariable(value = \"age\",pathVar = \"bossId\") Integer bossAge, @MatrixVariable(value = \"age\",pathVar = \"empId\") Integer empAge){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"bossId\",bossId); map.put(\"empId\",empId); map.put(\"bossAge\",bossAge); map.put(\"empAge\",empAge); return map; }} 2.3 主程序入口1234567891011121314package com.bjpowernode.springboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringbootAnnotationApplication { public static void main(String[] args) { SpringApplication.run(SpringbootAnnotationApplication.class, args); }} 3.结果演示 启动主程序SpringbootAnnotationApplication，在浏览器地址栏输入：http://localhost:8080/,可以得到如下页面 点击第一个链接，得到如下结果 点击第二个链接，得到如下结果","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"MatrixVariable","slug":"MatrixVariable","permalink":"https://www.colorfo.top/tags/MatrixVariable/"},{"name":"springboot注解","slug":"springboot注解","permalink":"https://www.colorfo.top/tags/springboot%E6%B3%A8%E8%A7%A3/"}]},{"title":"markdown语法的使用、博文标题的使用","slug":"markdown语法的使用、博文标题的使用","date":"2021-06-19T07:40:00.000Z","updated":"2021-08-01T08:18:17.177Z","comments":true,"path":"posts/9892.html","link":"","permalink":"https://www.colorfo.top/posts/9892.html","excerpt":"","text":"[TOC] 关于博文的Front-matter的使用 Front-matter中的内容为非必填项，但建议至少填写title和date 最全示例 12345678910111213141516171819---title: 基于 Hexo GitHub 从零开始搭建个人博客date: 2019-12-30 09:25:00author: Sitoiimg: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Hexokeywords: Hexo GitHub blogtags: - Hexo - Blog - GitHub--- 转载自:https://sitoi.cn/posts/63466.html markdown 的基本语法1.斜体和粗体12341. *斜体*或者_斜体_2. **粗体**3. ***加粗斜体***4. ~~删除线~~ 显示效果： 斜体或者_斜体_ 粗体 加粗斜体 删除线 2.分级标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 3.超链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。 3.1 行内式 介绍：[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。 123示例：1. 欢迎访问[我的博客](www.colorfo.top)2. 欢迎访问[我的博客](www.colorfo.top \"colorfo\") 欢迎访问我的博客 欢迎访问我的博客 3.2 参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明：参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 12345678我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3][Leanote 笔记][2]是一个不错的[网站][]。[1]:http://www.google.com \"Google\"[2]:http://www.leanote.com \"Leanote\"[3]:http://www.colorfo.top \"自己的博客\"[网站]:http://http://blog.leanote.com/freewalk 显示效果： 我经常去的几个网站Google、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 更多内容请参考—&gt;原文链接：https://blog.csdn.net/witnessai1/article/details/52551362","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.colorfo.top/tags/markdown/"},{"name":"front-matter","slug":"front-matter","permalink":"https://www.colorfo.top/tags/front-matter/"}],"author":"QianJL"},{"title":"hexo博客的启动和部署","slug":"hexo博客的启动和部署","date":"2021-06-02T08:12:23.000Z","updated":"2021-06-03T11:29:48.212Z","comments":true,"path":"posts/be0d.html","link":"","permalink":"https://www.colorfo.top/posts/be0d.html","excerpt":"","text":"本篇博客主要记录hexo博客的启动和部署启动hexo博客 在blog文件夹下，输入cmd,进入Windows的命令提示行窗口 输入”hexo server”即可启动 hexo 博客 打开浏览器，输入地址：http://localhost:4000,即可从本地访问hexo博客 添加部署信息 在_config.yml文件中操作(_config.yml文件的最下面修改)，可以将博客部署到github或者gitee 例如我的设置为： 1234deploy:type: gitrepo: https://gitee.com/ColorQian/ColorQian.gitbranch: master 修改好配置后，运行如下命令，将代码部署到gitee 123hexo clean hexo generate hexo deploy 在gitee的Gitee Pages 页面更新部署 在浏览器地址栏输入：http://colorqian.gitee.io 即可访问博客","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.colorfo.top/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-04-15T08:12:23.000Z","updated":"2021-06-03T09:23:14.311Z","comments":true,"path":"posts/3d22.html","link":"","permalink":"https://www.colorfo.top/posts/3d22.html","excerpt":"","text":"关于我姓名：钱佳乐😄来自南京理工大学你可以通过邮箱联系我：qjl@njust.edu.cn 关于这个博客网站网站名：”http://colorqian.gitee.io\"我将会不定期的在这个网站上发布一些关于java的文章 技术支持程序羊","categories":[],"tags":[]}],"categories":[{"name":"图解系统","slug":"图解系统","permalink":"https://www.colorfo.top/categories/%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://www.colorfo.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"图解HTTP","slug":"图解HTTP","permalink":"https://www.colorfo.top/categories/%E5%9B%BE%E8%A7%A3HTTP/"},{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"进程","slug":"进程","permalink":"https://www.colorfo.top/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"进程的状态","slug":"进程的状态","permalink":"https://www.colorfo.top/tags/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"},{"name":"PCB","slug":"PCB","permalink":"https://www.colorfo.top/tags/PCB/"},{"name":"内存管理","slug":"内存管理","permalink":"https://www.colorfo.top/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"内存分页","slug":"内存分页","permalink":"https://www.colorfo.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5/"},{"name":"内存分段","slug":"内存分段","permalink":"https://www.colorfo.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5/"},{"name":"字符串","slug":"字符串","permalink":"https://www.colorfo.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://www.colorfo.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"单调栈","slug":"单调栈","permalink":"https://www.colorfo.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"dp","slug":"dp","permalink":"https://www.colorfo.top/tags/dp/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.colorfo.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"子序列","slug":"子序列","permalink":"https://www.colorfo.top/tags/%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"买卖股票","slug":"买卖股票","permalink":"https://www.colorfo.top/tags/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/"},{"name":"完全背包","slug":"完全背包","permalink":"https://www.colorfo.top/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"},{"name":"cookie","slug":"cookie","permalink":"https://www.colorfo.top/tags/cookie/"},{"name":"http报文","slug":"http报文","permalink":"https://www.colorfo.top/tags/http%E6%8A%A5%E6%96%87/"},{"name":"http状态码","slug":"http状态码","permalink":"https://www.colorfo.top/tags/http%E7%8A%B6%E6%80%81%E7%A0%81/"},{"name":"贪心","slug":"贪心","permalink":"https://www.colorfo.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"回溯","slug":"回溯","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"BST","slug":"BST","permalink":"https://www.colorfo.top/tags/BST/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://www.colorfo.top/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"二叉树的遍历","slug":"二叉树的遍历","permalink":"https://www.colorfo.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"name":"KMP算法","slug":"KMP算法","permalink":"https://www.colorfo.top/tags/KMP%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://www.colorfo.top/tags/%E9%93%BE%E8%A1%A8/"},{"name":"约瑟夫环","slug":"约瑟夫环","permalink":"https://www.colorfo.top/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"name":"单链表","slug":"单链表","permalink":"https://www.colorfo.top/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://www.colorfo.top/tags/%E9%98%9F%E5%88%97/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.colorfo.top/tags/LeetCode/"},{"name":"回文","slug":"回文","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%96%87/"},{"name":"github搜索","slug":"github搜索","permalink":"https://www.colorfo.top/tags/github%E6%90%9C%E7%B4%A2/"},{"name":"git","slug":"git","permalink":"https://www.colorfo.top/tags/git/"},{"name":"github","slug":"github","permalink":"https://www.colorfo.top/tags/github/"},{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/tags/springboot/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://www.colorfo.top/tags/mybatis-plus/"},{"name":"分页","slug":"分页","permalink":"https://www.colorfo.top/tags/%E5%88%86%E9%A1%B5/"},{"name":"springboot定制化组件","slug":"springboot定制化组件","permalink":"https://www.colorfo.top/tags/springboot%E5%AE%9A%E5%88%B6%E5%8C%96%E7%BB%84%E4%BB%B6/"},{"name":"文件上传","slug":"文件上传","permalink":"https://www.colorfo.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"Interceptor","slug":"Interceptor","permalink":"https://www.colorfo.top/tags/Interceptor/"},{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"},{"name":"MatrixVariable","slug":"MatrixVariable","permalink":"https://www.colorfo.top/tags/MatrixVariable/"},{"name":"springboot注解","slug":"springboot注解","permalink":"https://www.colorfo.top/tags/springboot%E6%B3%A8%E8%A7%A3/"},{"name":"markdown","slug":"markdown","permalink":"https://www.colorfo.top/tags/markdown/"},{"name":"front-matter","slug":"front-matter","permalink":"https://www.colorfo.top/tags/front-matter/"},{"name":"博客","slug":"博客","permalink":"https://www.colorfo.top/tags/%E5%8D%9A%E5%AE%A2/"}]}