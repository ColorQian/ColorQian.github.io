{"meta":{"title":"color","subtitle":"一万年太久,只争朝夕","description":"专注于java后端的学习","author":"QianJL","url":"https://www.colorfo.top","root":"/"},"pages":[{"title":"404","date":"2021-06-02T08:41:10.000Z","updated":"2021-06-03T06:11:32.904Z","comments":true,"path":"404.html","permalink":"https://www.colorfo.top/404.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2021-06-02T08:08:48.360Z","comments":true,"path":"categories/index.html","permalink":"https://www.colorfo.top/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-06-03T04:25:30.000Z","updated":"2021-06-19T12:52:10.726Z","comments":true,"path":"about/index.html","permalink":"https://www.colorfo.top/about/index.html","excerpt":"","text":"基本信息 😘 昵称 : color 🌇 城市 : 南京 🎓 学历 : 硕士在读 💪 我努力的方向 : java后端 🏀 爱好 : 篮球 | 跑步 | 羽毛球 | 乒乓球等 联系我 QQ : 1255574204 ✉ : qjl@njust.edu.cn"},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2021-06-02T08:13:51.665Z","comments":true,"path":"friends/index.html","permalink":"https://www.colorfo.top/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-06-03T05:14:00.000Z","updated":"2021-06-03T07:51:07.993Z","comments":true,"path":"contact/index.html","permalink":"https://www.colorfo.top/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2021-06-02T08:07:41.432Z","comments":true,"path":"tags/index.html","permalink":"https://www.colorfo.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"单链表的增删改查和插入","slug":"单链表的增删改查和插入","date":"2021-08-05T07:07:50.000Z","updated":"2021-08-05T07:13:16.996Z","comments":true,"path":"posts/64b9.html","link":"","permalink":"https://www.colorfo.top/posts/64b9.html","excerpt":"","text":"本篇博文属于单链表的入门案例，包含单链表的一些基础操作:增删改查、插入 1.首先创建一个Node结点类 public class Node { Integer id; String name; Node next; public Node() { } public Node(Integer id, String name) { this.id = id; this.name = name; } @Override public String toString() { return \"Node{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; } } 2.然后创建一个单链表类(包含了单链表的增删改查等方法) public class SingleList { //头结点 private Node head = new Node(); //为当前单向链表添加一个结点 public void add(Node node){ //定义一个临时结点指向头结点 Node temp = head; //一直遍历链表，直到temp.next == null while (temp.next != null){ temp = temp.next; } //temp.next == null,说明找到了链表的尾部，将node加入链表中 temp.next = node; } //按照id修改链表的name public void update(Node node){ if (head.next == null){ return; } Node temp = head.next; while (temp != null){ if (temp.id == node.id){ temp.name = node.name; break; } temp = temp.next; } } //根据id删除节点 public void delete(int id){ if (head.next == null){ return; } Node temp = head; while (temp.next != null){ if (temp.next.id == id){ temp.next = temp.next.next; break; } temp = temp.next; } } //遍历链表 public void list(){ if (head.next == null){ return; } Node temp = head.next; while (temp != null){ System.out.println(temp); temp = temp.next; } } /** * 按照id编号的大小顺序插入，从小到大 * @param node */ public void insertById(Node node){ Node temp = head; boolean flag = false; while (true){ //如果temp结点的下一个为空，直接跳出循环,从这里跳出循环flag=false; if(temp.next == null){ break; } //程序走到这里，说明，temp.next != null if (node.id == temp.next.id){ flag = true; //从这里跳出循环flag = true break; }else if(node.id &lt; temp.next.id){ break; //从这里跳出循环flag = false; } //这里不用写出node.id > temp.next.id的情况， //因为这种情况会一直遍历到链表的末尾，满足temp.next == null条件后，跳出循环，最后在链表末尾加上node temp = temp.next; //temp 向后移动一位，用来遍历单链表 } if (flag){ System.out.println(\"编号已经存在\"); }else { //在此处执行结点的插入操作(适用于在head结点后加结点(即temp.next == null)，以及node.id 小于 temp.next.id的情况) node.next = temp.next; temp.next = node; } } public static void main(String[] args) { SingleList list = new SingleList(); /*list.add(new Node(1,\"张三\")); list.add(new Node(2,\"lisi\")); list.update(new Node(2,\"李四\")); list.add(new Node(3,\"王五\")); list.add(new Node(4,\"赵六\")); list.delete(1); list.delete(4); list.list();*/ //*****************上面是增删改查的测试************ //*****************下面是按顺序插入的测试************ list.insertById(new Node(3,\"王3\")); list.insertById(new Node(2,\"王2\")); list.insertById(new Node(1,\"王1\")); list.insertById(new Node(5,\"王5\")); list.insertById(new Node(4,\"王4\")); list.insertById(new Node(6,\"王6\")); list.list(); } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"https://www.colorfo.top/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"}]},{"title":"栈和队列刷题笔记","slug":"栈和队列刷题笔记","date":"2021-08-04T07:36:20.000Z","updated":"2021-08-04T07:35:45.586Z","comments":true,"path":"posts/f354.html","link":"","permalink":"https://www.colorfo.top/posts/f354.html","excerpt":"","text":"1.用一个栈实现另一个栈的排序 题目： ​ 一个栈中的类型为整型，现在想将该栈从顶到底按照从大到小的顺序排序，只允许申请一个栈，除此之外，可以申请新的变量，如何排序？ 思路分析： ​ 将要排序的栈记为stack,申请的辅助栈记为help，在stack上执行pop操作，弹出的元素记为cur 如果cur小于或等于help的栈顶元素，直接将cur压入help 如果cur大于help的栈顶元素，则将help中的元素逐次弹出，然后压入stack中，直到cur小于或等于help的栈顶元素，再将cur压入help栈中； 如果在help栈的弹栈过程中，help已经空了，则说明cur是当前的最大元素，则直接将cur压入help中 最后，help中的数，从栈顶到栈底为从小到大的顺序，将help中的数依次弹出压入stack中，则stack从栈顶到栈底为从大到小的顺序 难度：一星 代码实现 /** * 用一个栈实现另一个栈的排序 */ public class SortStackByStack { public static Stack sortStack(Stack&lt;Integer> stack){ Stack&lt;Integer> help = new Stack&lt;>(); while (!stack.isEmpty()){ int cur = stack.pop(); while(!help.isEmpty() &amp;&amp; cur > help.peek()){ stack.push(help.pop()); } help.push(cur); } while (!help.isEmpty()){ stack.push(help.pop()); } return stack; } public static void main(String[] args) { Stack&lt;Integer> stack = new Stack&lt;>(); stack.push(2); stack.push(1); stack.push(8); stack.push(7); stack.push(3); stack.push(4); stack.push(4); stack = sortStack(stack); int size = stack.size(); for (int i = 0; i &lt; size; i++) { System.out.println(stack.pop()); } } } 2.数组中元素与下一个比它大的元素之间的距离力扣（Medium） Input: [73, 74, 75, 71, 69, 72, 76, 73] Output: [1, 1, 4, 2, 1, 1, 0, 0] 说明：对于此题，提供两种解法，详情见下面代码 方法一：暴力求解,时间复杂度O(N^2) /** * 时间复杂度为O(N^2),每个位置向右遍历一下即可 */ public class DailyTemperature2 { public static int[] rightWay(int arr[]){ int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) { int cur = i+1; int rightMoreIndex = 0; while (cur &lt; arr.length){ if (arr[cur] > arr[i]){ res[i] = cur - i; break; } cur++; } } return res; } //写个main方法测试一下 public static void main(String[] args) { int[] arr = {73,74,75,71,69,72,76,73}; int[] res = rightWay(arr); for (int re : res) { System.out.println(re); } } } 方法二：遍历数组时，使用栈把数组的下标存起来,时间复杂度O(N) 思路分析： /** * 1.用dist数组存放距离当前位置的距离，用stack存放原始数组temperature的下标 * 2.用cur指向temperature数组的下标，pre指向stack栈的栈顶元素 * * 3.如果stack不为空，并且当前遍历的数temperature[cur] 大于 栈顶对应的数temperature[stack.peek()]， * 就将stack的栈顶元素弹出，存到pre变量中，cur - pre即为与pre的距离dist[pre].之后再将cur压入stack中。 * 4.如果stack为空，直接将cur压入stack中。 * */ public class DailyTemperatures { public static void main(String[] args) { int[] temperature = {73, 74, 75, 71, 69, 72, 76, 73}; int[] dist = dailyTemperatures(temperature); for (int i : dist) { System.out.print(i+\" \"); } } public static int[] dailyTemperatures(int[] temperatures) { int[] dist = new int[temperatures.length]; Stack&lt;Integer> stack = new Stack&lt;>(); for (int cur = 0; cur &lt; temperatures.length; cur++) { int pre = 0; while (!stack.isEmpty() &amp;&amp; temperatures[cur] > temperatures[stack.peek()]){ pre = stack.pop(); dist[pre] = cur - pre; } stack.push(cur); } return dist; } } 3.返回数组的最近邻位置（利用单调栈） 题目： 给定一个不含重复值的数组arr,找到每一个位置i左边和右边离i位置最近且值比arr[i]小的位置，返回左右位置的相应信息 举例： intput: arr = {3,4,1,5,6,2,7} output: { {-1,2}, {0,2}, {-1,-1}, {2,5}, {3,5}, {2,-1}, {5,-1}, } 解答：方法一 本题实现复杂度为O(N^2)的解释非常容易的，每个位置向左和向右遍历一下，总可以确定，见以下代码 public class MonotoneStack { public static int[][] rightWay(int[] arr){ int[][] res = new int[arr.length][2]; for (int i = 0; i &lt; arr.length; i++) { int leftLessIndex = -1; int rightLessIndex = -1; int cur = i-1; while (cur >= 0){ if (arr[cur] &lt; arr[i]){ leftLessIndex = cur; break; } cur--; } cur = i+1; while (cur &lt; arr.length){ if (arr[cur] &lt; arr[i]){ rightLessIndex = cur; break; } cur++; } res[i][0] = leftLessIndex; res[i][1] = rightLessIndex; } return res; } public static void printArr2(int[][] arr){ for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[0].length; j++) { System.out.print(arr[i][j]+\" \"); } System.out.println(\"\"); } } public static void main(String[] args) { int[] arr = {3,4,1,5,6,2,7}; int[][] res = rightWay(arr); printArr2(res); } } 方法二：利用单调栈结构，时间复杂度为O(N) 思路分析： /** * 单调栈——返回最近邻的位置 * * 准备一个栈，记为Stack&lt;integer>,栈中存放的元素是数组的位置，开始stack为空，如果找到每一个位置i左边 * 和右边离i位置最近且值比arr[i]小的位置，那么需要让stack从栈顶到栈底的位置所代表的值是递减的(也就是从大到小)； * 如果找到每一个位置i左边和右边离i位置最近且值比arr[i]大的位置，那么需要让stack从栈顶到栈底的位置所代表的值是递增的。 * 本题需要解决是前者。 * 下面举例展示单调栈的使用和求解流程，以arr = {3,4,1,5,6,2,7}为例。 * 1.初始时，arr = {3,4,1,5,6,2,7},stack为空。 * 2.遍历arr数组，遍历到arr[0] = 3时，stack为空，直接将0压入stack中，此时，stack中从栈顶到栈底为{0(值为3)} * 3.遍历到arr[1]=4时，`arr[1] > arr[stack.peek()]`，将1压入到stack中，此时，stack从栈顶到栈底为 * {1(值为4)，0(值为3)} * 4.遍历到arr[2] = 1时，如果将下标2压入stack中，会破坏stack从栈顶到栈底所代表的的值是递减的规律， * 那么，此时将stack的栈顶元素\"1\"弹出，位置1左边比它代表的值小的下标即为此时stack栈的栈顶元素\"0\"， * 位置1右边比它代表的值小的下标，即为当前遍历的下标\"2\"，那么res[1] = {0,2}。此时，stack从栈顶到栈底为{0(值为3)}， * 如果将下标2压入stack中，依旧会破坏stack从栈顶到栈底的元素所代表的值是递减的规律，此时将stack的栈顶元素\"0\"弹出，stack栈已经空了， * 位置0左边不存在比它小的数，默认取-1，位置0右边比它代表的值小的下标，即为当前遍历的下标\"2\"，那么res[0] = {-1,2}。 * 这时，stack为空，将\"2\"压入stack中，stack从栈顶到栈底的元素为{2(值为1)} * 5.按照此规律继续遍历下去...... * 6.遍历阶段结束后，stack从栈顶到栈底的元素为{6(值为7),5(值为2),2(值为1)}。 * 下面清算stack中剩下的元素，将stack的栈顶元素\"6\"弹出，栈中它的下面位置是5，而由于6位置是清算阶段弹出的，所以res[6] = {5,-1}; * 弹出5位置，栈中它的下面位置是2,5位置是清算阶段弹出的，所以res[5] = {2,-1}; * 弹出2位置，栈中它的下面没有位置了,2位置是清算阶段弹出的，所以res[2] = {-1,-1}; * */ 代码实现 /** * 单调栈——返回最近邻的位置 */ public class MonotoneStack2 { public static int[][] getNearLessNoRepeat(int[] arr){ int[][] res = new int[arr.length][2]; Stack&lt;Integer> stack = new Stack&lt;>(); //遍历阶段 for (int i = 0; i &lt; arr.length; i++) { while (!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[stack.peek()]){ int popIndex = stack.pop(); int leftLessIndex = stack.isEmpty() ? -1 : stack.peek(); res[popIndex][0] = leftLessIndex; res[popIndex][1] = i; } stack.push(i); } //开始清算阶段 while(!stack.isEmpty()){ int popIndex = stack.pop(); int leftLessIndex = stack.isEmpty() ? -1 : stack.peek(); res[popIndex][0] = leftLessIndex; res[popIndex][1] = -1; } return res; } public static void printArr2(int[][] arr){ for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[0].length; j++) { System.out.print(arr[i][j]+\" \"); } System.out.println(\"\"); } } public static void main(String[] args) { int[] arr = {3,4,1,5,6,2,7}; int[][] res = getNearLessNoRepeat(arr); printArr2(res); } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"}]},{"title":"Leetcode题解-栈和队列","slug":"Leetcode题解-栈和队列","date":"2021-08-02T07:38:51.000Z","updated":"2021-08-02T14:00:13.533Z","comments":true,"path":"posts/b04a.html","link":"","permalink":"https://www.colorfo.top/posts/b04a.html","excerpt":"","text":"[toc] 1.用栈实现队列栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。 public class StackForQueue { //首先准备两个栈 private Stack&lt;Integer> in = new Stack&lt;>(); private Stack&lt;Integer> out = new Stack&lt;>(); //首先将元素压入第一个栈 public void push(Integer val){ in.push(val); } //将入栈的数据弹出，压入出栈中 //在这个过程中，必须保证出栈为空 public void in2out(){ if (out.isEmpty()){ //如果出栈为空，才操作 while(!in.isEmpty()){ out.push(in.pop()); } } } //相当于一个出队列的操作 public int pop(){ //先将 入栈 中的数据 压入到出栈中，这样，经过栈的两次“先进后出”，就实现了队列的“先进先出” in2out(); return out.pop(); } //查看当前的队列的头 public int peek(){ in2out(); return out.peek(); } //判断队列是否为空 public boolean isEmpty(){ return in.isEmpty() &amp;&amp; out.isEmpty(); } //编写一个main方法测试一下结果 *********************************************** public static void main(String[] args) { StackForQueue queue = new StackForQueue(); for (int i = 1; i &lt;= 8; i++) { queue.push(i); } for (int i = 0; i &lt; 8; i++) { System.out.println(queue.pop()); } } } 2.用队列实现栈在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。 /** * 在队列这种数据结构中，最先插入的元素将是最先被删除的元素； * 反之最后插入的元素将是最后被删除的元素，因此队列又称为“先进先出”（FIFO—first in first out）的线性表。 * * Queue用法小结： * Queue使用时要尽量避免Collection的add()和remove()方法， * 而是要使用offer()来加入元素，使用poll()来获取并移出元素。 * 它们的优点是通过返回值可以判断成功与否。 * 而add()和remove()方法在失败的时候会抛出异常。 * 如果要使用前端而不移出该元素，使用element()或者peek()方法。 */ public class QueueForStack { private Queue&lt;Integer> queue; public QueueForStack(){ //LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用 queue = new LinkedList&lt;>(); } public void push(int val){ //首先将val加入到队列中，此时，val位于队列的最后一位 queue.offer(val); //获取队列的大小 int count = queue.size(); while (count > 1){ //将当前队列的除val之外的所有元素，先取出队列，再放入队列 //此时，val就位于队列的首位，那么，就实现了栈的“后进先出” queue.offer(queue.poll()); count--; } } public int pop(){ return queue.poll(); } public int peek(){ //查看当前的队列头 return queue.peek(); } public boolean isEmpty(){ return queue.isEmpty(); } //编写一个main方法，测试一下 ***************************************** public static void main(String[] args) { QueueForStack queue = new QueueForStack(); for (int i = 1; i &lt;= 8; i++) { queue.push(i); } for (int i = 0; i &lt; 8; i++) { System.out.println(queue.pop()); } } } 3.最小值栈：设计一个有getMin功能的栈 题目：实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作 要求： 1.pop,push,getMin操作的时间复杂度都是O(1) 设计的栈类型可以使用现成的栈结构 思路分析：在设计时，使用两个栈，一个栈用来保存所有的元素，其功能和一个正常的栈没有区别，这个栈记为dataStack. 另一个用来保存每一步的最小值，这个栈的栈针始终指向当前放入栈中元素的最小值，这个栈记为minStack. 代码实现 public class MyMinStack { private Stack&lt;Integer> dataStack; private Stack&lt;Integer> minStack; public MyMinStack(){ dataStack = new Stack&lt;>(); minStack = new Stack&lt;>(); } public void push(int data){ dataStack.push(data); //当minStack为空时，放入data if (minStack.isEmpty()){ minStack.push(data); }else { //当minStack不为空时,如果minStack的栈顶元素大于data时， // 将data放入minStack,此时就能保证,minStack的栈顶元素为dataStack的最小值 if(minStack.peek() > data){ minStack.push(data); } } } public int pop(){ if (dataStack.isEmpty()){ throw new RuntimeException(\"Your Stack is empty!!!\"); } return dataStack.pop(); } public int getMin(){ if (minStack.isEmpty()){ throw new RuntimeException(\"Your Stack is empty!\"); } return minStack.peek(); } public boolean isEmpty(){ return dataStack.isEmpty(); } //编写一个main测试一下****************************************** public static void main(String[] args) { MyMinStack stack = new MyMinStack(); stack.push(1); stack.push(3); stack.push(5); stack.push(2); stack.push(2); stack.push(4); stack.push(1); stack.push(8); stack.push(2); System.out.println(stack.getMin()); //1 } } ​ 对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。 4. 用栈实现括号的匹配（Easy）力扣 case1: Input:\"()[]{}\" Output : true case2: Input:\"({})\" Output : true 代码实现 /** * 用栈实现括号的匹配 * * Input:\"()[]{}\" * * Output : true */ public class ValidParentheses { private Stack&lt;Character> stack = new Stack&lt;>(); public boolean isValid(String s){ for (char c : s.toCharArray()){ if (c == '(' || c == '{' || c == '['){ //当满足\"左括号\"的条件时，压入栈中 stack.push(c); }else{ //如果此时栈中还为空，则不满足条件 if (stack.isEmpty()){ return false; } //走到这一步，说明栈中不为空，此时\"c\"，满足为括号的右半部分 //此时弹栈拿出括号的坐半部分left char left = stack.pop(); //以下三个条件说明，在弹栈得到的left时,括号右半部分匹配不上，就返回false; boolean b1 = left == '(' &amp;&amp; c != ')'; boolean b2 = left == '{' &amp;&amp; c != '}'; boolean b3 = left == '[' &amp;&amp; c != ']'; if (b1 || b2 || b3){ return false; } } } return stack.isEmpty(); } //测试 ******************************* public static void main(String[] args) { ValidParentheses vp = new ValidParentheses(); System.out.println(vp.isValid(\"()\")); //true System.out.println(vp.isValid(\"()[]{}\")); //true System.out.println(vp.isValid(\"{[]}\")); //true System.out.println(vp.isValid(\"(]\")); //false System.out.println(vp.isValid(\"([)]\")); //false } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://www.colorfo.top/tags/%E9%98%9F%E5%88%97/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.colorfo.top/tags/LeetCode/"}]},{"title":"利用数组实现栈","slug":"利用数组实现栈","date":"2021-08-01T13:20:26.000Z","updated":"2021-08-01T14:51:43.284Z","comments":true,"path":"posts/c93a.html","link":"","permalink":"https://www.colorfo.top/posts/c93a.html","excerpt":"","text":"本例子利用数组实现”栈”这种数据结构，算一个栈的入门案例 栈的特点：先进后出，后进先出 在实现栈的弹栈，压栈的操作之前，要判断栈是否为空栈或满栈 数组的长度即为栈的容量 写一个ArrayForStack类，在这个类中，实现栈的弹栈、压栈等方法 public class ArrayForStack { private int maxSize; private int[] array; //栈针 private int top = -1; public ArrayForStack(){ } //有参构造方法，利用构造方法给属性赋值 public ArrayForStack(int maxSize){ this.maxSize = maxSize; this.array = new int[maxSize]; } public boolean isEmpty(){ return top == -1; } public boolean isFull(){ return top == maxSize-1; } public void push(int num) throws Exception { if (isFull()){ throw new Exception(\"栈已经满了，不能继续压栈了\"); } array[++top] = num; } public int pop() throws Exception { if (isEmpty()){ throw new Exception(\"栈已经空了，不能弹栈\"); } int temp; temp = array[top--]; return temp; } } 编写一个测试类，测试栈的方法 public class StackTest { public static void main(String[] args) throws Exception { //栈的容量 int maxSize = 6; ArrayForStack stack = new ArrayForStack(maxSize); //压栈 for (int i = 0; i &lt; maxSize; i++) { stack.push(i); //依次压入0 1 2 3 4 5 } //弹栈 for (int i = 0; i &lt; maxSize; i++) { System.out.println(stack.pop()); //依次弹出5 4 3 2 1 0 } } } 接下来利用上面编写的ArrayForStack类，再实现一个回文字符串判断的例子 所谓的回文字符串即为：从左往右 与 从右往左 读这个字符串，结果是一样的 比如：”aba”就是一个回文串，而:”hello”,从右往左为”olleh”,则”hello”不是一个回文串 public class TestPalindrome { public static void main(String[] args) throws Exception { System.out.println(detection(\"abcdedcba\")); //true } public static boolean detection(String str) throws Exception { int length = str.length(); ArrayForStack stack = new ArrayForStack(length); for (int i = 0; i &lt; length; i++) { stack.push(str.charAt(i)); } String newStr = \"\"; for (int i = 0; i &lt; length; i++) { if (!stack.isEmpty()){ char s = (char)stack.pop(); newStr += s; } } if (str.equals(newStr)){ return true; } return false; } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"},{"name":"数组","slug":"数组","permalink":"https://www.colorfo.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"回文","slug":"回文","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%96%87/"}]},{"title":"github高效搜索项目","slug":"github高效搜索项目","date":"2021-07-31T08:56:16.000Z","updated":"2021-07-31T09:18:54.323Z","comments":true,"path":"posts/2a1b.html","link":"","permalink":"https://www.colorfo.top/posts/2a1b.html","excerpt":"","text":"利用项目名(仓库名) 例如in:name spring boot 利用项目名+stars in:name spring boot stars:&gt;1000 利用项目名+stars+forks in:name spring boot stars:&gt;1000 forks:&gt;100 利用readme in:readme springboot 利用readme+stars in:readme springboot stars:&gt;1000 利用description in:description 微服务 利用description + language in:description 微服务 language:java 利用description + language+日期 in:description 微服务 language:java pushed:&gt;2019-9-9 点进去查看项目的：描述利用了那些技术，代码结构、最新push日期、火热程度等，查看项目的readme文档 把github用起来，多去github看开源项目","categories":[],"tags":[{"name":"github搜索","slug":"github搜索","permalink":"https://www.colorfo.top/tags/github%E6%90%9C%E7%B4%A2/"}]},{"title":"git和github的使用","slug":"git和github的使用","date":"2021-07-30T08:42:22.000Z","updated":"2021-07-31T06:57:42.597Z","comments":true,"path":"posts/ec43.html","link":"","permalink":"https://www.colorfo.top/posts/ec43.html","excerpt":"","text":"[toc] git1.Git常用命令 2.分支的操作 3.远程仓库操作 4.IDEA集成git、github 1.确保idea已经集成了git和github 2.回到idea主界面，创建一个git repository 3.将代码加入暂存区 代码加入暂存区后，文件名由红色变为蓝色 4.将代码提交至本地库 代码提交至本地库后，文件名由蓝色变为正常的白色 5.查看git的log和master信息 切换version 创建分支 6.合并分支 在hot_fix分支下，加一行代码，并提交至本地库 注意：master分支想要合并hot_fix分支，必须在master分支下merge 已经切换至master 开始合并 成功合并 备注：以上演示的为无冲突合并，如果遇到冲突合并(简单理解为：对代码做了不同的修改)，需要进行手动选择代码，然后合并 7.将代码推送至远程github仓库 7.1 使用ssh免密登陆 进入C:/Users/Administrator/.ssh文件夹，右键选择“Git Bash Here ” 在命令行输入ssh-keygen -t rsa -C 邮箱 ，连续三次回车(其中有一次问你，要不要覆盖文件) 然后输入cat id_rsa.pub ,得到其文件内容，如下图 复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys →New SSH key 新建一个SSH key 7.2新建一个远程github仓库，用来储存来自本地仓库的代码，如下图 方式二，新建github仓库 7.3push代码到github仓库 push代码的重要提示 注意： push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说， 要想 push 成功，一定要保证本地库的版本要比远程库的版本高！ 因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送！ 8 pull 拉取远程库到本地库 首先更新一下github仓库的代码，以示本地和远程的区别 9.克隆代码到本地，并利用idea打开","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.colorfo.top/tags/git/"},{"name":"github","slug":"github","permalink":"https://www.colorfo.top/tags/github/"}]},{"title":"springboot集成mybatis-plus","slug":"springboot集成mybatis-plus","date":"2021-07-28T05:05:31.000Z","updated":"2021-07-28T11:29:26.531Z","comments":true,"path":"posts/667f.html","link":"","permalink":"https://www.colorfo.top/posts/667f.html","excerpt":"","text":"本博客基于springboot-web项目，集成thymeleaf，和mybatis-plus可以实现数据的CRUD和分页显示数据功能 案例一：实现数据的CRUD 依赖及配置 1.新建一个springboot-web项目，并选中thymeleaf模板引擎 2.加入依赖 &lt;dependency> &lt;groupId>com.baomidou&lt;/groupId> &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId> &lt;version>3.4.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;/dependency> 3.配置mysql的账号密码 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&characterEncoding=UTF-8&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=mysql密码 代码详情 1.控制层代码 @Controller public class MybatisController { //自动注入业务层的StudentService @Autowired private StudentService studentService; @RequestMapping(\"/queryAll\") //请求路径 public String queryAll(Model model){ //调用业务层的方法，查询所有学生 List&lt;Student> students = studentService.list(); model.addAttribute(\"students\",students); //将查询结果放入request作用域，并返回到视图层 return \"mybatis-plus\"; } } 2.业务层代码(包括一个接口和实现类) public interface StudentService extends IService&lt;Student> { //IService&lt;T> 中的 T 是实体 } IService为mybatis-plus提供的接口，里面提供了CRUD的基本方法,我们的业务层接口需要实现IService这个接口 3.业务接口实现类 @Service public class StudentServiceImpl extends ServiceImpl&lt;StudentMapper, Student> implements StudentService { //ServiceImpl&lt;M extends BaseMapper&lt;T>, T> 中的泛型：M 是 mapper 对象，T 是实体 } StudentServiceImpl 继承了ServiceImpl，而ServiceImpl是IService 实现类，它提供了IService中方法的具体实现。我们写的业务接口实现类需要继承ServiceImpl这个类，并且要实现我们自己写的StudentService这个接口 下面给出ServiceImpl类的部分代码 //IService 实现类（ 泛型：M 是 mapper 对象，T 是实体 ） public class ServiceImpl&lt;M extends BaseMapper&lt;T>, T> implements IService&lt;T> {} 4.持久层代码 @Mapper public interface StudentMapper extends BaseMapper&lt;Student> { } StudentMapper继承了 BaseMapper这一接口，当我们编写的Mapper接口 继承该接口后，无需编写 mapper.xml 文件，即可获得CRUD功能 说明：除了在该类的上面添加@Mapper,注明这是一个持久层之外，还可以在程序的主入口添加@MapperScan注解(两个注解选择一个使用即可) 5.实体类 @TableName(\"t_student\") public class Student { @TableField(exist = false) private String email; private Integer id; private String name; private Integer age; setter and getter toString } @TableName(“t_student”)由mybatis-plus提供，作用使该实体类与对应的数据库中的表名对应，例如类Student&lt;===&gt;表t_student @TableField(exist = false)由mybatis-plus提供,作用是标注出，数据库中的表不存在该字段 5.视图层的代码(由控制层转到视图层mybatis-plus.html) &lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>查询所有学生&lt;/title> &lt;/head> &lt;body> &lt;div > &lt;table> &lt;tr> &lt;td>id&lt;/td> &lt;td>姓名&lt;/td> &lt;td>年龄&lt;/td> &lt;/tr> &lt;tr th:each=\"student:${students}\"> &lt;!--thymeleaf循环一个list--> &lt;td>[[${student.id}]]&lt;/td> &lt;!--thymeleaf的行内写法，取出相应的变量--> &lt;td>[[${student.name}]]&lt;/td> &lt;td>[[${student.age}]]&lt;/td> &lt;/tr> &lt;/table> &lt;/div> &lt;/body> &lt;/html> 6查询结果 与数据库中的数据一致 案例二：实现分页数据的展示 数据的分页展示，在案例一的基础上修改而来 分页功能具体实现 1.新建一个配置类，用来加载分页插件 @Configuration //@Deprecated public class MyBatisPlusConfig { @Bean public PaginationInterceptor paginationInterceptor() { System.out.println(\"加载分页插件\"); return new PaginationInterceptor(); } } 2.修改控制层代码 @Controller @Slf4j public class MybatisController { @Autowired private StudentService studentService; @RequestMapping(\"/queryAll\") public String queryAll(@RequestParam(value = \"pn\",defaultValue = \"1\") Integer pn, Model model){ //分页查询，pn表示当前页，6表示每页几条数据 Page&lt;Student> studentPage = new Page&lt;>(pn,6); //分页查询结果 Page&lt;Student> page = studentService.page(studentPage, null); page.getCurrent(); //获取当前页 page.getPages(); //获取总的页数 page.getTotal(); //获取总记录数 model.addAttribute(\"page\",page); return \"mybatis-plus\"; } } 访问路径为“/queryAll”,请求参数为pn,表示当前页，默认为1 调用studentService.page(),即可得到Page对象，其内部属性，就是我们想要的与分页功能相关的数据 将page放入request作用域 3.修改视图显示的代码 &lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>查询所有学生&lt;/title> &lt;/head> &lt;body> &lt;div > &lt;table> &lt;tr> &lt;td>id&lt;/td> &lt;td>姓名&lt;/td> &lt;td>年龄&lt;/td> &lt;/tr> &lt;tr th:each=\"student:${page.records}\"> &lt;!--thymeleaf循环一个list--> &lt;td>[[${student.id}]]&lt;/td> &lt;!--thymeleaf的行内写法，取出相应的变量--> &lt;td>[[${student.name}]]&lt;/td> &lt;td>[[${student.age}]]&lt;/td> &lt;/tr> &lt;/table> &lt;/div> &lt;br> &lt;!--上方展示的student详情的list集合，必须从page.records中取--> &lt;!--#########################以下内容与分页功能相关###############################--> &lt;!--[[${page.current}]]为thymeleaf的写法，可以取出request域的变量--> &lt;!--page.current、page.pages、page.total都是放在request作用域中的变量page的属性}--> &lt;div>当前第 [[${page.current}]] 页 总计 [[${page.pages}]] 页 共 [[${page.total}]] 条记录&lt;/div> &lt;div> &lt;ul> &lt;!--#numbers.sequence(1,page.pages)，该表达式是thymeleaf的写法。 表示可以生成一个从\"1\"到\"page.pages\"的序列,然后用thymeleaf的foreach循环，就可以得到页码num了--> &lt;li th:each=\"num:${#numbers.sequence(1,page.pages)}\" > &lt;!--下面的写法为thymeleaf的超链接写法 [[${num}]]用来显示页码数 @{/queryAll(pn=${num})}表示超链接的链接地址,(pn=${num})表示请求参数 @{/queryAll(pn=${num})}等价于@{/queryAll?pn=num} --> &lt;a th:href=\"@{/queryAll(pn=${num})}\">[[${num}]]&lt;/a> &lt;/li> &lt;/ul> &lt;/div> &lt;/body> &lt;/html> 前端分页功能代码的说明见注释 结果展示","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/tags/springboot/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://www.colorfo.top/tags/mybatis-plus/"},{"name":"分页","slug":"分页","permalink":"https://www.colorfo.top/tags/%E5%88%86%E9%A1%B5/"}]},{"title":"springboot定制化组件的方式","slug":"springboot定制化组件的方式","date":"2021-07-27T11:58:08.000Z","updated":"2021-07-27T12:17:50.877Z","comments":true,"path":"posts/4e7c.html","link":"","permalink":"https://www.colorfo.top/posts/4e7c.html","excerpt":"","text":"定制化组件的常见方式 修改配置文件； xxxxxCustomizer； 编写自定义的配置类 xxxConfiguration；+ @Bean替换、增加容器中默认组件；视图解析器 Web应用 编写一个配置类实现 WebMvcConfigurer 即可定制化web功能；(+ @Bean给容器中再扩展一些组件,可选的) @Configuration public class AdminWebConfig implements WebMvcConfigurer{} @EnableWebMvc + WebMvcConfigurer —— @Bean 可以全面接管SpringMVC，所有规则全部自己重新配置； 实现定制和扩展功能 原理 1、WebMvcAutoConfiguration 默认的SpringMVC的自动配置功能类。静态资源、欢迎页….. 2、一旦使用 @EnableWebMvc 会 @Import(DelegatingWebMvcConfiguration.class) 3、DelegatingWebMvcConfiguration 的 作用，只保证SpringMVC最基本的使用 把所有系统中的 WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer 合起来一起生效 自动配置了一些非常底层的组件。RequestMappingHandlerMapping、这些组件依赖的组件都是从容器中获取 public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport 4、WebMvcAutoConfiguration 里面的配置要能生效 必须 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 5、@EnableWebMvc 导致了 WebMvcAutoConfiguration 没有生效。","categories":[],"tags":[{"name":"springboot定制化组件","slug":"springboot定制化组件","permalink":"https://www.colorfo.top/tags/springboot%E5%AE%9A%E5%88%B6%E5%8C%96%E7%BB%84%E4%BB%B6/"}]},{"title":"SpringBoot文件上传","slug":"SpringBoot文件上传","date":"2021-07-27T07:56:20.000Z","updated":"2021-08-01T08:31:15.837Z","comments":true,"path":"posts/c59d.html","link":"","permalink":"https://www.colorfo.top/posts/c59d.html","excerpt":"","text":"[toc] 简介 springboot中文件上传，可以将上传的文件保存到本地，或者保存到文件服务器，OSS 下面通过一个springboot-thymeleaf项目，演示这一过程 项目流程 1.浏览器地址栏访问：http:localhost:8080/,跳转到templates/file_form.html 2.在file_form.html页面，选择需要上传的文件(支持单个、多个文件上传，文件的最大值在配置文件中指定)，提交后转到控制层的upload方法 3.在upload方法中，上传的文件被保存到本地 代码演示 项目文件结构 控制层代码 @Controller public class MyController { @RequestMapping(\"/\") public String upload(){ return \"file_form\"; } @PostMapping(\"/upload\") @ResponseBody public String upload(@RequestPart(\"picture\") MultipartFile picture, @RequestPart(\"photos\") MultipartFile[] photos) throws IOException { if(!picture.isEmpty()){ String originalFilename = picture.getOriginalFilename(); //保存文件到本地 picture.transferTo(new File(\"E:\\\\test\\\\\"+originalFilename)); } if (photos.length > 0){ for (MultipartFile photo : photos) { if (!photo.isEmpty()){ String originalFilename = photo.getOriginalFilename(); //保存文件到本地 photo.transferTo(new File(\"E:\\\\test\\\\\"+originalFilename)); } } } return \"文件上传成功\"; } } 前端的file_form.html页面 &lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;form method=\"post\" th:action=\"@{/upload}\" enctype=\"multipart/form-data\" > 单个文件:&lt;input type=\"file\" name=\"picture\">&lt;br> 多个文件:&lt;input type=\"file\" name=\"photos\" multiple>&lt;br/> &lt;input type=\"submit\" value=\"提交\"> &lt;/form> &lt;/body> &lt;/html> 项目的配置文件 # 上传总文件的最大值 spring.servlet.multipart.max-request-size=100MB # 单个文件的最大值 spring.servlet.multipart.max-file-size=10MB 启动程序 @SpringBootApplication public class SpringbootFileUploadApplication { public static void main(String[] args) { SpringApplication.run(SpringbootFileUploadApplication.class, args); } }","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://www.colorfo.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"Interceptor拦截器的使用","slug":"Interceptor拦截器的使用","date":"2021-07-26T13:43:47.000Z","updated":"2021-07-26T14:37:16.414Z","comments":true,"path":"posts/ce45.html","link":"","permalink":"https://www.colorfo.top/posts/ce45.html","excerpt":"","text":"springboot项目中拦截器的使用 1.编写一个拦截器实现HandlerInterceptor接口 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors） 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】 1.实现HandlerInterceptor接口@Slf4j public class MyInterceptor implements HandlerInterceptor { //目标方法执行之前，进行拦截 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(\"preHandle方法执行了{}\",request.getRequestURI()); String userName = (String) request.getSession().getAttribute(\"userName\"); if(userName != null){ return true; } request.getRequestDispatcher(\"/\").forward(request,response); return false; } //目标方法执行完成之后 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.info(\"postHandle方法执行了{}\",modelAndView); } //页面渲染之后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { log.info(\"afterCompletion方法执行了\"); } } 2.拦截器注册到容器中 实现WebMvcConfigurer的addInterceptors @Configuration public class MyConfiguration implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()) .addPathPatterns(\"/**\") //需要拦截的资源 .excludePathPatterns(\"/\",\"/login\"); //需要放行的资源 } } 3.拦截器原理1、根据当前请求，找到HandlerExecutionChain【可以处理请求的handler以及handler的所有 拦截器】 2、先来顺序执行 所有拦截器的 preHandle方法 1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle 2、如果当前拦截器返回为false。直接 倒序执行所有已经执行了的拦截器的 afterCompletion； 3、如果任何一个拦截器返回false。直接跳出不执行目标方法 4、所有拦截器的prehandler都返回true，才执行目标方法 5、倒序执行所有拦截器的postHandle方法。 6、前面的步骤有任何异常都会直接倒序触发 afterCompletion 7、页面成功渲染完成以后，也会倒序触发 afterCompletion","categories":[],"tags":[{"name":"Interceptor","slug":"Interceptor","permalink":"https://www.colorfo.top/tags/Interceptor/"}]},{"title":"springboot集成websocket实现聊天室的index.jsp代码","slug":"springboot集成websocket实现聊天室的index-jsp代码","date":"2021-07-25T06:54:58.000Z","updated":"2021-07-25T13:30:24.709Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://www.colorfo.top/posts/undefined.html","excerpt":"","text":"SpringBoot+WebSocket+JSP 在线聊天室 发送 离开 $(function () { var ws; if (\"WebSocket\" in window) { var baseUrl = 'ws://localhost:8080/websocket/'; var userName = $('#username').val(); ws = new WebSocket(baseUrl + userName); // 连通之后的回调事件，建立连接 ws.onopen = function () { console.log(\"建立 websocket 连接...\"); }; // 接收后台服务端的消息 ws.onmessage = function (event) { $('#content').append(event.data + '\\n\\n'); console.log(\"接收到服务端发送的消息...\" + event.data + '\\n'); }; ws.onerror = function (event) { console.log(\"websocket发生错误...\" + event + '\\n'); } // 连接关闭的回调事件 ws.onclose = function () { $('#content').append('[' + userName + '] 已离开!'); console.log(\"关闭 websocket 连接...\"); }; } else { // 浏览器不支持 WebSocket alert(\"您的浏览器不支持WebSocket!\"); } // 客户端发送消息到服务器 $('#toSend').click(function () { sendMsg(); }); $(document).keyup(function (event) { // 回车键事件 if (event.keyCode == 13) { sendMsg(); } }); // 发送消息 function sendMsg() { //websocket发送消息 ws.send($('#message').val()); $('#message').val(\"\"); } // 退出 $('#user_exit').click(function () { if (ws) { ws.close(); } }); });","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"}]},{"title":"springboot集成websocket实现聊天室","slug":"springboot集成websocket实现聊天室","date":"2021-07-25T04:04:39.000Z","updated":"2021-07-25T13:30:26.881Z","comments":true,"path":"posts/3a35.html","link":"","permalink":"https://www.colorfo.top/posts/3a35.html","excerpt":"","text":"1.websocket简介WebSocket协议WebSocket协议是由HTML5定义的，基于TCP协议实现的一种网络协议，通过该协议服务器可以主动向客户端发送信息； WebSocket 协议在2008年诞生，2011年成为W3C国际标准；我们已经有了 HTTP 协议，为什么出现一个websocket协议？ http协议是短连接，因为请求之后，都会关闭连接，下次重新请求数据，需要再次打开链接；WebSocket协议是一种长连接，只需要通过一次请求来初始化连接，然后所有的请求和响应都是通过这个TCP连接进行通讯； 所以HTTP协议通信只能是客户端向服务器发出请求，服务器返回响应结果，HTTP 协议做不到服务器主动向客户端推送信息，而websocket能实现服务器和客户端全双工通信； 何谓全双工 信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工，信息能够同时双向传送则称为全双工； 基本实现原理 WebSocket协议基于TCP协议实现，客户端和服务器只需要做一个握手的动作之后，形成了一条基于客户端和服务器之间的快速通道，之后客户端与服务端之间便可以进行多次数据帧双向传输；这样实现的目的是客户端和服务器进行频繁双向通信时，可以使服务器避免频繁创建HTTP连接，节约资源，提高工作效率和资源利用率。 传统Web推送实现​ 在没有WebSocket协议之前，服务器如何向浏览器端推送消息？通常的实现方式是在页面通过Ajax定时轮询，比如每隔1秒中向服务器发送一次HTTP请求，询问服务器是否有新消息，服务器返回结果；这种形式缺点很明显，浏览器需要不断的向服务器发出HTTP请求，而HTTP请求包含较长的头部，有效信息相对较少，反复的无效请求占用了大量的带宽和 CPU 资源，造成很大的浪费，所以，WebSocket 应运而生；HTML5定义的WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯； WebSocket协议本质上是一个基于TCP的协议，因此与HTTP协议没有什么关系； WebSocket的特点全双工通信，客户端和服务器可以双向平等通信； 建立在TCP协议之上，服务器端的实现比较容易； 数据格式比较轻量，性能开销小，通信高效； 可以发送文本，也可以发送二进制数据； 通信具有更强的实时性； 协议标识符是ws，服务器地址就是：ws://www.abc.com/some/path http协议： http:// websocket的业务场景WebSocket聊天室； 股票实时价格显示等应用； 即时通讯、游戏、可视化大屏展示等领域； 企业内部管理通讯等功能，主要通讯协议websocket； web网页聊天、客服系统实现； 系统提醒、用户上下线提醒、客户端同步，实时数据更新，多屏幕同步，用户在线状态，消息通知，扫描二维码登录/二维码支付，弹幕、各类信息提醒，在线选座，实时监控大屏等等； Java中的WebSocket API在Java EE 7中Java语言开始支持websocket协议，Java EE 7中定义了一套Websocket API规范，也就是一系列接口，没有实现，位于包javax.websocket下，包含客户端API和服务端API，WebSocket的Java API 只是规范，具体实现需要web容器（比如tomcat就实现了Java websocket api）、Java EE服务器或者框架提供； 在java中服务端的实现 1、Tomcat：java中的websocket实现，需要tomcat 7.0.47+以上才支持， Java EE7的支持； 2、Spring的websocket，需要Spring 4.x，所以springboot也可以用； 2.Websocket开发相关注解及API方法websocket注解 @ServerEndpoint(“/websocket/{uid}”) 申明这是一个websocket服务； 需要指定访问该服务的地址，在地址中可以指定参数，需要通过{}进行占位； @OnOpen 用法：public void onOpen(Session session, @PathParam(\"uid\") String uid) throws IOException{} 该方法将在建立连接后执行，会传入session对象，就是客户端与服务端建立的长连接通道，通过@PathParam获取url中声明的参数； @OnClose 用法：public void onClose() {} 该方法是在连接关闭后执行； @OnMessage 用法：public void onMessage(String message, Session session) throws IOException {} 该方法用于接收客户端发送的消息； message：发来的消息数据； session：会话对象（也是长连接通道）； 发送消息到客户端； 用法：session.getBasicRemote().sendText(\"hello,websocket.\"); 通过session进行消息发送； 前端技术对websocket的支持Websocket是html5规范，主流浏览器都支持；（某些老浏览器不支持） jQuery、vueJS、React JS、angularjs等都可以支持webscoket对象； 底层是javascript支持的一个webscoket的js对象，通过这个对象可以建立websocket的连接：ws://localhost:8080/websocket/12345 WebSocket有很多优点，弥补了http协议的不足，但是如果服务端维护很多长连接也是很耗费资源的，服务器集群带来了复杂性以及存在老版本浏览器兼容性问题，各大厂目前大多数还是基于轮询的方式实现的，比如：扫码登录、支付成功通知、秒杀成功通知等； 在秒杀场景中，用轮询即可，前端轮询一般不可能穿透到后端数据库查询，一般是采用高性能的缓存标记来判定秒杀是否成功，相对于websocket长连接以及其不确定因素，轮询依然是相对比较合适的方案； Websocket各浏览器的支持情况： https://caniuse.com/#search=websocket 3.springboot集成WebSocket实现多人聊天室 项目代码结构分布 pom文件依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.5.2&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;!--此项目的GAV坐标--> &lt;groupId>com.bjpowernode&lt;/groupId> &lt;artifactId>041-springboot-websocket&lt;/artifactId> &lt;version>1.0.0&lt;/version> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;/properties> &lt;dependencies> &lt;!--springboot web项目的起步依赖--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;!--spring-boot-starter-websocket--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-websocket&lt;/artifactId> &lt;/dependency> &lt;!--lombok,需要在IDEA中安装lombok插件才能使用该依赖--> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;/dependency> &lt;!--引入Spring Boot内嵌的Tomcat对JSP的解析包--> &lt;dependency> &lt;groupId>org.apache.tomcat.embed&lt;/groupId> &lt;artifactId>tomcat-embed-jasper&lt;/artifactId> &lt;/dependency> &lt;!--热部署插件(该依赖不是必选项)--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;resources> &lt;!--src/main/java下的.xml配置文件编译到target下去--> &lt;resource> &lt;directory>src/main/java&lt;/directory> &lt;includes> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;/resource> &lt;!--src/main/resources下的配置文件编译到target下去--> &lt;resource> &lt;directory>src/main/resources&lt;/directory> &lt;includes> &lt;include>**/*.*&lt;/include> &lt;/includes> &lt;/resource> &lt;!--src/main/webapp下的jsp页面编译到META-INF/resources下才能访问--> &lt;resource> &lt;directory>src/main/webapp&lt;/directory> &lt;targetPath>META-INF/resources&lt;/targetPath> &lt;includes> &lt;include>**/*.*&lt;/include> &lt;/includes> &lt;/resource> &lt;/resources> &lt;/build> &lt;/project> 前端代码 项目的主配置文件application.properties #设置jsp文件的前缀和后缀 spring.mvc.view.prefix=/ spring.mvc.view.suffix=.jsp index.jsp文件详情 hexo博客不能正常显示jsp格式的代码 代码详情见本站的博文：\"springboot集成websocket实现聊天室的index-jsp代码\"， 进入该博文页面后，点击右键即可查看index.jsp的源代码 还需要一个jquery.min.js文件，可以去网上下载 后端代码 后端代码结构 首先是endpoint包下的chatServerEndpoint.java 文件 package com.bjpowernode.endpoint; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import javax.websocket.*; import javax.websocket.server.PathParam; import javax.websocket.server.ServerEndpoint; import java.io.IOException; /** * 说明： * 1、@ServerEndpoint注解中指定WebSocket协议的地址； * 2、@OnOpen、@OnMessage、@OnClose、@OnError注解与WebSocket中监听事件对应 * **/ @Slf4j //lombok jar包，帮我们自动生成一些代码：@Data @Component @ServerEndpoint(\"/websocket/{username}\") public class ChatServerEndpoint { /** * 连接建立时触发 */ @OnOpen public void openSession(@PathParam(\"username\") String username, Session session) { log.info(\"用户{}登录\", username); String message = \"用户[\" + username + \"] 已进入聊天室！\"; // 发送登录消息给其他人 WebSocketUtils.sendMessageAll(message); // 获取当前在线人数，发给自己 String onlineInfo = WebSocketUtils.getOnlineInfo(); //发送消息 WebSocketUtils.sendMessage(session, onlineInfo); // 添加自己到map中 WebSocketUtils.CLIENTS.put(username, session); } /** * 客户端接收服务端数据时触发 */ @OnMessage public void onMessage(@PathParam(\"username\") String username, String message) { log.info(\"发送消息：{}, {}\", username, message); //广播，把消息同步给其他客户端 WebSocketUtils.sendMessageAll(\"[\" + username + \"] : \" + message); } /** * 连接关闭时触发 */ @OnClose public void onClose(@PathParam(\"username\") String username, Session session) { // 当前的Session移除某个用户 WebSocketUtils.CLIENTS.remove(username); // 离开消息通知所有人 WebSocketUtils.sendMessageAll(\"[\" + username + \"] 已离开！\"); try { //关闭WebSocket Session会话 session.close(); log.info(\"{} 已退出, onclose\", username); } catch (IOException e) { e.printStackTrace(); log.error(\"onClose error\", e); } } /** * 通信发生错误时触发 */ @OnError public void onError(Session session, Throwable throwable) { try { //关闭WebSocket Session会话 session.close(); } catch (IOException e) { e.printStackTrace(); log.error(\"onError Exception\", e); } log.info(\"Throwable msg \" + throwable.getMessage()); } } endpoint包下的WebSocketUtils.java 文件 package com.bjpowernode.endpoint; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import javax.websocket.RemoteEndpoint; import javax.websocket.Session; import java.io.IOException; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public final class WebSocketUtils { private static final Logger logger = LoggerFactory.getLogger(WebSocketUtils.class); /** * 存储WebSocket session * &lt;p> * 用户名为key，WebSocket Session对象为value */ public static final Map&lt;String, Session> CLIENTS = new ConcurrentHashMap&lt;>(); /** * 使用连接发送数据 * * @param session 用户session * @param message 发送内容 */ public static void sendMessage(Session session, String message) { if (session == null) { return; } final RemoteEndpoint.Basic basic = session.getBasicRemote(); if (basic == null) { return; } try { //发送 basic.sendText(message); } catch (IOException e) { e.printStackTrace(); logger.error(\"sendMessage IOException \", e); } } /** * 发送消息给其他所有人 * * @param message */ public static void sendMessageAll(String message) { CLIENTS.forEach((sessionId, session) -> sendMessage(session, message)); } /** * 获取所有在线用户 */ public static String getOnlineInfo() { Set&lt;String> userNames = CLIENTS.keySet(); if (userNames.size() == 0) { return \"当前无人在线...\"; } return CLIENTS.keySet().toString() + \"在线\"; } } 接着是controller包下的ChatController.java文件 package com.bjpowernode.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import java.util.concurrent.atomic.AtomicInteger; @Controller public class ChatController { private AtomicInteger idProducer = new AtomicInteger(); @RequestMapping(\"/\") public String index(Model model) { model.addAttribute(\"username\",\"user\" + idProducer.getAndIncrement()); return \"index\"; } } 项目启动后，访问根路径，转发到index.jsp 最后是config包下的WebSocketConfig.java文件 package com.bjpowernode.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.config.annotation.EnableWebSocket; import org.springframework.web.socket.server.standard.ServerEndpointExporter; @EnableWebSocket //启用WebSocket支持 @Configuration //表示配置类 public class WebSocketConfig { /** * 配置ServerEndpointExporter的bean * * 该Bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint */ @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } 最后的最后，是程序的主入口Application.java，用来启动整个项目 package com.bjpowernode; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 项目启动运行 在浏览器地址栏输入http://localhost:8080/ 示例如下 在另一个浏览器地址栏(或者相同浏览器新建一个窗口)输入http://localhost:8080/，即可实现多人聊天","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"}]},{"title":"springboot之-MatrixVariable注解使用","slug":"springboot之-MatrixVariable注解使用","date":"2021-07-24T14:51:43.000Z","updated":"2021-07-24T14:53:39.425Z","comments":true,"path":"posts/80aa.html","link":"","permalink":"https://www.colorfo.top/posts/80aa.html","excerpt":"","text":"简介​ 根据 URI 规范 RFC 3986 中 URL 的定义，路径片段中可以可以包含键值对。规范中没对对应的术语。一般 “URL 路径参数” 可以被应用，尽管更加独特的 “矩阵 URI” 也经常被使用并且相当有名。在 Spring MVC 它被称为矩阵变量。 矩阵变量可以出现在任何路径片段中，每一个矩阵变量都用分号（;）隔开。比如 /cars;color=red;year=2012。多个值可以用逗号隔开，比如color=red,green,blue，或者分开写 color=red;color=green;color=blue。 如果你希望一个 URL 包含矩阵变量，那么请求映射模式必须用 URI 模板来表示这些矩阵变量。这样的话，不管矩阵变量顺序如何，都能够保证请求可以正确的匹配。 Springboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。 下面用一个springboot项目演示 @MatrixVariable的具体使用方法 1.前端代码部分 项目的结构分布 前端index.html的代码如下 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>springboot注解之@MatrixVariable&lt;/title> &lt;/head> &lt;body> &lt;h1>springboot注解之@MatrixVariable&lt;/h1>&lt;br/> &lt;a href=\"/car/sell;num=10;brand=BYD,AuDi\">@MatrixVariable（矩阵变量）/car/{sell}&lt;/a> &lt;br/> &lt;a href=\"/boss/1;age=20/2;age=30\">@MatrixVariable（矩阵变量）/boss/{bossId}/{empId}&lt;/a> &lt;/body> &lt;/html> ​ 1.在/car/sell路径下访问，请求参数为num和brand 2.在/boss/{bossId}/{empId}路径下访问.请求参数age=20表示/boss/bossId?age=20. 而请求参数age=30则表示访问路径/boss/bossId/empId?age=30 2.后端代码部分2.1 配置类MyConfig.javaSpringboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。 package com.bjpowernode.springboot.conf; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.PathMatchConfigurer; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import org.springframework.web.util.UrlPathHelper; @Configuration(proxyBeanMethods = false) public class MyConfig implements WebMvcConfigurer{ @Override public void configurePathMatch(PathMatchConfigurer configurer) { UrlPathHelper urlPathHelper = new UrlPathHelper(); urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); } } 2.2 控制器AnnotationController.javapackage com.bjpowernode.springboot.web; import org.springframework.web.bind.annotation.*; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController public class AnnotationController { @RequestMapping(\"/car/{path}\") public Map getCar(@MatrixVariable(\"num\") Integer num, @MatrixVariable(\"brand\") List&lt;String> brand, @PathVariable(\"path\") String path){ Map&lt;String,Object> map = new HashMap&lt;>(); map.put(\"num\",num); map.put(\"brand\",brand); map.put(\"path\",path); return map; } @GetMapping(\"/boss/{bossId}/{empId}\") public Map getAge(@PathVariable(\"bossId\") Integer bossId, @PathVariable(\"empId\") Integer empId, @MatrixVariable(value = \"age\",pathVar = \"bossId\") Integer bossAge, @MatrixVariable(value = \"age\",pathVar = \"empId\") Integer empAge){ Map&lt;String,Object> map = new HashMap&lt;>(); map.put(\"bossId\",bossId); map.put(\"empId\",empId); map.put(\"bossAge\",bossAge); map.put(\"empAge\",empAge); return map; } } 2.3 主程序入口package com.bjpowernode.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class SpringbootAnnotationApplication { public static void main(String[] args) { SpringApplication.run(SpringbootAnnotationApplication.class, args); } } 3.结果演示 启动主程序SpringbootAnnotationApplication，在浏览器地址栏输入：http://localhost:8080/,可以得到如下页面 点击第一个链接，得到如下结果 点击第二个链接，得到如下结果","categories":[{"name":"springboot注解","slug":"springboot注解","permalink":"https://www.colorfo.top/categories/springboot%E6%B3%A8%E8%A7%A3/"}],"tags":[{"name":"MatrixVariable","slug":"MatrixVariable","permalink":"https://www.colorfo.top/tags/MatrixVariable/"}]},{"title":"markdown语法的使用、博文标题的使用","slug":"markdown语法的使用、博文标题的使用","date":"2021-06-19T07:40:00.000Z","updated":"2021-08-01T08:18:17.177Z","comments":true,"path":"posts/9892.html","link":"","permalink":"https://www.colorfo.top/posts/9892.html","excerpt":"","text":"[TOC] 关于博文的Front-matter的使用 Front-matter中的内容为非必填项，但建议至少填写title和date 最全示例 --- title: 基于 Hexo GitHub 从零开始搭建个人博客 date: 2019-12-30 09:25:00 author: Sitoi img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Hexo keywords: Hexo GitHub blog tags: - Hexo - Blog - GitHub --- 转载自:https://sitoi.cn/posts/63466.html markdown 的基本语法1.斜体和粗体1. *斜体*或者_斜体_ 2. **粗体** 3. ***加粗斜体*** 4. ~~删除线~~ 显示效果： 斜体或者_斜体_ 粗体 加粗斜体 删除线 2.分级标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 3.超链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。 3.1 行内式 介绍：[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。 示例： 1. 欢迎访问[我的博客](www.colorfo.top) 2. 欢迎访问[我的博客](www.colorfo.top \"colorfo\") 欢迎访问我的博客 欢迎访问我的博客 3.2 参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明：参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3] [Leanote 笔记][2]是一个不错的[网站][]。 [1]:http://www.google.com \"Google\" [2]:http://www.leanote.com \"Leanote\" [3]:http://www.colorfo.top \"自己的博客\" [网站]:http://http://blog.leanote.com/freewalk 显示效果： 我经常去的几个网站Google、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 更多内容请参考—&gt;原文链接：https://blog.csdn.net/witnessai1/article/details/52551362","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.colorfo.top/tags/markdown/"},{"name":"front-matter","slug":"front-matter","permalink":"https://www.colorfo.top/tags/front-matter/"}],"author":"QianJL"},{"title":"hexo博客的启动和部署","slug":"hexo博客的启动和部署","date":"2021-06-02T08:12:23.000Z","updated":"2021-06-03T11:29:48.212Z","comments":true,"path":"posts/be0d.html","link":"","permalink":"https://www.colorfo.top/posts/be0d.html","excerpt":"","text":"本篇博客主要记录hexo博客的启动和部署启动hexo博客 在blog文件夹下，输入cmd,进入Windows的命令提示行窗口 输入”hexo server”即可启动 hexo 博客 打开浏览器，输入地址：http://localhost:4000,即可从本地访问hexo博客 添加部署信息 在_config.yml文件中操作(_config.yml文件的最下面修改)，可以将博客部署到github或者gitee 例如我的设置为： deploy: type: git repo: https://gitee.com/ColorQian/ColorQian.git branch: master 修改好配置后，运行如下命令，将代码部署到gitee hexo clean hexo generate hexo deploy 在gitee的Gitee Pages 页面更新部署 在浏览器地址栏输入：http://colorqian.gitee.io 即可访问博客","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.colorfo.top/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-04-15T08:12:23.000Z","updated":"2021-06-03T09:23:14.311Z","comments":true,"path":"posts/3d22.html","link":"","permalink":"https://www.colorfo.top/posts/3d22.html","excerpt":"","text":"关于我姓名：钱佳乐😄来自南京理工大学你可以通过邮箱联系我：qjl@njust.edu.cn 关于这个博客网站网站名：”http://colorqian.gitee.io\"我将会不定期的在这个网站上发布一些关于java的文章 技术支持程序羊","categories":[],"tags":[]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"},{"name":"springboot注解","slug":"springboot注解","permalink":"https://www.colorfo.top/categories/springboot%E6%B3%A8%E8%A7%A3/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"https://www.colorfo.top/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://www.colorfo.top/tags/%E9%98%9F%E5%88%97/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.colorfo.top/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://www.colorfo.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"回文","slug":"回文","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%96%87/"},{"name":"github搜索","slug":"github搜索","permalink":"https://www.colorfo.top/tags/github%E6%90%9C%E7%B4%A2/"},{"name":"git","slug":"git","permalink":"https://www.colorfo.top/tags/git/"},{"name":"github","slug":"github","permalink":"https://www.colorfo.top/tags/github/"},{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/tags/springboot/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://www.colorfo.top/tags/mybatis-plus/"},{"name":"分页","slug":"分页","permalink":"https://www.colorfo.top/tags/%E5%88%86%E9%A1%B5/"},{"name":"springboot定制化组件","slug":"springboot定制化组件","permalink":"https://www.colorfo.top/tags/springboot%E5%AE%9A%E5%88%B6%E5%8C%96%E7%BB%84%E4%BB%B6/"},{"name":"文件上传","slug":"文件上传","permalink":"https://www.colorfo.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"Interceptor","slug":"Interceptor","permalink":"https://www.colorfo.top/tags/Interceptor/"},{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"},{"name":"MatrixVariable","slug":"MatrixVariable","permalink":"https://www.colorfo.top/tags/MatrixVariable/"},{"name":"markdown","slug":"markdown","permalink":"https://www.colorfo.top/tags/markdown/"},{"name":"front-matter","slug":"front-matter","permalink":"https://www.colorfo.top/tags/front-matter/"},{"name":"博客","slug":"博客","permalink":"https://www.colorfo.top/tags/%E5%8D%9A%E5%AE%A2/"}]}