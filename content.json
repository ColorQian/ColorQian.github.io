{"meta":{"title":"color","subtitle":null,"description":"一个记录学习经历与分享技术的地方!","author":"QianJL","url":"https://www.colorfo.top","root":"/"},"pages":[{"title":"关于我","date":"2021-06-03T04:25:30.000Z","updated":"2021-08-10T12:18:48.663Z","comments":true,"path":"about/index.html","permalink":"https://www.colorfo.top/about/index.html","excerpt":"","text":"基本信息 😘 昵称 : color 🌇 城市 : 南京 🎓 学历 : 硕士在读 💪 我努力的方向 : java后端 🏀 爱好 : 篮球 | 跑步 | 羽毛球 | 乒乓球等 联系我 QQ : 1255574204 ✉ : qjl@njust.edu.cn"},{"title":"404","date":"2021-06-02T08:41:10.000Z","updated":"2021-06-03T06:11:32.904Z","comments":true,"path":"404.html","permalink":"https://www.colorfo.top/404.html","excerpt":"","text":""},{"title":"分类","date":"2018-09-30T09:25:30.000Z","updated":"2021-08-10T12:19:21.064Z","comments":true,"path":"categories/index.html","permalink":"https://www.colorfo.top/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-06-03T05:14:00.000Z","updated":"2021-08-10T12:19:39.398Z","comments":true,"path":"contact/index.html","permalink":"https://www.colorfo.top/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"友链","date":"2021-08-11T04:08:26.000Z","updated":"2021-08-11T04:54:56.517Z","comments":true,"path":"link/index.html","permalink":"https://www.colorfo.top/link/index.html","excerpt":"","text":""},{"title":"友链","date":"2018-12-12T13:25:30.000Z","updated":"2021-08-10T12:20:10.959Z","comments":true,"path":"friends/index.html","permalink":"https://www.colorfo.top/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-09-30T10:23:38.000Z","updated":"2021-08-10T12:20:39.463Z","comments":true,"path":"tags/index.html","permalink":"https://www.colorfo.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数组刷题笔记","slug":"数组刷题笔记","date":"2021-08-11T12:46:27.000Z","updated":"2021-08-12T09:31:03.169Z","comments":true,"path":"posts/7dec.html","link":"","permalink":"https://www.colorfo.top/posts/7dec.html","excerpt":"","text":"1.数组的二分查找 题目 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1 123输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 代码实现 12345678910111213141516171819202122232425262728293031323334353637public class BinarySearch { //二分查找 public int binarySearch(int[] nums,int target){ //先判断要查找的值是否在数组的范围内 if(target &lt; nums[0] || target &gt; nums[nums.length-1]){ return -1; } int left = 0; int right = nums.length-1; while (left &lt;= right){ int middle = (left+right)/2; if (nums[middle] == target){ return middle; }else if (target &lt; nums[middle]){ //如果要查找的值在左边 right = middle - 1; }else { //如果要查找的值在右边 left = middle+1; } } return -1; } //----------main------------- public static void main(String[] args) { BinarySearch binarySearch = new BinarySearch(); int[] arr = {-1,0,3,5,9,12}; int target = 4; int res = binarySearch.binarySearch(arr,target); System.out.println(res); }} 参考：代码随想录 2.移除数组中的元素题目链接 题目 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。 元素的顺序可以改变，你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 ​ 你不需要考虑数组中超出新长度后面的元素。 方法一：暴力求解 思路分析 这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。 代码实现 123456789101112131415161718192021222324252627282930313233343536public class RemoveElement { /**暴力移除数组的元素 * * @param arr 输入的数组 * @param val 要移除的元素 * @return 返回新的数组的长度 */ public int removeElement(int[] arr,int val){ int size = arr.length; for (int i = 0; i &lt; arr.length; i++) { //如果找到要删除的值,就利用一个for循环,将下标i后面的值统统后移 if (arr[i] == val){ for (int j = i+1; j &lt; arr.length; j++) { arr[j-1] = arr[j]; } i--; // 因为此时i后面的值后移了，i位置上是新的值，所以i要减去1 //这样下一次循环时(i++)，i上的值相当于原先i位置上的下一个 size--; } } return size; } //--------main------------ public static void main(String[] args) { RemoveElement remove = new RemoveElement(); int[] arr = {1,2,3,4,6,6}; int length = remove.removeElement(arr, 2); for (int i = 0; i &lt; length; i++) { System.out.println(arr[i]); } }} 方法二：双指针法 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 代码实现 12345678910111213141516171819202122public class RemoveElement2 { public int removeElement(int[] nums,int val){ int slowIndex = 0; for (int fastIndex = 0; fastIndex &lt; nums.length; fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } public static void main(String[] args) { RemoveElement2 remove = new RemoveElement2(); int[] arr = {0,1,2,3,3,0,4,2}; int length = remove.removeElement(arr, 2); for (int i = 0; i &lt; length; i++) { System.out.println(arr[i]); } }} 3.有序数组的平方 题目 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 思路：双指针法 数组其实是有序的， 只不过负数平方之后可能成为最大数了。 那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。 此时可以考虑双指针法了，i指向起始位置，j指向终止位置。 定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。 如果A[i] * A[i] &lt; A[j] * A[j] 那么result[k--] = A[j] * A[j]; 如果A[i] * A[i] &gt;= A[j] * A[j] 那么result[k--] = A[i] * A[i]; 代码详情 1234567891011121314151617181920212223242526272829303132public class SquareOfSortArray { public int[] sortedSquare(int[] arr){ int[] res = new int[arr.length]; int k = arr.length-1; int left = 0; int right = arr.length-1; while (left &lt;= right){ if (arr[right]*arr[right] &gt; arr[left]*arr[left]){ res[k--] = arr[right]*arr[right]; right--; }else { res[k--] = arr[left]*arr[left]; left++; } } return res; } //--------main------ public static void main(String[] args) { SquareOfSortArray sortArray = new SquareOfSortArray(); int[] arr = {-4,-1,2,3,10}; int[] square = sortArray.sortedSquare(arr); for (int i : square) { System.out.println(i); } }} 参考：代码随想录 4.长度最小的子数组题目链接 题目 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 示例： 输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 方法一：暴力解法 代码详情 这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2) 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 长度最小的子数组 */public class MinSubArrayLen { /** 暴力求解，利用两个for循环 * * @param nums 输入的数组 * @param s 要求子数组的和 &gt;= s * @return 返回子数组的长度 */ public int minSubArrayLen(int[] nums,int s){ int result = Integer.MAX_VALUE; // 要返回的子数组的长度 int subLen = 0; // 子数组的长度，中间变量，用于比较各个子数组 int sum = 0; //用于计算子数组的和 for (int i = 0; i &lt; nums.length; i++) { //遍历数组 sum = 0; for (int j = i; j &lt; nums.length ; j++) { //j从i的位置往后累加 sum += nums[j]; if(sum &gt;= s){ subLen = j-i+1; //当累加结果sum大于等于s时，保留此时的子数组长度 result = subLen &lt; result ? subLen : result; //更新result的值 break; //跳出循环，进行下一轮 } } } return result == Integer.MAX_VALUE ? 0 : result; //如果result的值不变， // 说明为找到符合条件的子数组，则返回0 } //--------------main--------------- public static void main(String[] args) { MinSubArrayLen subArrayLen = new MinSubArrayLen(); int[] nums = {2,3,1,2,4,3}; int len = subArrayLen.minSubArrayLen(nums, 7); System.out.println(len); }} 方法二：滑动窗口 思路分析 接下来就开始介绍数组操作中另一个重要的方法：滑动窗口。 所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。 这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程： 最后找到 4，3 是最短距离。 其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。 在本题中实现滑动窗口，主要确定如下三点： 窗口内是什么？ 如何移动窗口的起始位置？ 如何移动窗口的结束位置？ 窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。 窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。 窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。 解题的关键在于 窗口的起始位置如何移动，如图所示： 可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。 为什么时间复杂度是O(n): 不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是$O(n)$。 代码实现 12345678910111213141516171819202122232425262728/** 滑动窗口，也可以理解为双指针 * * @param nums 输入的数组 * @param s 要求子数组的和 &gt;= s * @return 返回子数组的长度 */ public int minSubArrayLengthWindow(int[] nums,int s){ int result = Integer.MAX_VALUE; // 要返回的子数组的长度 int subLen = 0; // 子数组的长度，中间变量，用于比较各个子数组 int sum = 0; //用于计算子数组的和 int i = 0; //滑动窗口的起始位置 for (int j = 0; j &lt; nums.length; j++) { //j表示滑动窗口的终止位置 sum += nums[j]; //sum滑动窗口内保存的值 //滑动窗口的精髓 while(sum &gt;= s){ //当滑动窗口内的值大于等于s时，滑动窗口的起始位置移动 subLen = j-i+1; result = result &lt; subLen ? result : subLen; //更新result的值 sum = sum - nums[i++]; //滑动窗口内的值减去nums[i],同时，滑动窗口的起始位置右移 } } return result == Integer.MAX_VALUE ? 0 : result; //如果result的值不变， // 说明为找到符合条件的子数组，则返回0 } 转载自：代码随想录，向大佬表示感谢。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://www.colorfo.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指offer题解之链表","slug":"剑指offer题解之链表","date":"2021-08-10T04:35:34.000Z","updated":"2021-08-11T05:58:07.303Z","comments":true,"path":"posts/ae99.html","link":"","permalink":"https://www.colorfo.top/posts/ae99.html","excerpt":"","text":"返回链表中倒数最后k个结点牛客网-JZ14 题目：输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。 如果该链表长度小于k，请返回一个长度为 0 的链表。 思路分析 设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K +1个节点处，该位置就是倒数第 K 个节点。 代码实现 123456789101112131415161718//Node节点类public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 返回链表中倒数最后k个结点 * * 注意：此题中链表的头节点即为第一个有效的节点 */public class FindKthToTail { public void add(Node head,Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list(Node head) { if (head == null){ System.out.println(\"链表为空！！！\"); return; } Node cur = head; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } /**输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。 * 如果该链表长度小于k，请返回一个长度为 0 的链表。 * * @param head 输入链表的头节点 * @param k 倒数第k个 * @return 倒数第k个结点至尾节点的全部节点 的 头节点 */ public Node findKthToTail(Node head,int k){ if (head == null){ return null; } Node p1 = head; Node p2 = head; while (p1 != null &amp;&amp; k &gt; 0){ p1 = p1.next; k--; } if (k &gt; 0){ return null; } while (p1 != null){ p1 = p1.next; p2 = p2.next; } return p2; } //---------------main----------------- public static void main(String[] args) { FindKthToTail list = new FindKthToTail(); Node head = new Node(1); list.add(head,new Node(2)); list.add(head,new Node(3)); list.add(head,new Node(4)); list.add(head,new Node(5)); list.list(head); System.out.println(\"--------findKthToTail---------\"); Node newHead = list.findKthToTail(head, 3); list.list(newHead); }} 两个链表的第一个公共结点牛客网-JZ36 题目：输入两个无环的单链表，找出它们的第一个公共结点。 解题思路 设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。 当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。 核心代码 12345678public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) { ListNode l1 = pHead1, l2 = pHead2; while (l1 != l2) { l1 = (l1 == null) ? pHead2 : l1.next; l2 = (l2 == null) ? pHead1 : l2.next; } return l1;} 本题转载自：CyC2018","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.colorfo.top/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"链表刷题日记","slug":"链表刷题日记","date":"2021-08-08T08:27:43.000Z","updated":"2021-08-09T14:06:39.161Z","comments":true,"path":"posts/3568.html","link":"","permalink":"https://www.colorfo.top/posts/3568.html","excerpt":"","text":"1.在单链表中删除倒数第K个节点 题目 给定一个单链表，要求删除倒数第K个节点，并返回该节点 解答 代码详情 Node节点类 123456789101112131415161718public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 单链表类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class SingleLinkedList { private Node head = new Node(-1); public void add(Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list() { if (head.next == null) { System.out.println(\"链表为空！！！\"); return; } Node cur = head.next; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } /**在单链表中删除倒数第k个节点 * * @param lastKth 倒数第k个 * @return 删除的倒数第k个节点 */ public Node removeLastKthNode(int lastKth){ Node cur = head; if (head.next == null || lastKth &lt; 1){ System.out.println(\"链表为空或者参数输入有误！！！\"); return cur; } //遍历链表，每移动一次，lathKth的值就减去1 while (cur.next != null){ cur = cur.next; lastKth--; } Node res = null; if (lastKth &gt; 0){ //lastKth的值大于链表的长度，直接返回 return cur; }else if(lastKth == 0){ // 此时，lastKth就是第一个节点 this.head = this.head.next; return this.head; }else { //如果lastKth &lt; 0 cur = this.head; while (lastKth != 0){ cur = cur.next; lastKth++; } res = cur.next; //将要删除的节点赋值给res,用来返回 cur.next = cur.next.next; } return res; } //------------------------------main----------------- public static void main(String[] args) { SingleLinkedList linkedList = new SingleLinkedList(); linkedList.add(new Node(1)); linkedList.add(new Node(2)); linkedList.add(new Node(3)); linkedList.add(new Node(4)); linkedList.add(new Node(5)); Node node = linkedList.removeLastKthNode(3); linkedList.list(); System.out.println(\"-------------\"); System.out.println(node); }} 2.单链表的反转 题目 给定一个单链表，实现单链表的反转 思路分析 代码实现 Node节点类 12345678910111213141516171819public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 反转链表类ReverseList 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ReverseList { private Node head = new Node(-1); public void add(Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list() { if (head.next == null) { System.out.println(\"链表为空！！！\"); return; } Node cur = head.next; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } /** * 反转单链表的方法 */ public void reverseList(){ if(head.next == null || head.next.next == null ){ System.out.println(\"不用反转该链表\"); return; } Node cur = head.next; Node next = null; Node newHead = new Node(-2); while(cur != null){ //遍历链表，cur为遍历到的当前节点 next = cur.next; //next 指向当前节点[cur]的下一个节点 cur.next = newHead.next; //当前节点[cur]的next域指向新的头节点的下一个节点 newHead.next = cur; //newHead的next域指向当前节点[cur] cur = next; //cur后移一位 } head.next = newHead.next; } //--------------main-------------------- public static void main(String[] args) { ReverseList reverseList = new ReverseList(); reverseList.add(new Node(1)); reverseList.add(new Node(3)); reverseList.add(new Node(2)); reverseList.add(new Node(4)); reverseList.list(); System.out.println(\"---反转后的链表---\"); reverseList.reverseList(); reverseList.list(); }} 3.判断一个链表是否为回文结构 题目 给定一个链表，请判断该链表是否为回文结构 例如： 1-&gt;2-&gt;1,返回true 1-&gt;2-&gt;2-&gt;1,返回true 1-&gt;2-&gt;3,返回false 思路分析 1.遍历链表，将链表的节点依次压入一个栈中 2.依次弹出栈中的节点，与链表中的节点作比较，如果每次比较的节点的值都相等，则为回文结构 代码实现 1234567891011121314151617//Node节点类public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 判断链表是否是回文结构 */public class IsPalindrome { private Node head = new Node(-1); public void add(Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public boolean isPalindrome(){ if (head.next == null){ System.out.println(\"链表为空！！！\"); return false; } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node cur = head.next; while (cur != null){ stack.push(cur); cur = cur.next; } cur = head.next; Node popNode = null; boolean flag = true; while (!stack.isEmpty() &amp;&amp; cur != null){ popNode = stack.pop(); if (popNode.val != cur.val){ flag = false; } cur = cur.next; } return flag; } //--------------main---------------- public static void main(String[] args) { IsPalindrome palindrome = new IsPalindrome(); palindrome.add(new Node(1)); palindrome.add(new Node(2)); palindrome.add(new Node(2)); palindrome.add(new Node(1)); boolean palindrome1 = palindrome.isPalindrome(); System.out.println(palindrome1); }} 4.删除无序链表中值重复出现的节点 题目(难度一星) 给定一个无序单链表，删除其中值重复出现的节点 例如:1-&gt;2-&gt;2-&gt;4-&gt;5-&gt;4-&gt;null,删除值重复之后的链表为：1-&gt;2-&gt;4-&gt;5-&gt;null 思路分析 1.遍历当前链表，创建Node节点cur指向当前节点，pre指向cur的前一个节点 2.生成一个哈希表，如果cur的值已经存在于哈希表中，就将当前节点删除(pre.next = cur.next) ​ 如果cur的值不存在哈希表中，将其加入到哈希表中，同时令pre = cur(为下一次遍历做准备) 代码实现 123456789101112131415161718public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 删除链表中的重复节点 */public class RemoveRepeat { private Node head = new Node(-1); public void add(Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list() { if (head.next == null) { System.out.println(\"链表为空！！！\"); return; } Node cur = head.next; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } public void removeRepeat(){ if (head.next == null){ System.out.println(\"链表为空！！！\"); return; } Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Node cur = head.next; //cur指向当前节点 Node pre = head; //cur指向当前节点的前一个节点 while (cur != null){ if (set.contains(cur.val)){ //如果哈希表中包含当前节点cur的值，就删除cur节点 pre.next = cur.next; }else { //如果不包含，则将cur节点的值加入到哈希表中 set.add(cur.val); pre = cur; //pre后移一位 } cur = cur.next; } } //-------------------main--------------------- public static void main(String[] args) { RemoveRepeat remove = new RemoveRepeat(); remove.add(new Node(1)); remove.add(new Node(2)); remove.add(new Node(2)); remove.add(new Node(4)); remove.add(new Node(5)); remove.add(new Node(4)); remove.removeRepeat(); remove.list(); }} 5.合并两个有序的单链表 题目(难度一星) 给定两个有序单链表的头节点head1,head2,请合并两个有序链表，合并后的链表依然有序，并返回合并后链表的头节点 例如： 0-&gt;2-&gt;3-&gt;7-&gt;null 1-&gt;3-&gt;5-&gt;7-&gt;9-&gt;null 合并后的链表：0-&gt;1-&gt;2-&gt;3-&gt;3-&gt;5-&gt;7-&gt;7-&gt;9-&gt;null 思路分析 1.当两个链表都不为空时，遍历两个链表，并比较链表中节点值的大小，将较小的节点加入到 新的以newHead为头节点的链表中，如果相等，则依次加入两个相等的节点。 2.若两个链表中其中一个遍历到了末尾，则把另一个链表中的节点加入到新的链表中 代码实现 12345678910111213141516171819//Node节点类public class Node { public int val; public Node next; public Node(int val){ this.val = val; } @Override public String toString() { return \"Node{\" + \"val=\" + val + '}'; }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * 合并两个有序的单链表 */public class MergeLinkedList { public void add(Node head,Node node){ Node cur = head; while (cur.next != null){ cur = cur.next; } cur.next = node; } public void list(Node head) { if (head.next == null){ System.out.println(\"链表为空！！！\"); return; } Node cur = head.next; while (cur != null) { System.out.printf(\"节点编号：%d \\n\", cur.val); cur = cur.next; } } /** * 合并两个单链表 * @param head1 第一个链表的头节点 * @param head2 第二个链表的头节点 * @return 返回新的链表的头节点 */ public Node merge(Node head1,Node head2){ if (head1.next == null &amp;&amp; head2.next == null){ System.out.println(\"两个链表为空！！！\"); return null; } Node newHead = new Node(-1); Node cur = newHead; head1 = head1.next; head2 = head2.next; while (head1 != null &amp;&amp; head2 != null){ if (head1.val &lt; head2.val){ cur.next = head1; cur = cur.next; head1 = head1.next; }else if (head2.val &lt; head1.val){ cur.next = head2; cur = cur.next; head2 = head2.next; }else { cur.next = head1; cur = cur.next; head1 = head1.next; cur.next = head2; cur = cur.next; head2 = head2.next; } } while (head1 != null){ cur.next = head1; cur = cur.next; head1 = head1.next; } while (head2 != null){ cur.next = head2; cur = cur.next; head2 = head2.next; } return newHead; } //----------------main-------------- public static void main(String[] args) { MergeLinkedList merge = new MergeLinkedList(); Node head1 = new Node(-1); Node head2 = new Node(-1); merge.add(head1,new Node(0)); merge.add(head1,new Node(2)); merge.add(head1,new Node(3)); merge.add(head1,new Node(7)); merge.add(head2,new Node(1)); merge.add(head2,new Node(3)); merge.add(head2,new Node(5)); merge.add(head2,new Node(7)); merge.add(head2,new Node(9)); Node merge1 = merge.merge(head1, head2); merge.list(merge1); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.colorfo.top/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单向环形链表之约瑟夫环","slug":"单向环形链表之约瑟夫环","date":"2021-08-07T08:38:52.000Z","updated":"2021-08-08T14:30:13.745Z","comments":true,"path":"posts/d2de.html","link":"","permalink":"https://www.colorfo.top/posts/d2de.html","excerpt":"","text":"Josephus问题: 约瑟夫问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 例如： n = 5 , 即有5个人 k = 1, 从第一个人开始报数 m = 2, 数2下 出圈的顺序 2-&gt;4-&gt;1-&gt;5-&gt;3 思路图解 构建单向环形链表 节点出圈的思路图解 代码详情 Node节点类 123456789101112131415//小孩节点类public class Boy { int no; Boy next; public Boy(int no) { this.no = no; } public Boy() { }} 下面是单向环形链表类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//单向环形链表-约瑟夫环public class SingleCircle { private Boy first; /** * 将小孩加入约瑟夫环的方法 * @param num 表示环中结点的个数 */ public void add(int num){ first = null; Boy curBoy = null; //辅助变量，用来帮助小孩进圈 for (int i = 1; i &lt;= num; i++) { Boy boy = new Boy(i); //当加入第一个小孩时，让其自己成环 if (i == 1){ first = boy; //first始终指向第一个小孩 first.next = first; curBoy = first; } //新的小孩结点的进圈操作 curBoy.next = boy; curBoy = curBoy.next; curBoy.next = first; } } //遍历圈中的小孩结点 public void list(){ if (first == null){ System.out.println(\"圈中没有小孩结点\"); return; } Boy cur = first; while (true){ System.out.printf(\"当前的小孩编号:%d \\n\",cur.no); if (cur.next == first){ break; } cur = cur.next; } } /** * 小孩出圈的方法 * @param startNo 从第几个小孩开始数 * @param count 数几次 * @param num 圈中小孩的个数 */ public void remove(int startNo,int count,int num){ if (first == null || startNo &lt; 1 || startNo &gt; num){ System.out.println(\"参数输入有误！！！\"); return; } Boy helper = first;//创建一个辅助指针，让其始终位于first指针的前一个 //先让first移动到startNo处，即开始报数的位置 for (int i = 1; i &lt;= startNo-1; i++) { first = first.next; } //再让helper 移动到first的前一位 while (helper.next != first){ helper = helper.next; } while (helper != first){ //开始报数，让helper和first移动到指定位置 for (int i = 1; i &lt;= count-1; i++) { helper = helper.next; first = first.next; } //此时first指向要移除的小孩结点 System.out.printf(\"出圈小孩的编号：%d \\n\",first.no); first = first.next; helper.next = first; } System.out.printf(\"最后出圈小孩的编号：%d \\n\",first.no); } //***************写个main方法测试一下******************* public static void main(String[] args) { SingleCircle singleCircle = new SingleCircle(); singleCircle.add(5); singleCircle.remove(1,2,5); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"约瑟夫环","slug":"约瑟夫环","permalink":"https://www.colorfo.top/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"}]},{"title":"单链表的增删改查和插入","slug":"单链表的增删改查和插入","date":"2021-08-05T07:07:50.000Z","updated":"2021-08-05T07:13:27.881Z","comments":true,"path":"posts/64b9.html","link":"","permalink":"https://www.colorfo.top/posts/64b9.html","excerpt":"","text":"本篇博文属于单链表的入门案例，包含单链表的一些基础操作:增删改查、插入 1.首先创建一个Node结点类 1234567891011121314151617181920212223public class Node { Integer id; String name; Node next; public Node() { } public Node(Integer id, String name) { this.id = id; this.name = name; } @Override public String toString() { return \"Node{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; }} 2.然后创建一个单链表类(包含了单链表的增删改查等方法) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public class SingleList { //头结点 private Node head = new Node(); //为当前单向链表添加一个结点 public void add(Node node){ //定义一个临时结点指向头结点 Node temp = head; //一直遍历链表，直到temp.next == null while (temp.next != null){ temp = temp.next; } //temp.next == null,说明找到了链表的尾部，将node加入链表中 temp.next = node; } //按照id修改链表的name public void update(Node node){ if (head.next == null){ return; } Node temp = head.next; while (temp != null){ if (temp.id == node.id){ temp.name = node.name; break; } temp = temp.next; } } //根据id删除节点 public void delete(int id){ if (head.next == null){ return; } Node temp = head; while (temp.next != null){ if (temp.next.id == id){ temp.next = temp.next.next; break; } temp = temp.next; } } //遍历链表 public void list(){ if (head.next == null){ return; } Node temp = head.next; while (temp != null){ System.out.println(temp); temp = temp.next; } } /** * 按照id编号的大小顺序插入，从小到大 * @param node */ public void insertById(Node node){ Node temp = head; boolean flag = false; while (true){ //如果temp结点的下一个为空，直接跳出循环,从这里跳出循环flag=false; if(temp.next == null){ break; } //程序走到这里，说明，temp.next != null if (node.id == temp.next.id){ flag = true; //从这里跳出循环flag = true break; }else if(node.id &lt; temp.next.id){ break; //从这里跳出循环flag = false; } //这里不用写出node.id &gt; temp.next.id的情况， //因为这种情况会一直遍历到链表的末尾，满足temp.next == null条件后，跳出循环，最后在链表末尾加上node temp = temp.next; //temp 向后移动一位，用来遍历单链表 } if (flag){ System.out.println(\"编号已经存在\"); }else { //在此处执行结点的插入操作(适用于在head结点后加结点(即temp.next == null)，以及node.id 小于 temp.next.id的情况) node.next = temp.next; temp.next = node; } } public static void main(String[] args) { SingleList list = new SingleList(); /*list.add(new Node(1,\"张三\")); list.add(new Node(2,\"lisi\")); list.update(new Node(2,\"李四\")); list.add(new Node(3,\"王五\")); list.add(new Node(4,\"赵六\")); list.delete(1); list.delete(4); list.list();*/ //*****************上面是增删改查的测试************ //*****************下面是按顺序插入的测试************ list.insertById(new Node(3,\"王3\")); list.insertById(new Node(2,\"王2\")); list.insertById(new Node(1,\"王1\")); list.insertById(new Node(5,\"王5\")); list.insertById(new Node(4,\"王4\")); list.insertById(new Node(6,\"王6\")); list.list(); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"https://www.colorfo.top/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"}]},{"title":"栈和队列刷题笔记","slug":"栈和队列刷题笔记","date":"2021-08-04T07:36:20.000Z","updated":"2021-08-04T07:36:28.354Z","comments":true,"path":"posts/f354.html","link":"","permalink":"https://www.colorfo.top/posts/f354.html","excerpt":"","text":"1.用一个栈实现另一个栈的排序 题目： ​ 一个栈中的类型为整型，现在想将该栈从顶到底按照从大到小的顺序排序，只允许申请一个栈，除此之外，可以申请新的变量，如何排序？ 思路分析： ​ 将要排序的栈记为stack,申请的辅助栈记为help，在stack上执行pop操作，弹出的元素记为cur 如果cur小于或等于help的栈顶元素，直接将cur压入help 如果cur大于help的栈顶元素，则将help中的元素逐次弹出，然后压入stack中，直到cur小于或等于help的栈顶元素，再将cur压入help栈中； 如果在help栈的弹栈过程中，help已经空了，则说明cur是当前的最大元素，则直接将cur压入help中 最后，help中的数，从栈顶到栈底为从小到大的顺序，将help中的数依次弹出压入stack中，则stack从栈顶到栈底为从大到小的顺序 难度：一星 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 用一个栈实现另一个栈的排序 */public class SortStackByStack { public static Stack sortStack(Stack&lt;Integer&gt; stack){ Stack&lt;Integer&gt; help = new Stack&lt;&gt;(); while (!stack.isEmpty()){ int cur = stack.pop(); while(!help.isEmpty() &amp;&amp; cur &gt; help.peek()){ stack.push(help.pop()); } help.push(cur); } while (!help.isEmpty()){ stack.push(help.pop()); } return stack; } public static void main(String[] args) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(2); stack.push(1); stack.push(8); stack.push(7); stack.push(3); stack.push(4); stack.push(4); stack = sortStack(stack); int size = stack.size(); for (int i = 0; i &lt; size; i++) { System.out.println(stack.pop()); } }} 2.数组中元素与下一个比它大的元素之间的距离力扣（Medium） 12Input: [73, 74, 75, 71, 69, 72, 76, 73]Output: [1, 1, 4, 2, 1, 1, 0, 0] 说明：对于此题，提供两种解法，详情见下面代码 方法一：暴力求解,时间复杂度O(N^2) 12345678910111213141516171819202122232425262728293031323334/** * 时间复杂度为O(N^2),每个位置向右遍历一下即可 */public class DailyTemperature2 { public static int[] rightWay(int arr[]){ int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) { int cur = i+1; int rightMoreIndex = 0; while (cur &lt; arr.length){ if (arr[cur] &gt; arr[i]){ res[i] = cur - i; break; } cur++; } } return res; } //写个main方法测试一下 public static void main(String[] args) { int[] arr = {73,74,75,71,69,72,76,73}; int[] res = rightWay(arr); for (int re : res) { System.out.println(re); } }} 方法二：遍历数组时，使用栈把数组的下标存起来,时间复杂度O(N) 思路分析： 123456789/** * 1.用dist数组存放距离当前位置的距离，用stack存放原始数组temperature的下标 * 2.用cur指向temperature数组的下标，pre指向stack栈的栈顶元素 * * 3.如果stack不为空，并且当前遍历的数temperature[cur] 大于 栈顶对应的数temperature[stack.peek()]， * 就将stack的栈顶元素弹出，存到pre变量中，cur - pre即为与pre的距离dist[pre].之后再将cur压入stack中。 * 4.如果stack为空，直接将cur压入stack中。 * */ 1234567891011121314151617181920212223242526272829public class DailyTemperatures { public static void main(String[] args) { int[] temperature = {73, 74, 75, 71, 69, 72, 76, 73}; int[] dist = dailyTemperatures(temperature); for (int i : dist) { System.out.print(i+\" \"); } } public static int[] dailyTemperatures(int[] temperatures) { int[] dist = new int[temperatures.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int cur = 0; cur &lt; temperatures.length; cur++) { int pre = 0; while (!stack.isEmpty() &amp;&amp; temperatures[cur] &gt; temperatures[stack.peek()]){ pre = stack.pop(); dist[pre] = cur - pre; } stack.push(cur); } return dist; }} 3.返回数组的最近邻位置（利用单调栈） 题目： 给定一个不含重复值的数组arr,找到每一个位置i左边和右边离i位置最近且值比arr[i]小的位置，返回左右位置的相应信息 举例： 123456789101112intput: arr = {3,4,1,5,6,2,7}output: { {-1,2}, {0,2}, {-1,-1}, {2,5}, {3,5}, {2,-1}, {5,-1}, } 解答：方法一 本题实现复杂度为O(N^2)的解释非常容易的，每个位置向左和向右遍历一下，总可以确定，见以下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MonotoneStack { public static int[][] rightWay(int[] arr){ int[][] res = new int[arr.length][2]; for (int i = 0; i &lt; arr.length; i++) { int leftLessIndex = -1; int rightLessIndex = -1; int cur = i-1; while (cur &gt;= 0){ if (arr[cur] &lt; arr[i]){ leftLessIndex = cur; break; } cur--; } cur = i+1; while (cur &lt; arr.length){ if (arr[cur] &lt; arr[i]){ rightLessIndex = cur; break; } cur++; } res[i][0] = leftLessIndex; res[i][1] = rightLessIndex; } return res; } public static void printArr2(int[][] arr){ for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[0].length; j++) { System.out.print(arr[i][j]+\" \"); } System.out.println(\"\"); } } public static void main(String[] args) { int[] arr = {3,4,1,5,6,2,7}; int[][] res = rightWay(arr); printArr2(res); }} 方法二：利用单调栈结构，时间复杂度为O(N) 思路分析： 12345678910111213141516171819202122232425/** * 单调栈——返回最近邻的位置 * * 准备一个栈，记为Stack&lt;integer&gt;,栈中存放的元素是数组的位置，开始stack为空，如果找到每一个位置i左边 * 和右边离i位置最近且值比arr[i]小的位置，那么需要让stack从栈顶到栈底的位置所代表的值是递减的(也就是从大到小)； * 如果找到每一个位置i左边和右边离i位置最近且值比arr[i]大的位置，那么需要让stack从栈顶到栈底的位置所代表的值是递增的。 * 本题需要解决是前者。 * 下面举例展示单调栈的使用和求解流程，以arr = {3,4,1,5,6,2,7}为例。 * 1.初始时，arr = {3,4,1,5,6,2,7},stack为空。 * 2.遍历arr数组，遍历到arr[0] = 3时，stack为空，直接将0压入stack中，此时，stack中从栈顶到栈底为{0(值为3)} * 3.遍历到arr[1]=4时，`arr[1] &gt; arr[stack.peek()]`，将1压入到stack中，此时，stack从栈顶到栈底为 * {1(值为4)，0(值为3)} * 4.遍历到arr[2] = 1时，如果将下标2压入stack中，会破坏stack从栈顶到栈底所代表的的值是递减的规律， * 那么，此时将stack的栈顶元素\"1\"弹出，位置1左边比它代表的值小的下标即为此时stack栈的栈顶元素\"0\"， * 位置1右边比它代表的值小的下标，即为当前遍历的下标\"2\"，那么res[1] = {0,2}。此时，stack从栈顶到栈底为{0(值为3)}， * 如果将下标2压入stack中，依旧会破坏stack从栈顶到栈底的元素所代表的值是递减的规律，此时将stack的栈顶元素\"0\"弹出，stack栈已经空了， * 位置0左边不存在比它小的数，默认取-1，位置0右边比它代表的值小的下标，即为当前遍历的下标\"2\"，那么res[0] = {-1,2}。 * 这时，stack为空，将\"2\"压入stack中，stack从栈顶到栈底的元素为{2(值为1)} * 5.按照此规律继续遍历下去...... * 6.遍历阶段结束后，stack从栈顶到栈底的元素为{6(值为7),5(值为2),2(值为1)}。 * 下面清算stack中剩下的元素，将stack的栈顶元素\"6\"弹出，栈中它的下面位置是5，而由于6位置是清算阶段弹出的，所以res[6] = {5,-1}; * 弹出5位置，栈中它的下面位置是2,5位置是清算阶段弹出的，所以res[5] = {2,-1}; * 弹出2位置，栈中它的下面没有位置了,2位置是清算阶段弹出的，所以res[2] = {-1,-1}; * */ 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 单调栈——返回最近邻的位置 */public class MonotoneStack2 { public static int[][] getNearLessNoRepeat(int[] arr){ int[][] res = new int[arr.length][2]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); //遍历阶段 for (int i = 0; i &lt; arr.length; i++) { while (!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[stack.peek()]){ int popIndex = stack.pop(); int leftLessIndex = stack.isEmpty() ? -1 : stack.peek(); res[popIndex][0] = leftLessIndex; res[popIndex][1] = i; } stack.push(i); } //开始清算阶段 while(!stack.isEmpty()){ int popIndex = stack.pop(); int leftLessIndex = stack.isEmpty() ? -1 : stack.peek(); res[popIndex][0] = leftLessIndex; res[popIndex][1] = -1; } return res; } public static void printArr2(int[][] arr){ for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[0].length; j++) { System.out.print(arr[i][j]+\" \"); } System.out.println(\"\"); } } public static void main(String[] args) { int[] arr = {3,4,1,5,6,2,7}; int[][] res = getNearLessNoRepeat(arr); printArr2(res); }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"}]},{"title":"Leetcode题解-栈和队列","slug":"Leetcode题解-栈和队列","date":"2021-08-02T07:38:51.000Z","updated":"2021-08-02T14:00:13.533Z","comments":true,"path":"posts/b04a.html","link":"","permalink":"https://www.colorfo.top/posts/b04a.html","excerpt":"","text":"[toc] 1.用栈实现队列栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class StackForQueue { //首先准备两个栈 private Stack&lt;Integer&gt; in = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; out = new Stack&lt;&gt;(); //首先将元素压入第一个栈 public void push(Integer val){ in.push(val); } //将入栈的数据弹出，压入出栈中 //在这个过程中，必须保证出栈为空 public void in2out(){ if (out.isEmpty()){ //如果出栈为空，才操作 while(!in.isEmpty()){ out.push(in.pop()); } } } //相当于一个出队列的操作 public int pop(){ //先将 入栈 中的数据 压入到出栈中，这样，经过栈的两次“先进后出”，就实现了队列的“先进先出” in2out(); return out.pop(); } //查看当前的队列的头 public int peek(){ in2out(); return out.peek(); } //判断队列是否为空 public boolean isEmpty(){ return in.isEmpty() &amp;&amp; out.isEmpty(); } //编写一个main方法测试一下结果 *********************************************** public static void main(String[] args) { StackForQueue queue = new StackForQueue(); for (int i = 1; i &lt;= 8; i++) { queue.push(i); } for (int i = 0; i &lt; 8; i++) { System.out.println(queue.pop()); } }} 2.用队列实现栈在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 在队列这种数据结构中，最先插入的元素将是最先被删除的元素； * 反之最后插入的元素将是最后被删除的元素，因此队列又称为“先进先出”（FIFO—first in first out）的线性表。 * * Queue用法小结： * Queue使用时要尽量避免Collection的add()和remove()方法， * 而是要使用offer()来加入元素，使用poll()来获取并移出元素。 * 它们的优点是通过返回值可以判断成功与否。 * 而add()和remove()方法在失败的时候会抛出异常。 * 如果要使用前端而不移出该元素，使用element()或者peek()方法。 */public class QueueForStack { private Queue&lt;Integer&gt; queue; public QueueForStack(){ //LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用 queue = new LinkedList&lt;&gt;(); } public void push(int val){ //首先将val加入到队列中，此时，val位于队列的最后一位 queue.offer(val); //获取队列的大小 int count = queue.size(); while (count &gt; 1){ //将当前队列的除val之外的所有元素，先取出队列，再放入队列 //此时，val就位于队列的首位，那么，就实现了栈的“后进先出” queue.offer(queue.poll()); count--; } } public int pop(){ return queue.poll(); } public int peek(){ //查看当前的队列头 return queue.peek(); } public boolean isEmpty(){ return queue.isEmpty(); } //编写一个main方法，测试一下 ***************************************** public static void main(String[] args) { QueueForStack queue = new QueueForStack(); for (int i = 1; i &lt;= 8; i++) { queue.push(i); } for (int i = 0; i &lt; 8; i++) { System.out.println(queue.pop()); } }} 3.最小值栈：设计一个有getMin功能的栈 题目：实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作 要求： 1.pop,push,getMin操作的时间复杂度都是O(1) 设计的栈类型可以使用现成的栈结构 思路分析：在设计时，使用两个栈，一个栈用来保存所有的元素，其功能和一个正常的栈没有区别，这个栈记为dataStack. 另一个用来保存每一步的最小值，这个栈的栈针始终指向当前放入栈中元素的最小值，这个栈记为minStack. 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MyMinStack { private Stack&lt;Integer&gt; dataStack; private Stack&lt;Integer&gt; minStack; public MyMinStack(){ dataStack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); } public void push(int data){ dataStack.push(data); //当minStack为空时，放入data if (minStack.isEmpty()){ minStack.push(data); }else { //当minStack不为空时,如果minStack的栈顶元素大于data时， // 将data放入minStack,此时就能保证,minStack的栈顶元素为dataStack的最小值 if(minStack.peek() &gt; data){ minStack.push(data); } } } public int pop(){ if (dataStack.isEmpty()){ throw new RuntimeException(\"Your Stack is empty!!!\"); } return dataStack.pop(); } public int getMin(){ if (minStack.isEmpty()){ throw new RuntimeException(\"Your Stack is empty!\"); } return minStack.peek(); } public boolean isEmpty(){ return dataStack.isEmpty(); } //编写一个main测试一下****************************************** public static void main(String[] args) { MyMinStack stack = new MyMinStack(); stack.push(1); stack.push(3); stack.push(5); stack.push(2); stack.push(2); stack.push(4); stack.push(1); stack.push(8); stack.push(2); System.out.println(stack.getMin()); //1 }} ​ 对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。 4. 用栈实现括号的匹配（Easy）力扣 12345678910case1:Input:\"()[]{}\"Output : true case2:Input:\"({})\"Output : true 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 用栈实现括号的匹配 * * Input:\"()[]{}\" * * Output : true */public class ValidParentheses { private Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); public boolean isValid(String s){ for (char c : s.toCharArray()){ if (c == '(' || c == '{' || c == '['){ //当满足\"左括号\"的条件时，压入栈中 stack.push(c); }else{ //如果此时栈中还为空，则不满足条件 if (stack.isEmpty()){ return false; } //走到这一步，说明栈中不为空，此时\"c\"，满足为括号的右半部分 //此时弹栈拿出括号的坐半部分left char left = stack.pop(); //以下三个条件说明，在弹栈得到的left时,括号右半部分匹配不上，就返回false; boolean b1 = left == '(' &amp;&amp; c != ')'; boolean b2 = left == '{' &amp;&amp; c != '}'; boolean b3 = left == '[' &amp;&amp; c != ']'; if (b1 || b2 || b3){ return false; } } } return stack.isEmpty(); } //测试 ******************************* public static void main(String[] args) { ValidParentheses vp = new ValidParentheses(); System.out.println(vp.isValid(\"()\")); //true System.out.println(vp.isValid(\"()[]{}\")); //true System.out.println(vp.isValid(\"{[]}\")); //true System.out.println(vp.isValid(\"(]\")); //false System.out.println(vp.isValid(\"([)]\")); //false }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://www.colorfo.top/tags/%E9%98%9F%E5%88%97/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.colorfo.top/tags/LeetCode/"}]},{"title":"利用数组实现栈","slug":"利用数组实现栈","date":"2021-08-01T13:20:26.000Z","updated":"2021-08-01T14:51:43.284Z","comments":true,"path":"posts/c93a.html","link":"","permalink":"https://www.colorfo.top/posts/c93a.html","excerpt":"","text":"本例子利用数组实现”栈”这种数据结构，算一个栈的入门案例 栈的特点：先进后出，后进先出 在实现栈的弹栈，压栈的操作之前，要判断栈是否为空栈或满栈 数组的长度即为栈的容量 写一个ArrayForStack类，在这个类中，实现栈的弹栈、压栈等方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ArrayForStack { private int maxSize; private int[] array; //栈针 private int top = -1; public ArrayForStack(){ } //有参构造方法，利用构造方法给属性赋值 public ArrayForStack(int maxSize){ this.maxSize = maxSize; this.array = new int[maxSize]; } public boolean isEmpty(){ return top == -1; } public boolean isFull(){ return top == maxSize-1; } public void push(int num) throws Exception { if (isFull()){ throw new Exception(\"栈已经满了，不能继续压栈了\"); } array[++top] = num; } public int pop() throws Exception { if (isEmpty()){ throw new Exception(\"栈已经空了，不能弹栈\"); } int temp; temp = array[top--]; return temp; }} 编写一个测试类，测试栈的方法 12345678910111213141516171819public class StackTest { public static void main(String[] args) throws Exception { //栈的容量 int maxSize = 6; ArrayForStack stack = new ArrayForStack(maxSize); //压栈 for (int i = 0; i &lt; maxSize; i++) { stack.push(i); //依次压入0 1 2 3 4 5 } //弹栈 for (int i = 0; i &lt; maxSize; i++) { System.out.println(stack.pop()); //依次弹出5 4 3 2 1 0 } }} 接下来利用上面编写的ArrayForStack类，再实现一个回文字符串判断的例子 所谓的回文字符串即为：从左往右 与 从右往左 读这个字符串，结果是一样的 比如：”aba”就是一个回文串，而:”hello”,从右往左为”olleh”,则”hello”不是一个回文串 1234567891011121314151617181920212223242526272829303132public class TestPalindrome { public static void main(String[] args) throws Exception { System.out.println(detection(\"abcdedcba\")); //true } public static boolean detection(String str) throws Exception { int length = str.length(); ArrayForStack stack = new ArrayForStack(length); for (int i = 0; i &lt; length; i++) { stack.push(str.charAt(i)); } String newStr = \"\"; for (int i = 0; i &lt; length; i++) { if (!stack.isEmpty()){ char s = (char)stack.pop(); newStr += s; } } if (str.equals(newStr)){ return true; } return false; }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"},{"name":"数组","slug":"数组","permalink":"https://www.colorfo.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"回文","slug":"回文","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%96%87/"}]},{"title":"github高效搜索项目","slug":"github高效搜索项目","date":"2021-07-31T08:56:16.000Z","updated":"2021-07-31T09:18:54.323Z","comments":true,"path":"posts/2a1b.html","link":"","permalink":"https://www.colorfo.top/posts/2a1b.html","excerpt":"","text":"利用项目名(仓库名) 例如in:name spring boot 利用项目名+stars in:name spring boot stars:&gt;1000 利用项目名+stars+forks in:name spring boot stars:&gt;1000 forks:&gt;100 利用readme in:readme springboot 利用readme+stars in:readme springboot stars:&gt;1000 利用description in:description 微服务 利用description + language in:description 微服务 language:java 利用description + language+日期 in:description 微服务 language:java pushed:&gt;2019-9-9 点进去查看项目的：描述利用了那些技术，代码结构、最新push日期、火热程度等，查看项目的readme文档 把github用起来，多去github看开源项目","categories":[],"tags":[{"name":"github搜索","slug":"github搜索","permalink":"https://www.colorfo.top/tags/github%E6%90%9C%E7%B4%A2/"}]},{"title":"git和github的使用","slug":"git和github的使用","date":"2021-07-30T08:42:22.000Z","updated":"2021-07-31T06:57:42.597Z","comments":true,"path":"posts/ec43.html","link":"","permalink":"https://www.colorfo.top/posts/ec43.html","excerpt":"","text":"[toc] git1.Git常用命令 2.分支的操作 3.远程仓库操作 4.IDEA集成git、github 1.确保idea已经集成了git和github 2.回到idea主界面，创建一个git repository 3.将代码加入暂存区 代码加入暂存区后，文件名由红色变为蓝色 4.将代码提交至本地库 代码提交至本地库后，文件名由蓝色变为正常的白色 5.查看git的log和master信息 切换version 创建分支 6.合并分支 在hot_fix分支下，加一行代码，并提交至本地库 注意：master分支想要合并hot_fix分支，必须在master分支下merge 已经切换至master 开始合并 成功合并 备注：以上演示的为无冲突合并，如果遇到冲突合并(简单理解为：对代码做了不同的修改)，需要进行手动选择代码，然后合并 7.将代码推送至远程github仓库 7.1 使用ssh免密登陆 进入C:/Users/Administrator/.ssh文件夹，右键选择“Git Bash Here ” 在命令行输入ssh-keygen -t rsa -C 邮箱 ，连续三次回车(其中有一次问你，要不要覆盖文件) 然后输入cat id_rsa.pub ,得到其文件内容，如下图 复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys →New SSH key 新建一个SSH key 7.2新建一个远程github仓库，用来储存来自本地仓库的代码，如下图 方式二，新建github仓库 7.3push代码到github仓库 push代码的重要提示 注意： push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说， 要想 push 成功，一定要保证本地库的版本要比远程库的版本高！ 因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送！ 8 pull 拉取远程库到本地库 首先更新一下github仓库的代码，以示本地和远程的区别 9.克隆代码到本地，并利用idea打开","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.colorfo.top/tags/git/"},{"name":"github","slug":"github","permalink":"https://www.colorfo.top/tags/github/"}]},{"title":"springboot集成mybatis-plus","slug":"springboot集成mybatis-plus","date":"2021-07-28T05:05:31.000Z","updated":"2021-07-28T11:29:26.531Z","comments":true,"path":"posts/667f.html","link":"","permalink":"https://www.colorfo.top/posts/667f.html","excerpt":"","text":"本博客基于springboot-web项目，集成thymeleaf，和mybatis-plus可以实现数据的CRUD和分页显示数据功能 案例一：实现数据的CRUD 依赖及配置 1.新建一个springboot-web项目，并选中thymeleaf模板引擎 2.加入依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 3.配置mysql的账号密码 1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=mysql密码 代码详情 1.控制层代码 1234567891011121314151617181920@Controllerpublic class MybatisController { //自动注入业务层的StudentService @Autowired private StudentService studentService; @RequestMapping(\"/queryAll\") //请求路径 public String queryAll(Model model){ //调用业务层的方法，查询所有学生 List&lt;Student&gt; students = studentService.list(); model.addAttribute(\"students\",students); //将查询结果放入request作用域，并返回到视图层 return \"mybatis-plus\"; }} 2.业务层代码(包括一个接口和实现类) 1234public interface StudentService extends IService&lt;Student&gt; { //IService&lt;T&gt; 中的 T 是实体} IService为mybatis-plus提供的接口，里面提供了CRUD的基本方法,我们的业务层接口需要实现IService这个接口 3.业务接口实现类 12345@Servicepublic class StudentServiceImpl extends ServiceImpl&lt;StudentMapper, Student&gt; implements StudentService { //ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; 中的泛型：M 是 mapper 对象，T 是实体} StudentServiceImpl 继承了ServiceImpl，而ServiceImpl是IService 实现类，它提供了IService中方法的具体实现。我们写的业务接口实现类需要继承ServiceImpl这个类，并且要实现我们自己写的StudentService这个接口 下面给出ServiceImpl类的部分代码 12//IService 实现类（ 泛型：M 是 mapper 对象，T 是实体 ）public class ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; implements IService&lt;T&gt; {} 4.持久层代码 1234@Mapperpublic interface StudentMapper extends BaseMapper&lt;Student&gt; {} StudentMapper继承了 BaseMapper这一接口，当我们编写的Mapper接口 继承该接口后，无需编写 mapper.xml 文件，即可获得CRUD功能 说明：除了在该类的上面添加@Mapper,注明这是一个持久层之外，还可以在程序的主入口添加@MapperScan注解(两个注解选择一个使用即可) 5.实体类 1234567891011121314151617@TableName(\"t_student\")public class Student { @TableField(exist = false) private String email; private Integer id; private String name; private Integer age; setter and getter toString } @TableName(“t_student”)由mybatis-plus提供，作用使该实体类与对应的数据库中的表名对应，例如类Student&lt;===&gt;表t_student @TableField(exist = false)由mybatis-plus提供,作用是标注出，数据库中的表不存在该字段 5.视图层的代码(由控制层转到视图层mybatis-plus.html) 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;查询所有学生&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div &gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"student:${students}\"&gt; &lt;!--thymeleaf循环一个list--&gt; &lt;td&gt;[[${student.id}]]&lt;/td&gt; &lt;!--thymeleaf的行内写法，取出相应的变量--&gt; &lt;td&gt;[[${student.name}]]&lt;/td&gt; &lt;td&gt;[[${student.age}]]&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6查询结果 与数据库中的数据一致 案例二：实现分页数据的展示 数据的分页展示，在案例一的基础上修改而来 分页功能具体实现 1.新建一个配置类，用来加载分页插件 123456789101112@Configuration//@Deprecatedpublic class MyBatisPlusConfig { @Bean public PaginationInterceptor paginationInterceptor() { System.out.println(\"加载分页插件\"); return new PaginationInterceptor(); }} 2.修改控制层代码 12345678910111213141516171819202122232425@Controller@Slf4jpublic class MybatisController { @Autowired private StudentService studentService; @RequestMapping(\"/queryAll\") public String queryAll(@RequestParam(value = \"pn\",defaultValue = \"1\") Integer pn, Model model){ //分页查询，pn表示当前页，6表示每页几条数据 Page&lt;Student&gt; studentPage = new Page&lt;&gt;(pn,6); //分页查询结果 Page&lt;Student&gt; page = studentService.page(studentPage, null); page.getCurrent(); //获取当前页 page.getPages(); //获取总的页数 page.getTotal(); //获取总记录数 model.addAttribute(\"page\",page); return \"mybatis-plus\"; }} 访问路径为“/queryAll”,请求参数为pn,表示当前页，默认为1 调用studentService.page(),即可得到Page对象，其内部属性，就是我们想要的与分页功能相关的数据 将page放入request作用域 3.修改视图显示的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;查询所有学生&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div &gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"student:${page.records}\"&gt; &lt;!--thymeleaf循环一个list--&gt; &lt;td&gt;[[${student.id}]]&lt;/td&gt; &lt;!--thymeleaf的行内写法，取出相应的变量--&gt; &lt;td&gt;[[${student.name}]]&lt;/td&gt; &lt;td&gt;[[${student.age}]]&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;br&gt; &lt;!--上方展示的student详情的list集合，必须从page.records中取--&gt; &lt;!--#########################以下内容与分页功能相关###############################--&gt; &lt;!--[[${page.current}]]为thymeleaf的写法，可以取出request域的变量--&gt; &lt;!--page.current、page.pages、page.total都是放在request作用域中的变量page的属性}--&gt; &lt;div&gt;当前第 [[${page.current}]] 页 总计 [[${page.pages}]] 页 共 [[${page.total}]] 条记录&lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;!--#numbers.sequence(1,page.pages)，该表达式是thymeleaf的写法。 表示可以生成一个从\"1\"到\"page.pages\"的序列,然后用thymeleaf的foreach循环，就可以得到页码num了--&gt; &lt;li th:each=\"num:${#numbers.sequence(1,page.pages)}\" &gt; &lt;!--下面的写法为thymeleaf的超链接写法 [[${num}]]用来显示页码数 @{/queryAll(pn=${num})}表示超链接的链接地址,(pn=${num})表示请求参数 @{/queryAll(pn=${num})}等价于@{/queryAll?pn=num} --&gt; &lt;a th:href=\"@{/queryAll(pn=${num})}\"&gt;[[${num}]]&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 前端分页功能代码的说明见注释 结果展示","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/tags/springboot/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://www.colorfo.top/tags/mybatis-plus/"},{"name":"分页","slug":"分页","permalink":"https://www.colorfo.top/tags/%E5%88%86%E9%A1%B5/"}]},{"title":"springboot定制化组件的方式","slug":"springboot定制化组件的方式","date":"2021-07-27T11:58:08.000Z","updated":"2021-07-27T12:17:50.877Z","comments":true,"path":"posts/4e7c.html","link":"","permalink":"https://www.colorfo.top/posts/4e7c.html","excerpt":"","text":"定制化组件的常见方式 修改配置文件； xxxxxCustomizer； 编写自定义的配置类 xxxConfiguration；+ @Bean替换、增加容器中默认组件；视图解析器 Web应用 编写一个配置类实现 WebMvcConfigurer 即可定制化web功能；(+ @Bean给容器中再扩展一些组件,可选的) 12@Configurationpublic class AdminWebConfig implements WebMvcConfigurer{} @EnableWebMvc + WebMvcConfigurer —— @Bean 可以全面接管SpringMVC，所有规则全部自己重新配置； 实现定制和扩展功能 原理 1、WebMvcAutoConfiguration 默认的SpringMVC的自动配置功能类。静态资源、欢迎页….. 2、一旦使用 @EnableWebMvc 会 @Import(DelegatingWebMvcConfiguration.class) 3、DelegatingWebMvcConfiguration 的 作用，只保证SpringMVC最基本的使用 把所有系统中的 WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer 合起来一起生效 自动配置了一些非常底层的组件。RequestMappingHandlerMapping、这些组件依赖的组件都是从容器中获取 public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport 4、WebMvcAutoConfiguration 里面的配置要能生效 必须 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 5、@EnableWebMvc 导致了 WebMvcAutoConfiguration 没有生效。","categories":[],"tags":[{"name":"springboot定制化组件","slug":"springboot定制化组件","permalink":"https://www.colorfo.top/tags/springboot%E5%AE%9A%E5%88%B6%E5%8C%96%E7%BB%84%E4%BB%B6/"}]},{"title":"SpringBoot文件上传","slug":"SpringBoot文件上传","date":"2021-07-27T07:56:20.000Z","updated":"2021-08-01T08:31:15.837Z","comments":true,"path":"posts/c59d.html","link":"","permalink":"https://www.colorfo.top/posts/c59d.html","excerpt":"","text":"[toc] 简介 springboot中文件上传，可以将上传的文件保存到本地，或者保存到文件服务器，OSS 下面通过一个springboot-thymeleaf项目，演示这一过程 项目流程 1.浏览器地址栏访问：http:localhost:8080/,跳转到templates/file_form.html 2.在file_form.html页面，选择需要上传的文件(支持单个、多个文件上传，文件的最大值在配置文件中指定)，提交后转到控制层的upload方法 3.在upload方法中，上传的文件被保存到本地 代码演示 项目文件结构 控制层代码 123456789101112131415161718192021222324252627282930313233@Controllerpublic class MyController { @RequestMapping(\"/\") public String upload(){ return \"file_form\"; } @PostMapping(\"/upload\") @ResponseBody public String upload(@RequestPart(\"picture\") MultipartFile picture, @RequestPart(\"photos\") MultipartFile[] photos) throws IOException { if(!picture.isEmpty()){ String originalFilename = picture.getOriginalFilename(); //保存文件到本地 picture.transferTo(new File(\"E:\\\\test\\\\\"+originalFilename)); } if (photos.length &gt; 0){ for (MultipartFile photo : photos) { if (!photo.isEmpty()){ String originalFilename = photo.getOriginalFilename(); //保存文件到本地 photo.transferTo(new File(\"E:\\\\test\\\\\"+originalFilename)); } } } return \"文件上传成功\"; }} 前端的file_form.html页面 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"post\" th:action=\"@{/upload}\" enctype=\"multipart/form-data\" &gt; 单个文件:&lt;input type=\"file\" name=\"picture\"&gt;&lt;br&gt; 多个文件:&lt;input type=\"file\" name=\"photos\" multiple&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 项目的配置文件 1234# 上传总文件的最大值spring.servlet.multipart.max-request-size=100MB# 单个文件的最大值spring.servlet.multipart.max-file-size=10MB 启动程序 123456789@SpringBootApplicationpublic class SpringbootFileUploadApplication { public static void main(String[] args) { SpringApplication.run(SpringbootFileUploadApplication.class, args); }}","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://www.colorfo.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"Interceptor拦截器的使用","slug":"Interceptor拦截器的使用","date":"2021-07-26T13:43:47.000Z","updated":"2021-07-26T14:37:16.414Z","comments":true,"path":"posts/ce45.html","link":"","permalink":"https://www.colorfo.top/posts/ce45.html","excerpt":"","text":"springboot项目中拦截器的使用 1.编写一个拦截器实现HandlerInterceptor接口 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors） 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】 1.实现HandlerInterceptor接口123456789101112131415161718192021222324252627282930313233@Slf4jpublic class MyInterceptor implements HandlerInterceptor { //目标方法执行之前，进行拦截 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(\"preHandle方法执行了{}\",request.getRequestURI()); String userName = (String) request.getSession().getAttribute(\"userName\"); if(userName != null){ return true; } request.getRequestDispatcher(\"/\").forward(request,response); return false; } //目标方法执行完成之后 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.info(\"postHandle方法执行了{}\",modelAndView); } //页面渲染之后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { log.info(\"afterCompletion方法执行了\"); }} 2.拦截器注册到容器中 实现WebMvcConfigurer的addInterceptors 1234567891011@Configurationpublic class MyConfiguration implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()) .addPathPatterns(\"/**\") //需要拦截的资源 .excludePathPatterns(\"/\",\"/login\"); //需要放行的资源 }} 3.拦截器原理1、根据当前请求，找到HandlerExecutionChain【可以处理请求的handler以及handler的所有 拦截器】 2、先来顺序执行 所有拦截器的 preHandle方法 1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle 2、如果当前拦截器返回为false。直接 倒序执行所有已经执行了的拦截器的 afterCompletion； 3、如果任何一个拦截器返回false。直接跳出不执行目标方法 4、所有拦截器的prehandler都返回true，才执行目标方法 5、倒序执行所有拦截器的postHandle方法。 6、前面的步骤有任何异常都会直接倒序触发 afterCompletion 7、页面成功渲染完成以后，也会倒序触发 afterCompletion","categories":[],"tags":[{"name":"Interceptor","slug":"Interceptor","permalink":"https://www.colorfo.top/tags/Interceptor/"}]},{"title":"springboot集成websocket实现聊天室的index.jsp代码","slug":"springboot集成websocket实现聊天室的index-jsp代码","date":"2021-07-25T06:54:58.000Z","updated":"2021-07-25T13:30:24.709Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://www.colorfo.top/posts/undefined.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"${pageContext.request.contextPath}/js/jquery.min.js\"&gt;&lt;/script&gt; &lt;title&gt;SpringBoot+WebSocket+JSP&lt;/title&gt;&lt;/head&gt;&lt;body style=\"margin: 45px;\"&gt; &lt;h4&gt;在线聊天室&lt;/h4&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"content\"&gt;&lt;/label&gt; &lt;textarea id=\"content\" readonly=\"readonly\" cols=\"80\" rows=\"15\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"form-group\" style=\"margin-top: 8px\"&gt; &lt;textarea id=\"message\" cols=\"80\" rows=\"5\" placeholder=\"请输入消息\"&gt;&lt;/textarea&gt; &lt;div style=\"margin-top: 10px\"&gt; &lt;button id=\"toSend\" class=\"btn btn-info\"&gt;发送&lt;/button&gt; &lt;button id=\"user_exit\" class=\"btn btn-danger\"&gt;离开&lt;/button&gt; &lt;input id=\"username\" value=\"${username}\" style=\"display: none\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; $(function () { var ws; if (\"WebSocket\" in window) { var baseUrl = 'ws://localhost:8080/websocket/'; var userName = $('#username').val(); ws = new WebSocket(baseUrl + userName); // 连通之后的回调事件，建立连接 ws.onopen = function () { console.log(\"建立 websocket 连接...\"); }; // 接收后台服务端的消息 ws.onmessage = function (event) { $('#content').append(event.data + '\\n\\n'); console.log(\"接收到服务端发送的消息...\" + event.data + '\\n'); }; ws.onerror = function (event) { console.log(\"websocket发生错误...\" + event + '\\n'); } // 连接关闭的回调事件 ws.onclose = function () { $('#content').append('[' + userName + '] 已离开!'); console.log(\"关闭 websocket 连接...\"); }; } else { // 浏览器不支持 WebSocket alert(\"您的浏览器不支持WebSocket!\"); } // 客户端发送消息到服务器 $('#toSend').click(function () { sendMsg(); }); $(document).keyup(function (event) { // 回车键事件 if (event.keyCode == 13) { sendMsg(); } }); // 发送消息 function sendMsg() { //websocket发送消息 ws.send($('#message').val()); $('#message').val(\"\"); } // 退出 $('#user_exit').click(function () { if (ws) { ws.close(); } }); }); &lt;/script&gt;&lt;/body&gt;&lt;%--此页面的源代码即为index.jsp的代码--%&gt;&lt;%--点击右键即可查看网页源代码--%&gt;&lt;/html&gt;","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"}]},{"title":"springboot集成websocket实现聊天室","slug":"springboot集成websocket实现聊天室","date":"2021-07-25T04:04:39.000Z","updated":"2021-07-25T13:30:26.881Z","comments":true,"path":"posts/3a35.html","link":"","permalink":"https://www.colorfo.top/posts/3a35.html","excerpt":"","text":"1.websocket简介WebSocket协议WebSocket协议是由HTML5定义的，基于TCP协议实现的一种网络协议，通过该协议服务器可以主动向客户端发送信息； WebSocket 协议在2008年诞生，2011年成为W3C国际标准；我们已经有了 HTTP 协议，为什么出现一个websocket协议？ http协议是短连接，因为请求之后，都会关闭连接，下次重新请求数据，需要再次打开链接；WebSocket协议是一种长连接，只需要通过一次请求来初始化连接，然后所有的请求和响应都是通过这个TCP连接进行通讯； 所以HTTP协议通信只能是客户端向服务器发出请求，服务器返回响应结果，HTTP 协议做不到服务器主动向客户端推送信息，而websocket能实现服务器和客户端全双工通信； 何谓全双工 信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工，信息能够同时双向传送则称为全双工； 基本实现原理 WebSocket协议基于TCP协议实现，客户端和服务器只需要做一个握手的动作之后，形成了一条基于客户端和服务器之间的快速通道，之后客户端与服务端之间便可以进行多次数据帧双向传输；这样实现的目的是客户端和服务器进行频繁双向通信时，可以使服务器避免频繁创建HTTP连接，节约资源，提高工作效率和资源利用率。 传统Web推送实现​ 在没有WebSocket协议之前，服务器如何向浏览器端推送消息？通常的实现方式是在页面通过Ajax定时轮询，比如每隔1秒中向服务器发送一次HTTP请求，询问服务器是否有新消息，服务器返回结果；这种形式缺点很明显，浏览器需要不断的向服务器发出HTTP请求，而HTTP请求包含较长的头部，有效信息相对较少，反复的无效请求占用了大量的带宽和 CPU 资源，造成很大的浪费，所以，WebSocket 应运而生；HTML5定义的WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯； WebSocket协议本质上是一个基于TCP的协议，因此与HTTP协议没有什么关系； WebSocket的特点全双工通信，客户端和服务器可以双向平等通信； 建立在TCP协议之上，服务器端的实现比较容易； 数据格式比较轻量，性能开销小，通信高效； 可以发送文本，也可以发送二进制数据； 通信具有更强的实时性； 协议标识符是ws，服务器地址就是：ws://www.abc.com/some/path http协议： http:// websocket的业务场景WebSocket聊天室； 股票实时价格显示等应用； 即时通讯、游戏、可视化大屏展示等领域； 企业内部管理通讯等功能，主要通讯协议websocket； web网页聊天、客服系统实现； 系统提醒、用户上下线提醒、客户端同步，实时数据更新，多屏幕同步，用户在线状态，消息通知，扫描二维码登录/二维码支付，弹幕、各类信息提醒，在线选座，实时监控大屏等等； Java中的WebSocket API在Java EE 7中Java语言开始支持websocket协议，Java EE 7中定义了一套Websocket API规范，也就是一系列接口，没有实现，位于包javax.websocket下，包含客户端API和服务端API，WebSocket的Java API 只是规范，具体实现需要web容器（比如tomcat就实现了Java websocket api）、Java EE服务器或者框架提供； 在java中服务端的实现 1、Tomcat：java中的websocket实现，需要tomcat 7.0.47+以上才支持， Java EE7的支持； 2、Spring的websocket，需要Spring 4.x，所以springboot也可以用； 2.Websocket开发相关注解及API方法websocket注解 @ServerEndpoint(“/websocket/{uid}”) 申明这是一个websocket服务； 需要指定访问该服务的地址，在地址中可以指定参数，需要通过{}进行占位； @OnOpen 用法：public void onOpen(Session session, @PathParam(\"uid\") String uid) throws IOException{} 该方法将在建立连接后执行，会传入session对象，就是客户端与服务端建立的长连接通道，通过@PathParam获取url中声明的参数； @OnClose 用法：public void onClose() {} 该方法是在连接关闭后执行； @OnMessage 用法：public void onMessage(String message, Session session) throws IOException {} 该方法用于接收客户端发送的消息； message：发来的消息数据； session：会话对象（也是长连接通道）； 发送消息到客户端； 用法：session.getBasicRemote().sendText(\"hello,websocket.\"); 通过session进行消息发送； 前端技术对websocket的支持Websocket是html5规范，主流浏览器都支持；（某些老浏览器不支持） jQuery、vueJS、React JS、angularjs等都可以支持webscoket对象； 底层是javascript支持的一个webscoket的js对象，通过这个对象可以建立websocket的连接：ws://localhost:8080/websocket/12345 WebSocket有很多优点，弥补了http协议的不足，但是如果服务端维护很多长连接也是很耗费资源的，服务器集群带来了复杂性以及存在老版本浏览器兼容性问题，各大厂目前大多数还是基于轮询的方式实现的，比如：扫码登录、支付成功通知、秒杀成功通知等； 在秒杀场景中，用轮询即可，前端轮询一般不可能穿透到后端数据库查询，一般是采用高性能的缓存标记来判定秒杀是否成功，相对于websocket长连接以及其不确定因素，轮询依然是相对比较合适的方案； Websocket各浏览器的支持情况： https://caniuse.com/#search=websocket 3.springboot集成WebSocket实现多人聊天室 项目代码结构分布 pom文件依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;!--此项目的GAV坐标--&gt; &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt; &lt;artifactId&gt;041-springboot-websocket&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--springboot web项目的起步依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--spring-boot-starter-websocket--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok,需要在IDEA中安装lombok插件才能使用该依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入Spring Boot内嵌的Tomcat对JSP的解析包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署插件(该依赖不是必选项)--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;!--src/main/java下的.xml配置文件编译到target下去--&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!--src/main/resources下的配置文件编译到target下去--&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!--src/main/webapp下的jsp页面编译到META-INF/resources下才能访问--&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 前端代码 项目的主配置文件application.properties 123#设置jsp文件的前缀和后缀spring.mvc.view.prefix=/spring.mvc.view.suffix=.jsp index.jsp文件详情 1234hexo博客不能正常显示jsp格式的代码代码详情见本站的博文：\"springboot集成websocket实现聊天室的index-jsp代码\"，进入该博文页面后，点击右键即可查看index.jsp的源代码 还需要一个jquery.min.js文件，可以去网上下载 后端代码 后端代码结构 首先是endpoint包下的chatServerEndpoint.java 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.bjpowernode.endpoint;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import javax.websocket.*;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;import java.io.IOException;/** * 说明： * 1、@ServerEndpoint注解中指定WebSocket协议的地址； * 2、@OnOpen、@OnMessage、@OnClose、@OnError注解与WebSocket中监听事件对应 * **/@Slf4j //lombok jar包，帮我们自动生成一些代码：@Data@Component@ServerEndpoint(\"/websocket/{username}\")public class ChatServerEndpoint { /** * 连接建立时触发 */ @OnOpen public void openSession(@PathParam(\"username\") String username, Session session) { log.info(\"用户{}登录\", username); String message = \"用户[\" + username + \"] 已进入聊天室！\"; // 发送登录消息给其他人 WebSocketUtils.sendMessageAll(message); // 获取当前在线人数，发给自己 String onlineInfo = WebSocketUtils.getOnlineInfo(); //发送消息 WebSocketUtils.sendMessage(session, onlineInfo); // 添加自己到map中 WebSocketUtils.CLIENTS.put(username, session); } /** * 客户端接收服务端数据时触发 */ @OnMessage public void onMessage(@PathParam(\"username\") String username, String message) { log.info(\"发送消息：{}, {}\", username, message); //广播，把消息同步给其他客户端 WebSocketUtils.sendMessageAll(\"[\" + username + \"] : \" + message); } /** * 连接关闭时触发 */ @OnClose public void onClose(@PathParam(\"username\") String username, Session session) { // 当前的Session移除某个用户 WebSocketUtils.CLIENTS.remove(username); // 离开消息通知所有人 WebSocketUtils.sendMessageAll(\"[\" + username + \"] 已离开！\"); try { //关闭WebSocket Session会话 session.close(); log.info(\"{} 已退出, onclose\", username); } catch (IOException e) { e.printStackTrace(); log.error(\"onClose error\", e); } } /** * 通信发生错误时触发 */ @OnError public void onError(Session session, Throwable throwable) { try { //关闭WebSocket Session会话 session.close(); } catch (IOException e) { e.printStackTrace(); log.error(\"onError Exception\", e); } log.info(\"Throwable msg \" + throwable.getMessage()); }} endpoint包下的WebSocketUtils.java 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.bjpowernode.endpoint;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.websocket.RemoteEndpoint;import javax.websocket.Session;import java.io.IOException;import java.util.Map;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;public final class WebSocketUtils { private static final Logger logger = LoggerFactory.getLogger(WebSocketUtils.class); /** * 存储WebSocket session * &lt;p&gt; * 用户名为key，WebSocket Session对象为value */ public static final Map&lt;String, Session&gt; CLIENTS = new ConcurrentHashMap&lt;&gt;(); /** * 使用连接发送数据 * * @param session 用户session * @param message 发送内容 */ public static void sendMessage(Session session, String message) { if (session == null) { return; } final RemoteEndpoint.Basic basic = session.getBasicRemote(); if (basic == null) { return; } try { //发送 basic.sendText(message); } catch (IOException e) { e.printStackTrace(); logger.error(\"sendMessage IOException \", e); } } /** * 发送消息给其他所有人 * * @param message */ public static void sendMessageAll(String message) { CLIENTS.forEach((sessionId, session) -&gt; sendMessage(session, message)); } /** * 获取所有在线用户 */ public static String getOnlineInfo() { Set&lt;String&gt; userNames = CLIENTS.keySet(); if (userNames.size() == 0) { return \"当前无人在线...\"; } return CLIENTS.keySet().toString() + \"在线\"; }} 接着是controller包下的ChatController.java文件 1234567891011121314151617181920package com.bjpowernode.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.concurrent.atomic.AtomicInteger;@Controllerpublic class ChatController { private AtomicInteger idProducer = new AtomicInteger(); @RequestMapping(\"/\") public String index(Model model) { model.addAttribute(\"username\",\"user\" + idProducer.getAndIncrement()); return \"index\"; }} 项目启动后，访问根路径，转发到index.jsp 最后是config包下的WebSocketConfig.java文件 123456789101112131415161718192021package com.bjpowernode.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.config.annotation.EnableWebSocket;import org.springframework.web.socket.server.standard.ServerEndpointExporter;@EnableWebSocket //启用WebSocket支持@Configuration //表示配置类public class WebSocketConfig { /** * 配置ServerEndpointExporter的bean * * 该Bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint */ @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); }} 最后的最后，是程序的主入口Application.java，用来启动整个项目 123456789101112package com.bjpowernode;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 项目启动运行 在浏览器地址栏输入http://localhost:8080/ 示例如下 在另一个浏览器地址栏(或者相同浏览器新建一个窗口)输入http://localhost:8080/，即可实现多人聊天","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"}]},{"title":"springboot之-MatrixVariable注解使用","slug":"springboot之-MatrixVariable注解使用","date":"2021-07-24T14:51:43.000Z","updated":"2021-07-24T14:53:39.425Z","comments":true,"path":"posts/80aa.html","link":"","permalink":"https://www.colorfo.top/posts/80aa.html","excerpt":"","text":"简介​ 根据 URI 规范 RFC 3986 中 URL 的定义，路径片段中可以可以包含键值对。规范中没对对应的术语。一般 “URL 路径参数” 可以被应用，尽管更加独特的 “矩阵 URI” 也经常被使用并且相当有名。在 Spring MVC 它被称为矩阵变量。 矩阵变量可以出现在任何路径片段中，每一个矩阵变量都用分号（;）隔开。比如 /cars;color=red;year=2012。多个值可以用逗号隔开，比如color=red,green,blue，或者分开写 color=red;color=green;color=blue。 如果你希望一个 URL 包含矩阵变量，那么请求映射模式必须用 URI 模板来表示这些矩阵变量。这样的话，不管矩阵变量顺序如何，都能够保证请求可以正确的匹配。 Springboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。 下面用一个springboot项目演示 @MatrixVariable的具体使用方法 1.前端代码部分 项目的结构分布 前端index.html的代码如下 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;springboot注解之@MatrixVariable&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;springboot注解之@MatrixVariable&lt;/h1&gt;&lt;br/&gt;&lt;a href=\"/car/sell;num=10;brand=BYD,AuDi\"&gt;@MatrixVariable（矩阵变量）/car/{sell}&lt;/a&gt;&lt;br/&gt;&lt;a href=\"/boss/1;age=20/2;age=30\"&gt;@MatrixVariable（矩阵变量）/boss/{bossId}/{empId}&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; ​ 1.在/car/sell路径下访问，请求参数为num和brand 2.在/boss/{bossId}/{empId}路径下访问.请求参数age=20表示/boss/bossId?age=20. 而请求参数age=30则表示访问路径/boss/bossId/empId?age=30 2.后端代码部分2.1 配置类MyConfig.javaSpringboot 默认是无法使用矩阵变量绑定参数的。需要覆盖WebMvcConfigurer中的configurePathMatch方法。 12345678910111213141516171819package com.bjpowernode.springboot.conf;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.PathMatchConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.util.UrlPathHelper;@Configuration(proxyBeanMethods = false)public class MyConfig implements WebMvcConfigurer{ @Override public void configurePathMatch(PathMatchConfigurer configurer) { UrlPathHelper urlPathHelper = new UrlPathHelper(); urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); }} 2.2 控制器AnnotationController.java123456789101112131415161718192021222324252627282930313233343536373839package com.bjpowernode.springboot.web;import org.springframework.web.bind.annotation.*;import java.util.HashMap;import java.util.List;import java.util.Map;@RestControllerpublic class AnnotationController { @RequestMapping(\"/car/{path}\") public Map getCar(@MatrixVariable(\"num\") Integer num, @MatrixVariable(\"brand\") List&lt;String&gt; brand, @PathVariable(\"path\") String path){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"num\",num); map.put(\"brand\",brand); map.put(\"path\",path); return map; } @GetMapping(\"/boss/{bossId}/{empId}\") public Map getAge(@PathVariable(\"bossId\") Integer bossId, @PathVariable(\"empId\") Integer empId, @MatrixVariable(value = \"age\",pathVar = \"bossId\") Integer bossAge, @MatrixVariable(value = \"age\",pathVar = \"empId\") Integer empAge){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"bossId\",bossId); map.put(\"empId\",empId); map.put(\"bossAge\",bossAge); map.put(\"empAge\",empAge); return map; }} 2.3 主程序入口1234567891011121314package com.bjpowernode.springboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringbootAnnotationApplication { public static void main(String[] args) { SpringApplication.run(SpringbootAnnotationApplication.class, args); }} 3.结果演示 启动主程序SpringbootAnnotationApplication，在浏览器地址栏输入：http://localhost:8080/,可以得到如下页面 点击第一个链接，得到如下结果 点击第二个链接，得到如下结果","categories":[{"name":"springboot注解","slug":"springboot注解","permalink":"https://www.colorfo.top/categories/springboot%E6%B3%A8%E8%A7%A3/"}],"tags":[{"name":"MatrixVariable","slug":"MatrixVariable","permalink":"https://www.colorfo.top/tags/MatrixVariable/"}]},{"title":"markdown语法的使用、博文标题的使用","slug":"markdown语法的使用、博文标题的使用","date":"2021-06-19T07:40:00.000Z","updated":"2021-08-01T08:18:17.177Z","comments":true,"path":"posts/9892.html","link":"","permalink":"https://www.colorfo.top/posts/9892.html","excerpt":"","text":"[TOC] 关于博文的Front-matter的使用 Front-matter中的内容为非必填项，但建议至少填写title和date 最全示例 12345678910111213141516171819---title: 基于 Hexo GitHub 从零开始搭建个人博客date: 2019-12-30 09:25:00author: Sitoiimg: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Hexokeywords: Hexo GitHub blogtags: - Hexo - Blog - GitHub--- 转载自:https://sitoi.cn/posts/63466.html markdown 的基本语法1.斜体和粗体12341. *斜体*或者_斜体_2. **粗体**3. ***加粗斜体***4. ~~删除线~~ 显示效果： 斜体或者_斜体_ 粗体 加粗斜体 删除线 2.分级标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 3.超链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。 3.1 行内式 介绍：[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。 123示例：1. 欢迎访问[我的博客](www.colorfo.top)2. 欢迎访问[我的博客](www.colorfo.top \"colorfo\") 欢迎访问我的博客 欢迎访问我的博客 3.2 参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明：参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 12345678我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3][Leanote 笔记][2]是一个不错的[网站][]。[1]:http://www.google.com \"Google\"[2]:http://www.leanote.com \"Leanote\"[3]:http://www.colorfo.top \"自己的博客\"[网站]:http://http://blog.leanote.com/freewalk 显示效果： 我经常去的几个网站Google、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 更多内容请参考—&gt;原文链接：https://blog.csdn.net/witnessai1/article/details/52551362","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.colorfo.top/tags/markdown/"},{"name":"front-matter","slug":"front-matter","permalink":"https://www.colorfo.top/tags/front-matter/"}],"author":"QianJL"},{"title":"hexo博客的启动和部署","slug":"hexo博客的启动和部署","date":"2021-06-02T08:12:23.000Z","updated":"2021-06-03T11:29:48.212Z","comments":true,"path":"posts/be0d.html","link":"","permalink":"https://www.colorfo.top/posts/be0d.html","excerpt":"","text":"本篇博客主要记录hexo博客的启动和部署启动hexo博客 在blog文件夹下，输入cmd,进入Windows的命令提示行窗口 输入”hexo server”即可启动 hexo 博客 打开浏览器，输入地址：http://localhost:4000,即可从本地访问hexo博客 添加部署信息 在_config.yml文件中操作(_config.yml文件的最下面修改)，可以将博客部署到github或者gitee 例如我的设置为： 1234deploy:type: gitrepo: https://gitee.com/ColorQian/ColorQian.gitbranch: master 修改好配置后，运行如下命令，将代码部署到gitee 123hexo clean hexo generate hexo deploy 在gitee的Gitee Pages 页面更新部署 在浏览器地址栏输入：http://colorqian.gitee.io 即可访问博客","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.colorfo.top/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-04-15T08:12:23.000Z","updated":"2021-06-03T09:23:14.311Z","comments":true,"path":"posts/3d22.html","link":"","permalink":"https://www.colorfo.top/posts/3d22.html","excerpt":"","text":"关于我姓名：钱佳乐😄来自南京理工大学你可以通过邮箱联系我：qjl@njust.edu.cn 关于这个博客网站网站名：”http://colorqian.gitee.io\"我将会不定期的在这个网站上发布一些关于java的文章 技术支持程序羊","categories":[],"tags":[]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.colorfo.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/categories/springboot/"},{"name":"springboot注解","slug":"springboot注解","permalink":"https://www.colorfo.top/categories/springboot%E6%B3%A8%E8%A7%A3/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.colorfo.top/categories/Hexo/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://www.colorfo.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","permalink":"https://www.colorfo.top/tags/%E9%93%BE%E8%A1%A8/"},{"name":"约瑟夫环","slug":"约瑟夫环","permalink":"https://www.colorfo.top/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"name":"单链表","slug":"单链表","permalink":"https://www.colorfo.top/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"https://www.colorfo.top/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://www.colorfo.top/tags/%E9%98%9F%E5%88%97/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.colorfo.top/tags/LeetCode/"},{"name":"回文","slug":"回文","permalink":"https://www.colorfo.top/tags/%E5%9B%9E%E6%96%87/"},{"name":"github搜索","slug":"github搜索","permalink":"https://www.colorfo.top/tags/github%E6%90%9C%E7%B4%A2/"},{"name":"git","slug":"git","permalink":"https://www.colorfo.top/tags/git/"},{"name":"github","slug":"github","permalink":"https://www.colorfo.top/tags/github/"},{"name":"springboot","slug":"springboot","permalink":"https://www.colorfo.top/tags/springboot/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://www.colorfo.top/tags/mybatis-plus/"},{"name":"分页","slug":"分页","permalink":"https://www.colorfo.top/tags/%E5%88%86%E9%A1%B5/"},{"name":"springboot定制化组件","slug":"springboot定制化组件","permalink":"https://www.colorfo.top/tags/springboot%E5%AE%9A%E5%88%B6%E5%8C%96%E7%BB%84%E4%BB%B6/"},{"name":"文件上传","slug":"文件上传","permalink":"https://www.colorfo.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"Interceptor","slug":"Interceptor","permalink":"https://www.colorfo.top/tags/Interceptor/"},{"name":"websocket","slug":"websocket","permalink":"https://www.colorfo.top/tags/websocket/"},{"name":"MatrixVariable","slug":"MatrixVariable","permalink":"https://www.colorfo.top/tags/MatrixVariable/"},{"name":"markdown","slug":"markdown","permalink":"https://www.colorfo.top/tags/markdown/"},{"name":"front-matter","slug":"front-matter","permalink":"https://www.colorfo.top/tags/front-matter/"},{"name":"博客","slug":"博客","permalink":"https://www.colorfo.top/tags/%E5%8D%9A%E5%AE%A2/"}]}